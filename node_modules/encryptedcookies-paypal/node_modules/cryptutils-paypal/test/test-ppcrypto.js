/*global describe:false, before:false, it:false*/
'use strict';

var ppcryptutils = require('../lib'),
    async = require('async'),
    assert = require('chai').assert;

describe('PPCrypto', function () {

    var cookieStruct = new Buffer([91, -91, 92, 37, -41, -67, -124, 29, -57, 123, 3, 0, 0, 0, 0, 0, 10, 0, 0, 0, 87, 50, 19, 74, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);

    var encryptTestCookie = 'KIed4ZuzuUaptYM7aPu7v7Y-CwoKuJ3_TkcpcYVV0zH0yHCzFkTqnsHMLTKuSgtDHOHQhRSkLF8xs0866ucpGrVgimUGFW7yB66EfG5HxBKrIpDYJ9L0d0COWl_O4xoUwP7Q20';

    var configuration = {
        encryptionAlgorithm: 'desx',
        macAlgorithm: 'sha1',
        encryptionKey: new Buffer('1h1P/y6F/kg6OlM7oeTms2Yr6Lw=', 'base64'),
        macKey: new Buffer('SF4HNI/A1U3xPww2eylPqJNQIvU=', 'base64')
    };

    var configurationBeacon = {
        encryptionAlgorithm: 'des-ede3-cbc',
        macAlgorithm: 'sha1',
        encryptionKey: new Buffer('jtf5ScpoGd6NpM0h2FpOqSBhTsB6WK0p', 'base64'),
        macKey: new Buffer('EDqF73KW1QQagrDEx1g1LwPOJm0=', 'base64')
    };


    before(function (next) {
        next();
    });

    it('should seal Beacon URL', function (next) {
        var ppcrypto = ppcryptutils(configurationBeacon);

        ppcrypto.sealAndEncodeBeacon(new Buffer('p=12345678&t=12345&i=1.2.3.4&l=1&v=98765432'), function (data) {
            assert.strictEqual(data.toString(), 'm-Q8LCj4dm2Mzog5rnBPFzixGaZNCUYKuwYmfznfwrU9CbuYXNv1yQLhPSW9uTXkBol7xAC3ULNBYN57Ako2PGM-sOo1Lg6W_pRSZg');
            next();
        });
    });

    it('should unseal Beacon URL', function(next) {
        var ppcrypto = ppcryptutils(configurationBeacon);

        ppcrypto.decodeAndUnsealBeacon(new Buffer('m-Q8LCj4dm2Mzog5rnBPFzixGaZNCUYKuwYmfznfwrU9CbuYXNv1yQLhPSW9uTXkBol7xAC3ULNBYN57Ako2PGM-sOo1Lg6W_pRSZg', 'base64'), function(data) {
            assert.strictEqual( data.toString(), 'p=12345678&t=12345&i=1.2.3.4&l=1&v=98765432');
            next();
        });
    });

    it('should seal Hello World', function (next) {

        var ppcrypto = ppcryptutils(configuration);

        ppcrypto.sealAndEncode(new Buffer('Hello World'), function (data) {
            assert.strictEqual(data, 'EeID2labT1Xskqv5sMSXtAGUMDzrt1eljVgdzU5PTlCwKloaAodwdQDqfzW');
            next();
        });

    });

    it('should unseal Hello World', function (next) {

        var ppcrypto = ppcryptutils(configuration);

        ppcrypto.decodeAndUnseal(new Buffer('EeID2labT1Xskqv5sMSXtAGUMDzrt1eljVgdzU5PTlCwKloaAodwdQDqfzW'), function (data) {
            assert.strictEqual(data.toString(), 'Hello World');
            next();
        });

    });

    it('should seal cookie', function (next) {

        var ppcrypto = ppcryptutils(configuration);

        ppcrypto.sealAndEncodeNamed('user_session', cookieStruct, function (data) {
            assert.strictEqual(data, encryptTestCookie);
            next();
        });

    });

    it('should unseal cookie', function (next) {

        var ppcrypto = ppcryptutils(configuration);

        ppcrypto.decodeAndUnsealNamed('user_session', new Buffer(encryptTestCookie), function (data) {
            assert.strictEqual(data.toString('hex'), cookieStruct.toString('hex'));
            next();
        });

    });

    it('should hmac the name', function (next) {

        var hmac = ppcryptutils.hmacString(configuration.macAlgorithm, configuration.macKey, 'user_session');

        assert.strictEqual(hmac, 'TVKbnJIgoopqCTftP3PCeQTrLnu');

        next();
    });

    /**
     * This does both because it encrypts one way - i.e. you can't check it except to unseal it.
     */
    it('should encrypt/decrypt rlogid', function (next) {

        var inputValue = 'nodejstestweb::lm-sjn-00713581';

        var ppcrypto = ppcryptutils({
            encryptionAlgorithm: 'des-ede3-cbc',
            macAlgorithm: 'sha1',
            encryptionKey: new Buffer('mjok7Ye1bVDHkCDMQZUvZ8VhkawCvhoM', 'base64'),
            macKey: new Buffer('8rH6RMptN2O3kH4YwJQFyA-owRM', 'base64')
        });

        ppcrypto.macKeyStringXorEncryptAndEncode(new Buffer(inputValue), function (result) {
            ppcrypto.macKeyStringXorDecryptAndDecode(result, function (original) {
                assert.strictEqual(original, inputValue);
                next();
            });
        });
    });

    it('should decrypt rlogid encrypted in Java', function (next) {

        var inputValue = 'marketingspartaweb::slcspartamp3027a';
        var expectedValue = 'pgPczdYpBs23BkNh0ThnaJai4PgoWJQdT25CqhYbXNOaICZctMfMmjsoz6LGMk8/lR9+oqbLjOpmjs0lsXO80A';

        var ppcrypto = ppcryptutils({
            encryptionAlgorithm: 'des-ede3-cbc',
            macAlgorithm: 'sha1',
            encryptionKey: new Buffer('mjok7Ye1bVDHkCDMQZUvZ8VhkawCvhoM', 'base64'),
            macKey: new Buffer('8rH6RMptN2O3kH4YwJQFyA-owRM', 'base64')
        });

        ppcrypto.macKeyStringXorDecryptAndDecode(expectedValue, function (result) {
            assert.strictEqual(result, inputValue);
            next();
        });
    });

    it('should encrypt-decrypt des-cbc', function (next) {

        var inputValue = '_PayPal_';

        var descbc = ppcryptutils.createCipherSpec('des-cbc', new Buffer('01254567', 'utf8'));

        descbc.cipher(inputValue, function (encryptedDataBuffer) {
            descbc.decipher(encryptedDataBuffer, function (originalValue) {
                assert.ok(inputValue === originalValue.toString());
                next();
            });
        }.bind(this));
    });

    it('should encrypt-decrypt aes-256-cbc', function (next) {

        var inputValue = 'Test';

        var aes256 = ppcryptutils.createCipherSpec('aes-256-cbc', new Buffer(32), true);

        aes256.cipher(inputValue, function (encryptedDataBuffer) {
            aes256.decipher(encryptedDataBuffer, function (originalValue) {
                assert.ok(inputValue === originalValue.toString());
                next();
            });
        }.bind(this));

    });

    it('should encrypt-decrypt desx-cbc', function (next) {

        var inputValue = '_PAYPAL_';

        var desxcbc = ppcryptutils.createCipherSpec('desx-cbc', new Buffer(24), false, new Buffer(8));

        desxcbc.cipher(inputValue, function (encryptedDataBuffer) {
            desxcbc.decipher(encryptedDataBuffer, function (decryptedValue) {
                assert.ok(inputValue === decryptedValue.toString());
                next();
            });
        }.bind(this));

    });

    it('should encrypt-decrypt aes-256-cbc: 10 times serial', function (next) {

        async.timesSeries(10, function (n, cb) {
            var inputValue = 'Test';

            var aes256 = ppcryptutils.createCipherSpec('aes-256-cbc', new Buffer(32), true);

            aes256.cipher(inputValue, function (encryptedDataBuffer) {
                aes256.decipher(encryptedDataBuffer, function (originalValue) {
                    assert.ok(inputValue === originalValue.toString());
                    cb();
                });
            }.bind(this));
        }, function () {
            next();
        });

    });

    it('should encrypt-decrypt desx-cbc: 10 times serial', function (next) {

        async.timesSeries(10, function (n, cb) {
            var inputValue = '_PAYPAL_';

            var desxcbc = ppcryptutils.createCipherSpec('desx-cbc', new Buffer(24), false, new Buffer(8));

            desxcbc.cipher(inputValue, function (encryptedDataBuffer) {
                desxcbc.decipher(encryptedDataBuffer, function (decryptedValue) {
                    assert.ok(inputValue === decryptedValue.toString());
                    cb();
                });
            }.bind(this));
        }, function () {
            next();
        });
    });

    it('should encrypt-decrypt aes-256-cbc: 10 times parallel', function (next) {

        async.times(10, function (n, cb) {
            var inputValue = 'Test';

            var aes256 = ppcryptutils.createCipherSpec('aes-256-cbc', new Buffer(32), true);

            aes256.cipher(inputValue, function (encryptedDataBuffer) {
                aes256.decipher(encryptedDataBuffer, function (originalValue) {
                    assert.ok(inputValue === originalValue.toString());
                    cb();
                });
            }.bind(this));
        }, function () {
            next();
        });

    });

    it('should encrypt-decrypt desx-cbc: 10 times parallel', function (next) {

        async.times(10, function (n, cb) {
            var inputValue = '_PAYPAL_';

            var desxcbc = ppcryptutils.createCipherSpec('desx-cbc', new Buffer(24), false, new Buffer(8));

            desxcbc.cipher(inputValue, function (encryptedDataBuffer) {
                desxcbc.decipher(encryptedDataBuffer, function (decryptedValue) {
                    assert.ok(inputValue === decryptedValue.toString());
                    cb();
                });
            }.bind(this));
        }, function () {
            next();
        });
    });

});
