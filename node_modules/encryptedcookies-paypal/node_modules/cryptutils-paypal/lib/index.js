'use strict';

var assert = require('assert'),
    crypto = require('crypto'),
    constants = require('./constants'),
    ciphers = require('./ciphers'),
    base64 = require('base64-paypal'),
    utils = require('./utils');

exports = module.exports = function createCryptUtil(options) {
    var encAlgorithm, encKey, macAlgorithm, macKey, padding;

    assert.strictEqual(typeof options, 'object', 'Expected an options object.');
    assert.ok(options.encryptionKey, 'Encryption key can not be null.');
    assert.ok(options.macKey, 'Mac key can not be null.');

    encAlgorithm = options.encryptionAlgorithm || 'desx';
    encKey = options.encryptionKey;
    macAlgorithm = options.macAlgorithm || 'sha1';
    macKey = encAlgorithm === 'desx' ? ciphers.DesxCipherSpec._truncateKey(options.macKey) : options.macKey;
    padding = !!options.padding;

    return {

        sealAndEncodeNamed: function sealAndEncodeNamed(name, input, callback) {
            this.sealAndEncode(Buffer.concat([new Buffer(name), input]), callback);
        },

        sealAndEncode: function sealAndEncode(input, callback) {
            this.seal(input, function (encrypted) {
                callback(base64.encode(encrypted, base64.CharacterSet.PPUUENCODING, false).toString());
            });
        },

        sealAndEncodeBeacon: function sealAndEncodeBeacon(input, callback) {
            this.sealBeacon(input, function (encrypted) {
                var encoded = new Buffer( encrypted || '').toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                callback(encoded);
            });
        },

        seal: function seal(input, callback) {
            var hmac, padCount, formatted;
            var pseudo_iv_length = constants.PSEUDO_IV_LENGTH;

            switch (encAlgorithm) {
            case 'aes128':
            case 'aes-128-cbc' :
            case 'aes-256-cbc' :
                pseudo_iv_length = constants.PSEUDO_AES_IV_LENGTH;
                break;
            default:
                pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
                break;
            }

            hmac = createHmac(macAlgorithm, macKey, input);
            padCount = pseudo_iv_length - (input.length % pseudo_iv_length);

            formatted = [];
            formatted[0] = hmac.slice(0, pseudo_iv_length);
            formatted[1] = input;
            formatted[2] = hmac.slice(pseudo_iv_length, pseudo_iv_length + (padCount - 1));
            formatted[3] = new Buffer([padCount]);

            createCipherSpec(encAlgorithm, encKey, padding).cipher(Buffer.concat(formatted), function (ciphered) {
                var result;

                result = [];
                result[0] = ciphered;
                result[1] = createHmac(macAlgorithm, macKey, ciphered);

                callback(Buffer.concat(result));
            });
        },

        sealBeacon: function sealBeacon(input, callback) {
            var hmac, padCount, formatted;
            var pseudo_iv_length = constants.PSEUDO_IV_LENGTH;

            switch (encAlgorithm) {
            case 'aes128':
            case 'aes-128-cbc' :
            case 'aes-256-cbc' :
                pseudo_iv_length = constants.PSEUDO_AES_IV_LENGTH;
                break;
            default:
                pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
                break;
            }

            hmac = createHmac(macAlgorithm, macKey, input);
            padCount = pseudo_iv_length - (input.length % pseudo_iv_length);

            formatted = [];
            formatted[0] = input;
            formatted[1] = hmac.slice(pseudo_iv_length, pseudo_iv_length + (padCount - 1));
            formatted[2] = new Buffer([padCount]);

            createCipherSpec(encAlgorithm, encKey, padding, hmac.slice(0, pseudo_iv_length)).cipher( Buffer.concat(formatted), function (ciphered) {
                var toSign;
                var result;

                toSign = [];
                toSign[0] = hmac.slice(0, pseudo_iv_length);
                toSign[1] = ciphered;

                result = [];
                result[0] = hmac.slice(0, pseudo_iv_length);
                result[1] = ciphered;
                //result[2] = hmac.slice(pseudo_iv_length, pseudo_iv_length + (padCount - 1));
                //result[3] = new Buffer([padCount]);
                result[2] = createHmac(macAlgorithm, macKey, Buffer.concat(toSign));

                callback(Buffer.concat(result));
            });
        },

        decodeAndUnsealNamed: function decodeAndUnsealNamed(name, input, callback) {
            this.decodeAndUnseal(input, function (data) {
                callback(data.slice(Buffer.byteLength(name), data.length));
            });
        },

        decodeAndUnseal: function decodeAndUnseal(input, callback) {
            var decodedInput = base64.decode(input, base64.CharacterSet.PPUUENCODING, false);
            this.unseal(decodedInput, callback);
        },

        decodeAndUnsealBeacon: function decodeAndUnsealBeacon(input, callback) {
            //var encoded = input.replace(/-/g, '+').replace(/_/g, '/');
            var encoded = input.toString('base64').replace(/-/g, '+').replace(/_/g, '/');
            while (encoded.length % 4) {
                encoded += '=';
            }
            var decodedInput = new Buffer(encoded || '', 'base64');
            this.unsealBeacon(decodedInput, callback);
            //callback(decodedInput);
        },

        unseal: function unseal(input, callback) {
            var trimmed, hmac;
            var pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
            var hash_digest_length = constants.SHA1_DIGEST_LENGTH;

            switch (encAlgorithm) {
            case 'aes128':
            case 'aes-128-cbc' :
            case 'aes-256-cbc' :
                pseudo_iv_length = constants.PSEUDO_AES_IV_LENGTH;
                break;
            default:
                pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
                break;
            }

            switch (macAlgorithm) {
            case 'sha256':
                hash_digest_length = constants.SHA256_DIGEST_LENGTH;
                break;
            default:
                hash_digest_length = constants.SHA1_DIGEST_LENGTH;
                break;
            }


            trimmed = input.slice(0, input.length - hash_digest_length);
            hmac = createHmac(macAlgorithm, macKey, trimmed);

            if (!utils.equals(hmac, input.slice(input.length - hash_digest_length, input.length))) {
                throw new Error('HMAC comparison failed');
            }

            createCipherSpec(encAlgorithm, encKey).decipher(trimmed, function (deciphered) {
                var padCount = deciphered[deciphered.length - 1];
                callback(deciphered.slice(pseudo_iv_length, deciphered.length - padCount));
            });
        },

        unsealBeacon: function unsealBeacon(input, callback) {
            var trimmed, hmac;
            var pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
            var hash_digest_length = constants.SHA1_DIGEST_LENGTH;

            switch (encAlgorithm) {
            case 'aes128':
            case 'aes-128-cbc' :
            case 'aes-256-cbc' :
                pseudo_iv_length = constants.PSEUDO_AES_IV_LENGTH;
                break;
            default:
                pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
                break;
            }

            switch (macAlgorithm) {
            case 'sha256':
                hash_digest_length = constants.SHA256_DIGEST_LENGTH;
                break;
            default:
                hash_digest_length = constants.SHA1_DIGEST_LENGTH;
                break;
            }


            trimmed = input.slice(0, input.length - hash_digest_length);
            hmac = createHmac(macAlgorithm, macKey, trimmed);

            if (!utils.equals(hmac, input.slice(input.length - hash_digest_length, input.length))) {
                throw new Error('HMAC comparison failed');
            }

            createCipherSpec(encAlgorithm, encKey, padding, trimmed.slice(0, pseudo_iv_length)).decipher(trimmed.slice(pseudo_iv_length, trimmed.length), function (deciphered) {
                var padCount = deciphered[deciphered.length - 1];
                callback(deciphered.slice(0, deciphered.length - padCount));
            });
        },


        macKeyStringXorEncryptAndEncode: function macKeyStringXorEncryptAndEncode(input, callback) {
            if (!Buffer.isBuffer(input)) {
                input = new Buffer(input);
            }

            var padSize = (Math.ceil((macKey.length + input.length) / 8) * 8) - (macKey.length + input.length);

            var padding = new Buffer(new Array(padSize || 8));

            var rxordata = new Buffer(4);

            var buffer = Buffer.concat([macKey, input, padding]);

            for (var i = 0; i < buffer.length; i++) {
                var whitener = rxordata[i % rxordata.length];
                buffer[i] = buffer[i] ^ whitener;
            }

            createCipherSpec(encAlgorithm, encKey).cipher(buffer, function (encrypted) {
                callback(base64.encode(encrypted, base64.CharacterSet.DEFAULT, false).toString());
            });
        },

        macKeyStringXorDecryptAndDecode: function macKeyStringXorDecryptAndDecode(input, callback) {
            var decoded = base64.decode(input, base64.CharacterSet.DEFAULT, false);

            createCipherSpec(encAlgorithm, encKey).decipher(decoded, function (decrypted) {
                var rxordata, i, whitener, data;

                rxordata = new Buffer(4);

                for (i = 0; i < 4; i++) {
                    rxordata[i] = decrypted[i] ^ macKey[i];
                }

                for (i = 0; i < decrypted.length; i++) {
                    whitener = rxordata[i % 4];
                    decrypted[i] = decrypted[i] ^ whitener;
                }

                // Ensure first 10 bytes match?
                if (!utils.equals(decrypted, macKey, Math.floor(macKey.length / 2))) {
                    throw new Error('Mac key not recovered.');
                }

                data = decrypted.slice(macKey.length, decrypted.length);
                for (i = 0; i < data.length; i++) {
                    if (data[i] === 0) {
                        return callback(data.slice(0, i).toString());
                    }
                }

                throw new Error('Could not recover data');
            });
        }
    };
};

function createCipherSpec(encAlg, encKey, padding, iv) {
    return ciphers.createCipherSpec(encAlg, encKey, !!padding, iv);
}

function createHmac(macAlgorithm, macKey, input) {
    return crypto.createHmac(macAlgorithm, macKey).update(input).digest();
}

function hmacString(macAlgorithm, macKey, input) {
    macKey = ciphers.DesxCipherSpec._truncateKey(macKey);
    return base64.encode(createHmac(macAlgorithm, macKey, input), base64.CharacterSet.PPUUENCODING, false).toString('utf8');
}

exports.createCipherSpec = createCipherSpec;

exports.createHmac = createHmac;

exports.hmacString = hmacString;
