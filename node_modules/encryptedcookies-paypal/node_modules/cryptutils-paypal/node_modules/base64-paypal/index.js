'use strict';

var CharacterSet = {
    DEFAULT: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    PPBASE64: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-.',
    URLSAFE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    PPUUENCODING: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_-'
};

exports.CharacterSet = CharacterSet;

var DecodeCharacters = Object.keys(CharacterSet).reduce(function (obj, key) {
    obj[CharacterSet[key]] = _decodeCharacterSet(CharacterSet[key]);
    return obj;
}, {});

exports.encode = function (input, charset, pad) {
    var padding, size, char3, i, result, pos;

    // Ensure arguments are clean
    input = Buffer.isBuffer(input) ? input : new Buffer(input);
    if (!charset || typeof charset !== 'string') {
        pad = charset;
        charset = CharacterSet.DEFAULT;
    }
    pad = pad !== false;

    // Cache some useful values
    padding = ((3 - (input.length % 3)) % 3);

    // Depend on native decoding, when possible.
    if (charset === CharacterSet.DEFAULT || charset === CharacterSet.PPBASE64 || charset === CharacterSet.URLSAFE) {
        result = nativeb64encode(input, charset);
        if (!pad && padding) {
            result = result.slice(0, -padding);
        }
        return result;
    }

    size = input.length + padding;

    result = new Buffer(size * 2);
    result.fill(0);
    pos = 0;

    for (i = 0; i <= size; i += 3) {
        //3 Characters (8bit * 3 = 24 bits) as a 24 bit int
        char3 = ((input[i] & 0xff) << 16) |
        ((input[i + 1] & 0xff) << 8) |
        ((input[i + 2] & 0xff));

        //Convert int to 4 Characters (6 bit * 4 = 24 bits)
        result[pos++] = charset.charCodeAt((char3 >> 18) & 0x3f);
        result[pos++] = charset.charCodeAt((char3 >> 12) & 0x3f);
        result[pos++] = charset.charCodeAt((char3 >> 6) & 0x3f);
        result[pos++] = charset.charCodeAt((char3 & 0x3f));

        if (i + 3 >= size) {
            pos -= (4 - (4 - padding));
        }
    }

    result = result.slice(0, pos);

    if (pad && padding) {
        if (padding === 1) {
            result.length -= 2;
        }

        if (padding === 2) {
            result[result.length - 2] = 0x3d;
        }

        result[result.length - 1] = 0x3d;
        return result;
    }

    result.length -= (4 - padding);
    return result;
};

exports.decode = function (input, charset, pad) {
    var padding, decodeChars, char4, buffer, pos;

    // Ensure arguments are clean
    input = Buffer.isBuffer(input) ? input : new Buffer(input);
    if (!charset || typeof charset !== 'string') {
        pad = charset;
        charset = CharacterSet.DEFAULT;
    }
    pad = pad !== false;

    padding = 0;

    if (!pad) {
        padding = ((4 - (input.length % 4)) % 4);
    }
    else {
        if (input[input.length - 1] === 61) {
            padding++;
        }
        if (input[input.length - 2] === 61) {
            padding++;
        }
    }

    // Depend on native decoding, when possible.
    if (charset === CharacterSet.DEFAULT || charset === CharacterSet.PPBASE64 || charset === CharacterSet.URLSAFE) {
        input = input.toString();
        while (!pad && padding) {
            input += '=';
            padding -= 1;
        }
        return nativeb64decode(input, charset);
    }

    decodeChars = DecodeCharacters[charset] || (DecodeCharacters[charset] = _decodeCharacterSet(charset));

    // Trim off the trailing '=' padding before decode.
    if (pad && padding) {
        input.length -= padding;
    }

    buffer = new Buffer(input.length);
    buffer.fill(0);
    pos = 0;

    for (var i = 0; i < input.length; i += 4) {
        //4 Characters (6 bit * 4 = 24 bits) as 24 bit int.
        char4 = decodeChars[input[i]] << 18 |
        decodeChars[input[i + 1]] << 12 |
        decodeChars[input[i + 2]] << 6 |
        decodeChars[input[i + 3]];

        buffer[pos++] = char4 >> 16;
        buffer[pos++] = char4 >> 8;
        buffer[pos++] = char4;

        if (i + 4 >= input.length) {
            pos -= 3 - (3 - padding);
        }
    }

    return buffer.slice(0, pos);
};

function _decodeCharacterSet(characterSet) {
    var set = {};
    for (var i = 0; i < characterSet.length; i++) {
        set[characterSet.charCodeAt(i)] = i;
    }
    return set;
}

function nativeb64encode(input, charset) {
    var encoded = new Buffer(input).toString('base64');

    if (!charset) {
        charset = CharacterSet.DEFAULT;
    }

    switch (charset) {
        case CharacterSet.PPBASE64:
            encoded = encoded.replace(/\+/g, '-');
            encoded = encoded.replace(/\//g, '.');
            break;
        case CharacterSet.URLSAFE:
            encoded = encoded.replace(/\+/g, '-');
            encoded = encoded.replace(/\//g, '_');
            break;
        default:
            break;
    }

    return new Buffer(encoded);
}

function nativeb64decode(input, charset) {
    if (!charset) {
        charset = CharacterSet.DEFAULT;
    }

    switch (charset) {
        case CharacterSet.PPBASE64:
            input = input.replace(/\-/g, '+');
            input = input.replace(/\./g, '/');
            break;
        case CharacterSet.URLSAFE:
            input = input.replace(/\-/g, '+');
            input = input.replace(/\_/g, '/');
            break;
        default:
            break;
    }

    return new Buffer(input, 'base64');
}
