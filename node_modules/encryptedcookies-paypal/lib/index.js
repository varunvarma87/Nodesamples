'use strict';

var assert = require('assert'),
    util = require('./util'),
    async = require('async'),
    ppcryptutils = require('cryptutils-paypal'),
    CookieIds = require('./cookieIds'),
    LoginCookie = require('logincookie-paypal'),
    decryptor = require('./decryptor'),
    debug = util.debuglog();

exports = module.exports = function (configuration) {
    var ppcrypto, cachedNames, hmac;

    configuration || (configuration = {});
    cachedNames = {};

    if (!configuration.decrypt) {
        configuration.decrypt = [CookieIds.WEBSCR_LOGIN_COOKIE_NAME, CookieIds.VISITOR_ID_COOKIE, CookieIds.GUID_COOKIE ];
    }

    if (typeof configuration.encryptionKey === 'string') {
        configuration.encryptionKey = new Buffer(configuration.encryptionKey, 'base64');
    }
    if (typeof configuration.macKey === 'string') {
        configuration.macKey = new Buffer(configuration.macKey, 'base64');
    }

    assert(configuration.encryptionKey && Buffer.isBuffer(configuration.encryptionKey), 'Expected encryptionKey to be a buffer or string.');
    assert(configuration.macKey && Buffer.isBuffer(configuration.macKey), 'Expected macKey to be a buffer or string.');
    assert(Array.isArray(configuration.decrypt), 'Expected decrypt list to be an array.');

    ppcrypto = new ppcryptutils({
        encryptionAlgorithm: 'desx',
        macAlgorithm: 'sha1',
        encryptionKey: configuration.encryptionKey,
        macKey: configuration.macKey
    });

    hmac = ppcryptutils.hmacString.bind(null, 'sha1', new Buffer(configuration.macKey, 'base64'));

    function writeEncryptedCookie(res, name, value, options, callback) {
        var encName;

        if (typeof options === 'function') {
            callback = options;
            options = {
                secure: true,
                httpOnly: true,
                domain: '.paypal.com'
            };
        }

        //Ignore localhost
        if (options.domain === 'localhost') {
            delete options.domain;
        }

        encName = cachedNames[name] || (options.encryptName ? hmac(name) : name);

        delete options.encryptName;

        if (typeof value === 'string') {
            value = new Buffer(value);
        }

        debug('Writing encrypted cookie %s.', encName);

        ppcrypto.sealAndEncodeNamed(name, value, function (encValue) {
            res.cookie(encName, encValue, options);
            callback();
        });
    }

    return function readCookies(req, res, done) {
        var tasks = [];

        res.encryptedCookie = writeEncryptedCookie.bind(null, res);

        if (!req.cookies) {
            done();
            return;
        }

        configuration.decrypt.forEach(function (cookieName) {
            var encName, encValue;

            encName = cachedNames[cookieName];

            if (!encName) {
                encName = hmac(cookieName);
                cachedNames[cookieName] = encName;
            }

            encValue = req.cookies[encName];

            if (encValue) {
                tasks.push(decryptor(ppcrypto, cookieName, encValue));
            }
        });

        async.parallel(tasks, function (error, results) {
            if (error) {
                debug(error);
                done(error);
                return;
            }

            if (results) {
                results.forEach(function (result) {
                    var cookie;

                    if (result.error) {
                        debug(result.error);
                        return;
                    }

                    cookie = result.cookie;

                    if (cookie.name === CookieIds.WEBSCR_LOGIN_COOKIE_NAME) {
                        cookie.value = LoginCookie.deserialize(cookie.value);
                    }
                    else {
                        cookie.value = new Buffer(cookie.value).toString();
                    }
                    req.cookies[cookie.name] = cookie.value;
                });
            }

            done();
        });
    };
};

exports.CookieIds = CookieIds;
