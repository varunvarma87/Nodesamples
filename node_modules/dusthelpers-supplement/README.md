# dusthelpers-supplement 

This module supplies a commonly used set of PayPal dust extension helpers.

Note: krakenJs requires dust helper extensions to be configured in your config/app.json file.
In order to make these helpers available in your application,  add a section like this
to your config/app.json file.

```json
"view engines": {
      "dust": {
           "settings": {
              "helpers": [ "dusthelpers-supplement" ]
           }
       },
      "js": {
           "settings": {
              "helpers": [ "dusthelpers-supplement" ]
           }
       }
  }
```

If there are other helpers already present, just add "dusthelpers-supplement" to the array. 
Be sure you have a dependency on this project in your package.json also. 

Note that the above appears redundant and it is. The helpers are for dust and 
the dust view engine. However, they get compiled to JavaScript and so become helpers for
the JS view engine. Either or both will achieve the same result but if you have extra
options that differ on the two view engines you might want both present. 
For purity, do it twic.
     
Custom Helpers defined by this module
<ul>
<li><a href="#link">link helper - generate PayPal urls for links and images</li>
<li><a href="#provide">provide helper - defines complex dust params for easy usage</li>
<li><a href="#if">if helper - Alternative to @if in standard dust that does not use eval</li>

</ul>

<a name="link"/>
## @link 

The link dust helper generates PayPal urls for links and images. It is used in templates and content strings.
The general usage is:

    {@link href="path" /}

The tag is executed when the template is executed and expects to find host, country, and locale
in the data model. Running the node-locale middleware will ensure these values are populated.
Where possible, the link builder generates relative urls for commands. 

There are two forms of relative urls supported by browsers, those that start with a slash (server-relative) and
those that do not. If it starts with a slash, the browser retains the protocol, host and port
and suffixes the /path you provide. If it does not start with a slash, the path will be suffixed
relative to the path of the current page retaining everything prior. The advantage of relative
urls is that they work equally well on stage, sandbox and live.

If your href ends with an extension (.xxx), the url will be built to reference  
a resource (e.g. js, css, images...) for your currrent environmnent (e.g. stage or production). If you have the case
where a command ends with an extension (.do, for example) and you have no trailing query string, you will need
to add the type="command" paarameter to the helper to clarify the intent.

If you add the 'cobrand' parameter, the value of the cobrand parameter will override the value set in context, if it 
is present, and will be prepended to the URL path. For example, a reference such as {@link href="/a/b" /} will
result in a relative path of "/a/b", the same reference with a context.locality.cobrand="US" will result in
a relative path of "/us/a/b", and a reference of {@link href="/a/b" cobrand="DE"/} will result in a relative path
of "/de/a/b" regardless of the context.locality.cobrand.

#### Home Page Link
    <a href='{@link href="/" /}'>Home</a>

#### webscr command link
    <a href='{@link href="/cgi-bin/webscr?cmd=xpt/Marketing/general/SiteMap-outside" /}'>Site Map</a>

#### Application relative link
This sort of link would be used within an application, perhaps to navigate to a peer page of the current one
    <a href='{@link href="page2" /}'>Next</a>

#### Resource Links
Most JS/CSS references are built by the framework and access aggregated, minimized and hash path addressed files from www.paypalobjects.com.
A small number of use cases may require urls to JS/CSS/XML, etc. files with fixed paths. 
Resource links are generated when a file extension is detected on the url
    <script type="text/javascript" src='{@link href="/pa/js/code.js" /}'></script> 

Here are some other usage examples assuming a production environment:

    {@link href="/a/b" /}  -> /us/a/b restoring the cobrand and retaining protocol,host,port
    {@link href="a/b" /}  -> a/b - Do not use the helper for this case. Just write "a/b"
    {@link href="i/cebit.gif"/} -> https://www.paypalobjects.com/webstatic/i/cebit.gif

<a name="provide"/>
## @provide

The provide dust helper allows definition of rich parameter values you can pass to partials.

There are a number of cases where you may want to define a value for a parameter to be more complex
than just the basic forms allowed by dust; viz p="abc", p=xyz, p="{xyz}". A very common case is to
want the value from a helper function like {@size} that you can pass to a partial or test.
@provide lets you capture that value and reference it like a parameter.

The general form of @provide is

    {@provide [optional params]}
      main block of dust
      {:block1}
        evaluation of this block defines a param named "block1"
      {:block2}
        evaluation of this block defines a param named "block2"
      ... as many blocks as you need params
    {/provide} 

Rules:
* The text in a param block should evaluate to a valid JSON object. constants, strings, array [ ], object { } are the main legal forms.
* a param on the @provide helper can be used in the main block and all param blocks
* params defined by the blocks can be used in the main block
* If a block name duplicates a param name, the block name overrides in the main block although the param can be used in the block param definitions

If the param block does not contain a valid JSON object, the param gets the value of the evaluated text directly.

#### Examples:

Find the size of an array and pass the value to a partial

    {@provide}
      {>partial size=len /}
    {:len}
      {@size key=array /}
    {/provide}

Create an ad hoc list of month numbers for a dropdown without requiring the controller to supply them

    {@provide selected=chosen}
      <select name="months">
        {#months}
          <option value="{.}"{@if cond="'{selected}' == '{.}'"} selected="selected"{/if}>{.}</option>
        {/months}
      </select>
    {:months}
      [1,2,3,4,5,6,7,8,9,10,11,12]
    {/provide}

Create an ad hoc structure from simple data values to pass to a partial that expects a particular structure

    {@provide}
      {>displayAddress data=struct}
    {:struct}
      {"street":"{homeStreet}", "city":"{homeCity}", "state": "{homeState}" }
    {/provide}

An interesting use case is when you need to dynamically choose an entry from a map and use
fields belonging to the entry. For example, you have a set of content strings data for
a number of different banks (e.g. HSBC, BofA, etc) and you want to dynamically get the
messages appropriate to the customer's bank from the content.

The following object is easily described using map format with a .properties file:
````
"bankRules": {
   "Banorte": {
       "bankInfoText":"Payment concept",
       "bankInfoRefText":"Reference number",
       "transferText":"Transfers"
   },
   "HSBC": {
       "bankInfoText":"Payment concept",
       "bankInfoRefText":"numeric reference",
       "transferText":"Transfers to other banks"
   }
}

bankName: "HSBC",
````

Now if the template contains the following you can display the bankInfoText message
for HSBC (note bankName:HSBC in the data model).

````
{@provide}
BANK RULES: {#bankRules[bankName]}{.bankInfoText}{/bankRules[bankName]}
{:bankRules}
{@pre type="content" key="bankrules" mode="json" /}
{/provide}
````

<a name="if"/>
## @if

Another version of the main dustjs-helpers @if helper which does not use eval.

## Definition 

```
{@if test="expr"}block{/if}

test - Mandatory parameter specifying the expression used for the if test.
       If you use the old cond="expr" attribute of the current dustjs-helpers @if,
       it will work exactly like the current one including the use of eval.
       Try to convert your usages to test="expr". The old form is provided
       for ease of migration.
```
The test="expr" expression is limited unlike the @if cond= eval=based version. What is allowed is:
<ul>
<li>Variables are restricted to dust names and paths used to access values from the context.</li> 
<li>Constants are JavaScript integer, float, hex and string forms ("xx" or 'xx'). </li>
<li>Operands can be a "variable", a constant, or a binary or unary expression yielding a value. 
<li>Relational operators are <, >, <=, >=, ==, !=. Boolean operators are ! (unary), || and &&.  The == and != operators
actually use JavaScript === and !== under the covers but "dust is not JavaScript" so going with the simpler operator
forms was chosen.</li>
<li>Operator precedence is the same as JavaScript and parentheses are allowed for clarity or for when the precedence is not what you want.</li>
</ul>

Expressions are easier to write than with the current if helper because names and paths do not have to be wrapped in braces or braces within quotes.  For example,
```
{@if cond="\'{state}\' == 'CA' "} versus {@if test="state == 'CA' "}
```

## Examples
```
Context:
{
  x:1,
  y:2,
  a: {b: 5},
  arr: [1, 2, 3], nums:[1, 2, 3]
}
{@if test="x"}3{/if} is true and outputs 3

{@if test="a.b == 5"}5{/if} is true and outputs 5

{@if test="arr[nums[1]]==3"}3{/if} is true and outputs 3

{@if test="2>1 && 3>=3 && 4==4"}true{/if} outputs true

{@if test=" x && y "}X and Y exist{:else}X and Y do not exists/if} outputs "X and Y exist"

{#arr}{@if test=". < 4"}1{/if}{/arr} outputs 111 because all elements of arr are < 4

{@if test="!!0"}true{:else}false{/if} outputs false
```
While complicated expressions are allowed, always try to see if there isn't a
better way to organize the data model to have less logic in the template.
If the conditional actually contains business logic, move it back into the controller ASAP.
