'use strict';

var fs = require('fs'),
    util = require('util'),
    domain = require('domain'),
    stream = require('readable-stream'),
    constants = require('./const');


function CdbStream(file) {
    CdbStream.super_.call(this, { objectMode: true });

    this._file = file;
    this._fd = undefined;
    this._cursor = 0;
    this._pointer = undefined;
    this._pointers = undefined;
    this._hashentry = 0;

    this._domain = domain.create();
    this._domain.on('error', function (err) {
        this.emit('error', err);
        this._end();
    }.bind(this));
}

util.inherits(CdbStream, stream.Readable);



CdbStream.prototype._readStart = function () {
    var that = this;

    if (this._fd) {
        this._readPointers(this._cursor);
        return;
    }

    fs.open(this._file, 'r', this._domain.intercept(function (fd) {
        that._fd = fd;
        that._readPointers(that._cursor);
    }));
};


CdbStream.prototype._readStop = function () {
    // technically a noop. We only ever read from the source when this._read is called
};


CdbStream.prototype._end = function () {
    var that = this;

    function cleanup() {
        that._fd = undefined;
        that.push(null);
        process.nextTick(function () {
            that.emit('close');
        });
    }

    if (this._fd) {
        fs.close(this._fd, this._domain.intercept(cleanup));
        return;
    }

    cleanup();
};


CdbStream.prototype._onRecord = function (record) {
    if (!this.push(record)) {
        this._readStop();
    }
};


CdbStream.prototype._read = function () {
    this._readStart();
};


//CdbStream.prototype._readPointer = function (position) {
//    var that = this;
//
//    if (position >= constants.POINTER_SIZE_IN_BYTES) {
//        // Read complete
//        this._end();
//        return;
//    }
//
//    if (this._pointer) {
//        process.nextTick(function () {
//            that._readHashtable(that._pointer.position, that._pointer.length);
//        });
//        return;
//    }
//
//    this._readFile(position, 8, function (buffer) {
//        that._cursor = position + 8;
//        that._pointer = {
//            position: buffer.readUInt32LE(0),
//            length:   buffer.readUInt32LE(4)
//        };
//
//        that._readHashtable(that._pointer.position, that._pointer.length);
//    });
//};


CdbStream.prototype._readPointers = function (position) {
    var that, pointer;

    pointer = this._pointer;
    if (pointer) {
        // Same pointer, different hashtable entry
        this._readHashtable(pointer.position, pointer.length);
        return;
    }

    if (this._pointers) {
        // We've already read and parsed the pointer block
        if (position < this._pointers.length) {
            // pointers remain, so read the next one
            pointer = this._pointer = this._pointers[position];
            this._readHashtable(pointer.position, pointer.length);
            this._cursor += 1;
        } else {
            // Read complete
            this._pointers = undefined;
            this._end();
        }
        return;
    }

    that = this;

    // Initial read, so grab and parse the entire pointer block
    this._readFile(0, constants.POINTER_SIZE_IN_BYTES, function (buffer) {
        var pointers, cursor;

        pointers = [];
        for (cursor = 0; cursor < buffer.length; cursor += 8) {
            pointers.push({
                position: buffer.readUInt32LE(cursor),
                length:   buffer.readUInt32LE(cursor + 4)
            });
        }

        that._pointers = pointers;
        that._readStart();
    });
};


CdbStream.prototype._readHashtable = function (position, length) {
    var that, start;

    if (!length) {
        this._hashentry = 0;
        this._pointer = undefined;
        this._readStart();
        return;
    }

    that = this;
    start = position + (this._hashentry * 8);

    this._readFile(start, 8, function (buffer) {
        that._readRecord(buffer.readUInt32LE(0), buffer.readUInt32LE(4));
    });

    this._hashentry += 1;
    if (this._hashentry === length) {
        this._hashentry = 0;
        this._pointer = undefined;
    }
};


CdbStream.prototype._readRecord = function (hash, position) {
    var that;

    if (!position) {
        // No position, so move on to next entry
        this._readStart();
        return;
    }

    that = this;
    this._readFile(position, 8, function (buffer) {
        that._readKeyValue(position + 8, buffer.readUInt32LE(0), buffer.readUInt32LE(4));
    });
};


CdbStream.prototype._readKeyValue = function (position, keySize, valueSize) {
    var that = this;
    this._readFile(position, (keySize + valueSize), function (buffer) {
        that._onRecord({
            key:   buffer.slice(0, keySize).toString('ascii'),
            value: buffer.slice(keySize).toString('ascii')
        });
    });
};


CdbStream.prototype._readFile = function (position, length, callback) {
    fs.read(this._fd, new Buffer(length), 0, length, position, this._domain.intercept(function (bytes, buffer) {
        callback(buffer);
    }));
};


exports = module.exports = CdbStream;