'use strict';

var servicecore = require('servicecore'),
    useraccesscontrol = require('useraccesscontrol-paypal'),
    AuthToken = require('authtoken-paypal'),
    utils = require('../utils'),
    LoginCookie = require('logincookie-paypal'),
    SecurityContext = require('./securitycontext');


function validate(req, res, next) {
    var loginCookie, uac, uacRequest, visitorId, guid, token;

    req.securityContext = new SecurityContext();

    loginCookie = req.cookies && req.cookies.user_session;

    //Skip
    if (!loginCookie) {
        utils.debug('No login cookie.');
        next();
        return;
    }

    servicecore.register('useraccesscontrol-paypal', useraccesscontrol);
    uac = servicecore.create('useraccesscontrol-paypal', { asfSchemaOverride: false });
    visitorId = req.cookies.visitor_id || 0;
    guid = req.cookies.guid;

    token = AuthToken.serialize(loginCookie.data || {}, loginCookie.format);

    uacRequest = {
        channel: loginCookie.channel,
        client_actor: {
            actor_type: 2,
            visitor_id: visitorId,
            guid: guid,
            token: token,
            token_type: (loginCookie.format === 2) ? 3 : 0,
            actor_auth_type: (loginCookie.format === 2) ? 87 : 80
        }
    };

    utils.debug('Validating token %s.', token);

    uac.validate_token(uacRequest, function (error, response) {
        if (error) {
            utils.debug('Error during validate_token: %s', error.message);
            next(error);
            return;
        }

        if (response.statusCode !== 200) {
            utils.debug('Unexpected response code from service: %d', response.statusCode);
            next(new Error(response.body.toString() || 'Unknown error.'));
            return;
        }

        utils.debug('validate_token result = %d.', response.body.result.result);

        createSecurityContext(response.body.result, function (error, securityContext, sessionToken, serializedToken, actor) {
            securityContext && (req.securityContext = securityContext);
            sessionToken && (req.sessionToken = sessionToken);
            serializedToken && (req.serializedToken = serializedToken);
            actor && (req.actorInfo = actor);

            next();
        });
    });
}

/**
 * Builds the security context from the result of validate_token.
 * @param validateResult
 * @param done
 */
function createSecurityContext(validateResult, next) {
    var actor, serializedToken;

    utils.debug('Building securitycontext (validationResult = %d).', validateResult.result);

    actor = validateResult.updated_client_actor || {};

    if (!actor || !actor.token) {
        next();
        return;
    }

    AuthToken.deserialize(actor.token, function (error, token) {
        var securityContext;

        if (error) {
            next(error);
            return;
        }

        if (typeof token === 'object') {
            securityContext = new SecurityContext(validateResult.result, actor, token);
        }

        if (actor.token_type === 0) {
            serializedToken = LoginCookie.Legacy.fromJSON(token).buffer;
        }
        else {
            serializedToken = LoginCookie.serialize(new LoginCookie(token, 2));
        }

        next(null, securityContext, token, serializedToken, actor);
    });
}

module.exports = validate;
