'use strict';

var assert = require('assert'),
    utils = require('./../utils'),
    objutil = require('objutil'),
    cal = utils.tryRequire('cal'),
    querystring = require('querystring'),
    os = require('os'),
    thing = require('core-util-is'),
    debug = require('debuglog')('servicecore');
    
/**
 * Wraps the given (transport) function for CAL logging / profiling.
 * @type {exports}
 */
exports = module.exports = function () {
    var cls, profiler, start, end;

    cls = utils.localStorage();

    /**
     * Wrapped transport function.
     * @param options - the transport specific options.
     * @param callback
     * @returns {*}
     */
    profiler = function profile(options, callback, invoke) {
        var req, originalCallback, appName, correlationId, poolStack,
            pageStartTime, txnStart, hostName, clientIp, remoteAddress, fraudnetData,
            txn, txname, profileHeaders, threadId,
            connectTxname, connectTxn, connectEvent;

        appName = cls.get('appName');
        correlationId = cls.get('correlationId');
        pageStartTime = cls.get('pageStartTime');
        clientIp = cls.get('ip');
        remoteAddress = cls.get('remoteAddress');
        fraudnetData = cls.get('fn_dt');
        threadId = cls.get('threadId');

        txname = utils.getTransactionName(options);
        originalCallback = callback;
        connectEvent = options.protocol === 'https:' ? 'secureConnect' : 'connect';

        if (!cal || !correlationId) {
            debug('no CAL context, skipping profile.');
            invoke(options, callback);
            return;
        }

        hostName = os.hostname();
        txnStart = (pageStartTime || 0).toString(16);
        poolStack = appName + ':' + txname + '*CalThreadId=0*TopLevelTxnStartTime=' + txnStart + '*Host=' + hostName;

        options.headers = options.headers || {};

        options.clientInfo = {
            host: hostName,
            calPoolName: appName,
            pid: process.pid,
            ip: clientIp,
            poolStack: poolStack
        };

        //CAL-centric headers.
        profileHeaders = {
            'pp_remote_addr': remoteAddress,
            'fn_dt': fraudnetData,
            'correlation-id': correlationId,
            'x-pp-corrid': correlationId,
            'x-pp-show-serverinfo': true,
            'client_info': poolStack
        };

        objutil.merge(profileHeaders, options.headers);

        if (!options.caltxn) {
            txn = cal.createTransaction('CALL_A', txname);
            txn.threadId = threadId;
            txn.correlationId = correlationId;
            txn.addData({ method: options.method, path: options.path });

            options.caltxn = txn;
        }

        txn = options.caltxn;

        cls.set('caltxn', txn);

        //Wrap callback for CAL transaction completion.
        callback = function (error, response) {
            var body;

            if (error) {
                if (error.code === 'ETIMEDOUT') {
                    connectTxn.addData({
                        error: error.message
                    });
                    if (options.retry) {
                        connectTxn.addData({
                            retry: options.retry,
                            maxRetry: options.maxRetry
                        });
                    }
                }

                connectTxn.status = cal.Status.ERROR;
                connectTxn.complete();

                if (error.code !== 'ETIMEDOUT' || options.retry >= options.maxRetry) {
                    txn.status = cal.Status.ERROR;
                    txn.addData({
                        error: error.message
                    });

                    txn.complete();
                }

                req.socket.removeListener(connectEvent, onSocketConnect);

                originalCallback.apply(null, arguments);

                return;
            }

            txn.status = cal.Status.SUCCESS;
            txn.addData({ statusCode: response.statusCode });

            if (response.statusCode && response.statusCode >= 500) {
                body = response.body;

                if (body && Buffer.isBuffer(body)) {
                    body = body.toString();
                }

                txn.status = cal.Status.ERROR;
                txn.addData({ message: body });
            }

            if (response.headers && response.headers.server_info) {
                logServerInfo(response.headers.server_info);
                debug('%s server info: %s', txname, response.headers.server_info);
            }

            txn.complete();
            originalCallback.apply(null, arguments);
        };

        debug('profiling %s: clientinfo %s', txname, profileHeaders.client_info);

        connectTxname = (options.rawHostname || options.hostname) + ':' + options.port;
        connectTxn = cal.createTransaction('CONNECT', connectTxname);
        connectTxn.threadId = threadId;
        connectTxn.addData({
            client: options.clientName,
            transport: options.transportName
        });

        req = invoke(options, callback);

        req.once('socket', onSocket);

        function onSocket(socket) {
            socket.removeListener(connectEvent, onSocketConnect);
            socket.once(connectEvent, onSocketConnect);
        }

        function onSocketConnect() {
            var socket = req.socket.pair && req.socket.pair.encrypted || req.socket;

            connectTxn.addData({
                'ssl-r': thing.isFunction(socket.isSessionReused) ? socket.isSessionReused() : false
            });

            if (options.retry) {
                connectTxn.addData({
                    retry: options.retry,
                    maxRetry: options.maxRetry
                });
            }
            connectTxn.complete();
        }

        return req;
    };

    return profiler;
};

/**
 * Cal log x-pp-serverinfo header.
 * @param data
 */
function logServerInfo(serverInfoString) {
    var event, serverInfo, poolStack, poolName;
    serverInfo = querystring.parse('PoolStack=' + serverInfoString);

    poolStack = serverInfo.PoolStack;
    poolName = poolStack.substr(0, poolStack.indexOf(':'));

    event = cal.createEvent('SERVER_INFO', poolName);

    event.status = 0;

    event.addData('CurrentPID', process.pid);
    event.addData('ServerPool', poolStack);
    event.addData('CalThreadId', serverInfo.CalThreadId || 0);
    event.addData('TopLevelTxnStartTime', serverInfo.TopLevelTxnStartTime);
    event.addData('Host', serverInfo.Host);
    event.addData('pid', serverInfo.pid || 0);

    event.complete();
}
