'use strict';

var assert = require('assert'),
    utils = require('../utils'),
    objutil = require('objutil'),
    thing = require('core-util-is'),
    profiler = require('./profiler'),
    httpunch = require('httpunch'),
    pkg = require('../../package.json'),
    dns = require('dns'),
    net = require('net'),
    clone = require('lodash.clone'),
    debug = require('debuglog')('servicecore');

var registered, defaultTransports;

defaultTransports = ['bridge', 'asf', 'generic', 'rest', 'ppaas'];

registered = {};

/**
 * Transport function factory.
 * @type {exports}
 */
exports = module.exports = function transportFactory(config) {
    var transport, type, wrapped, impl, agent, sessions, createConnection;

    config = config || {};

    if (!registered.hasOwnProperty(config.transport)) {
        if (config.transport !== undefined) {
            console.warn('%s unrecognized; defaulting to generic.', config.transport);
        }
        config.transport = 'generic';
    }

    transport = registered[config.transport];

    config.protocol = utils.suffix(config.protocol || 'https:', ':');

    config.basepath = utils.suffix(config.basepath, '/');

    //PayPal does not issue certs for individual hosts, but a generic cert for the entire domain
    //Setting this to false will disable Hostname/IP matching against server cert altnames in tls
    //Works only wih node v0.12 - https://github.com/joyent/node/commit/bf5e2f246eff55dfc33318f0ffb4572a56f7645a
    config.checkServerIdentity = function (host, cert) {
        return false;
    };

    agent = config.agent || httpunch.agents.create(config);

    //Session resume setup.
    if (config.sessions && config.protocol === 'https:') {
        sessions = config.sessions;

        //Save original for wrapping
        createConnection = agent.createConnection;

        //Wrap createConnection to look up session and inject.
        agent.createConnection = function tlsConnect(options) {
            var session = sessions[utils.getSessionKeyName()];

            if (session) {
                debug('resuming SSL session.');
                options.session = new Buffer(session, 'base64');
            }
            //Invoke original
            return createConnection.call(agent, options);
        };
    }

    debug('loading transport type: %s', config.transport);

    impl = transport(config);

    /**
     * Wrapped transport function provides some default http options for transport.
     * @param options - the transport specific options.
     */
    wrapped = function (options, callback) {
        assert.strictEqual(arguments.length, 2, 'expected 2 arguments.');
        assert.ok(thing.isObject(options), 'expected an object as first argument.');
        assert.ok(thing.isFunction(callback), 'expected a callback.');

        options = clone(options);

        options.path = utils.unprefix(options.path, '/');
        options.path = utils.unsuffix(config.basepath + options.path, '/');
        options.headers = utils.normalizeHeaders(options.headers);

        if (!options.headers['user-agent']) {
            options.headers['user-agent'] = utils.userAgentString({ name: pkg.name, version: pkg.version });
        }

        objutil.deepMerge({
            protocol: config.protocol,
            method: config.method,
            hostname: config.hostname,
            port: config.port,
            qs: config.qs,
            pathparams: config.pathparams,
            socketTimeout: config.socketTimeout,
            connectTimeout: config.connectTimeout,
            maxRetry: config.maxRetry,
            headers: config.headers
        }, options);

        options.agent = options.agent || agent;
        options.rawHostname = options.hostname;
        options.method = options.method || 'POST';
        options.retry = options.retry || 0;
        options.dnslookup = (config.dnslookup === false || options.dnslookup === false) ? false : true;

        assert.ok(utils.isHttpMethod(options.method), 'method ' + options.method + ' is not an http method.');
        assert.ok(options.hostname, 'hostname must be defined.');

        debug('transport(): %s//%s:%s%s', options.protocol, options.hostname, options.port, options.path);

        function makeRequest(options, callback) {
            impl(options, function handleResponse(error, response) {
                if (error) {
                    ++options.retry;
                    if (error.code === 'ETIMEDOUT' && options.retry <= options.maxRetry) {
                        debug('connect timeout: retry %d of %d', options.retry, options.maxRetry);
                        makeRequest(options, callback);
                        return;
                    }
                    callback(error);
                    return;
                }
                callback(error, response);
            });
        }

        if (options.dnslookup && net.isIP(options.hostname) === 0) {
            dns.lookup(options.hostname, 4, utils.nsBindCallback(function (error, ip) {

                //Sets the hostname as the ip if no errors. Errors are intentionally ignored in favor of Node Core handling it later.
                if (ip && !error) {
                    debug('dns resolved %s to %s.', options.hostname, ip);
                    options.hostname = ip;
                    options.host = options.hostname + (options.port ? ':' + options.port : '');
                }

                makeRequest(options, callback);
            }));
            return;
        }

        makeRequest(options, callback);
    };

    type = config.transport;

    //Expose other exports in transport module (such as vo and jsonify) to transport function being passed.
    Object.keys(transport).forEach(function (key) {
        Object.defineProperty(wrapped, key, {
            enumerable: true,
            value: transport[key]
        });
    });

    //Read only type property.
    Object.defineProperty(wrapped, 'type', {
        enumerable: true,
        value: type
    });

    return wrapped;
};

/**
 * Register new transports.
 * @param name
 * @param transport
 * @returns {Object}
 */
function register(name, transport) {
    //Do not overwrite default transports.
    if (!~defaultTransports.indexOf(name)) {
        registered[name] = transport;
    }

    return exports;
}

/**
 * Adds a profile to the given transport name.
 * @param name
 * @param profile
 * @returns {exports|*|Object}
 */
function wrap(name, profile) {
    var transports, override, factory;

    if (thing.isFunction(name)) {
        profile = name;
        name = 'all';
    }

    transports = name === 'all' ? Object.keys(registered) : [name];

    transports.forEach(function (name) {
        factory = registered[name];

        if (!factory) {
            debug('no such transport factory: %s.', name);
            return;
        }

        override = function factoryWrapper(config) {
            var transport, wrapped;

            transport = factory.apply(factory, arguments);

            wrapped = function transportWrapper(options, callback) {
                options.clientName = config.clientName;
                options.transportName = config.transport;

                profile(options, callback, function () {
                    return transport.apply(null, arguments);
                });
            };

            return wrapped;
        };

        //Expose other exports in transport module (such as vo and jsonify) to transport function being passed.
        Object.keys(factory).forEach(function (key) {
            Object.defineProperty(override, key, {
                enumerable: true,
                value: factory[key]
            });
        });

        registered[name] = override;
    });

    return exports;
}

exports.register = register;
exports.wrap = wrap;

//Require in default transports and export them.
defaultTransports.forEach(function (transport) {
    registered[transport] = require('./' + transport);
    wrap(transport, profiler());
});
