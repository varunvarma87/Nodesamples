'use strict';

var assert = require('assert'),
    httpunch = require('httpunch'),
    utils = require('../utils'),
    objutil = require('objutil'),
    genericTransport = require('./generic'),
    thing = require('core-util-is');

/**
 * ASF transport communicates with ASF services using OpenJSON payloads.
 * @type {exports}
 */
exports = module.exports = function (config) {
    var transport = genericTransport(config);

    return function asfTransport(options, callback) {
        var req, clientInfo;

        assert.ok(options.service, 'service must be specified.');
        assert.ok(options.operation, 'operation must be specified.');

        clientInfo = options.clientInfo || {};
        options.headers = options.headers || {};

        objutil.mixin({
            'accept': 'application/OpenJson',
            'content-type': 'application/OpenJson',
            'content-encoding': 'OpenJSON'
        }, options.headers);

        options.method = 'post';
        options.path = options.path + '/' + options.operation;

        options.body = JSON.stringify({
            _type: 'ASF::Service::RequestVO',
            service: options.service,
            operation: options.operation,
            params: options.data,
            correlation_id: options.headers['correlation-id'] || options.correlationId,
            client_ip: clientInfo.ip,
            client_pid: clientInfo.pid,
            pool_name: clientInfo.calPoolName,
            pool_stack: clientInfo.poolStack
        });

        return transport(options, function handleAsfResponse(error, response) {
            var serverInfoString, contentType;

            if (error) {
                callback(error);
                return;
            }

            response.body = utils.tryParse(response.body);

            if (!response.body) {
                contentType = response.headers['content-type'];
                callback(contentType && contentType.indexOf('application/OpenJson') === -1 ? new Error('Unexpected content-type: ' + contentType) : new Error('Unable to parse body'), response);
                return;
            }

            //Normalize server-info.
            if (response.body && response.body.server_info) {
                serverInfoString = response.body.server_info.replace(/\*/g, '&');
                response.headers.server_info = serverInfoString;
            }

            callback(null, response);
        });
    };
};

/**
 * Adds _type to JSON.
 * @param type
 * @param properties
 * @returns {{_type: *}}
 */
function vo(type, properties) {
    var obj = {
        _type: type
    };


    Object.keys(properties).forEach(function (key) {
        obj[key] = properties[key];
    });

    return obj;
}

/**
 * Strips _type from OpenJSON.
 * @param vo
 */
function jsonify(obj) {

    if (thing.isObject(obj) && obj._type) {
        delete obj._type;

        Object.keys(obj).forEach(function (key) {
            jsonify(obj[key]);
        });
    }
    else if (thing.isArray(obj)) {
        obj.forEach(function (item) {
            jsonify(item);
        });
    }

    return obj;
}

exports.vo = vo;
exports.jsonify = jsonify;
