'use strict';

var middleware = require('./middleware'),
    assert = require('assert'),
    objutil = require('objutil'),
    transportFactory = require('./transport'),
    utils = require('./utils'),
    thing = require('core-util-is'),
    debug = require('debuglog')('servicecore'),
    httpunch = require('httpunch'),
    callermodule = require('callermodule'),
    Emitter = require('events').EventEmitter;

var cache, configuration, events;

cache = {};
configuration = {};
events = new Emitter();

/**
 * Middleware for servicecore sets up cls.
 * @type {servicecore}
 */
exports = module.exports = middleware;

objutil.mixin({
    get cache() {
        return cache;
    },

    /**
     * @deprecated use transports instead.
     */
    get transport() {
        console.warn('servicecore.transport is deprecated; use servicecore.transports instead.');
        return transportFactory;
    },

    get transports() {
        return transportFactory;
    },

    get utils() {
        return utils;
    },

    /**
     * event emitter.
     */
    get events() {
        return events;
    },

    get configuration() {
        return configuration;
    },

    set configuration(config) {
        assert.ok(config && thing.isObject(config), 'expected configuration to be an object.');
        configuration = config;
    },

    /**
     * Registers a Service implementation.
     * @param name the name to register under
     * @param service the service wrapper factory
     * @returns {*}
     */
    register: function (name, factory) {
        debug('registering %s.', name);

        assert.strictEqual(arguments.length, 2, 'expected name and factory.');
        assert.ok(name && thing.isString(name), 'expected a string name.');
        assert.ok(factory && thing.isFunction(factory), 'expected a factory function to register.');

        cache[name] = factory;

        return exports;
    },

    /**
     * Create an instance of a service implementation.
     * @param name the name of the service module
     * @param override configuration mixin.
     * @returns {ServiceWrapper}
     */
    create: function (name, override) {
        var config, defaultConfig, moduleConfig, factory, client, transport;

        debug('creating %s, in cache: %s', name, !!cache[name]);

        assert.ok(name && thing.isString(name), 'expected a string name.');
        override && assert.ok(thing.isObject(override) || thing.isString(override), 'expected an object or string for override configuration.');

        config = {};

        defaultConfig = configuration.servicecore;
        moduleConfig = configuration[name];

        if (defaultConfig) {
            defaultConfig = utils.normalizeConfiguration(defaultConfig);
            objutil.mixin(defaultConfig, config);
        }
        if (moduleConfig) {
            moduleConfig = utils.normalizeConfiguration(moduleConfig);
            objutil.mixin(moduleConfig, config);
        }
        if (override) {
            override = utils.normalizeConfiguration(override);
            objutil.mixin(override, config);
        }

        transport = transportFactory(config);

        if (!cache[name]) {
            cache[name] = config.transport !== 'ppaas' ? utils.tryRequire(callermodule() + '/node_modules/' + name) || require(name) : require('./client/ppaas');
        }

        config.clientName = name;

        factory = cache[name];

        assert.ok(thing.isFunction(factory), 'client factory must be a function.');

        client = factory(config, transport);

        assert.ok(thing.isObject(client), 'client must be an object.');
        assert.ok(!client.hasOwnProperty('transport'), 'client can not define a transport property.');

        //Add getter to client for transport so that transport properties and functions can be accessed.
        client.__defineGetter__('transport', function () {
            return transport;
        });

        return client;
    }
}, exports);
