'use strict';

var pkg = require('../package.json'),
    objutil = require('objutil'),
    thing = require('core-util-is'),
    url = require('url'),
    cls = require('continuation-local-storage'),
    httpunch = require('httpunch'),
    camelscore = require('camelscore');

var CAL_NAMESPACE = 'node-cal';

//Copy httpunch utils.
Object.keys(httpunch.utils).forEach(function (key) {
    exports[key] = httpunch.utils[key];
});

//Copy camelscore utils
Object.keys(camelscore).forEach(function (key) {
    exports[key] = camelscore[key];
});

/**
 * Creates a local storage for cls.
 * @returns {*}
 */
exports.localStorage = function (name) {
    var ns, clsq, clsbb;

    ns = cls.getNamespace(name || CAL_NAMESPACE);

    if (!ns) {
        ns = cls.createNamespace(name || CAL_NAMESPACE);
    }

    return ns;
};

/**
 * Returns a Date object representing the start of the current week.
 * @param date
 * @returns {Date}
 */
exports.getWeekStart = function getWeekStart(date) {
    var today = date || new Date();

    var day = today.getDay() + 1;

    date = today.getDate() - day;

    return new Date(today.setDate(date + 1));
};

/**
 * Helps construct the keyname to lookup ssl sessions. This is basically the year + month + startDay of current week.
 * @returns {string}
 * @private
 */
exports.getSessionKeyName = function getSessionKeyName(date) {
    var endDate = exports.getWeekStart(date);

    var endYear = String(endDate.getFullYear());
    var endMonth = ('0' + (endDate.getMonth() + 1)).slice(-2);
    var startDay = ('0' + endDate.getDate()).slice(-2);

    return endYear + endMonth + startDay;
};

/**
 * Parses urls in configuration, and prepares configuration object structure.
 * @param config
 * @returns {{}}
 */
exports.normalizeConfiguration = function (config) {
    var parsed;

    config = config || {};

    if (typeof config === 'string') {
        config = {
            url: config
        };
    }

    if (thing.isString(config.url || config.uri)) {
        parsed = url.parse(config.url || config.uri, true);

        config.protocol = parsed.protocol;
        config.hostname = parsed.hostname;
        config.basepath = parsed.pathname;
        config.qs = parsed.query;
        config.port = parsed.port;

        delete config.url;
        delete config.uri;
    }

    if (config.protocol || config.scheme) {
        config.protocol = httpunch.utils.suffix(config.protocol || config.scheme, ':');
        delete config.scheme;
    }

    config.headers = httpunch.utils.normalizeHeaders(config.headers);

    return config;
};

/**
 * Attempts to require a module.
 * @param name
 * @returns {*}
 */
exports.tryRequire = function tryRequire(name) {
    try {
        return require(name);
    }
    catch (err) {
        // noop
    }
    return undefined;
};

exports.nsBindRequest = function nsBindRequest(req) {
    process.namespaces && Object.keys(process.namespaces).forEach(function (k) {
        process.namespaces[k] && process.namespaces[k].bindEmitter(req);
    });

    return req;
};

exports.nsBindCallback = function bindAll(func) {
    process.namespaces && Object.keys(process.namespaces).forEach(function (k) {
        var ns = process.namespaces[k];
        if (ns) {
            func = ns.bind(func);
        }
    });
    return func;
};

exports.getTransactionName = function getTransactionName(options) {
    var txname, match;

    if (!options) {
        return 'unknown';
    }

    if (options.transportName === 'ppaas' || options.transportName === 'generic' || options.transportName === 'rest') {
        options.path = options.path || '/';
        match = options.path.match(/^(\/([\w\d]+)){0,3}/);
        txname = options.clientName + '_' + options.method + match[0].replace(/\//g, '_');
    }
    else {
        txname = options.clientName + '_' + options.operation;
    }

    return txname;
};
