'use strict';

var Utils = require('./utils');
var Http = require('http');
var Https = require('https');
var Thing = require('core-util-is');
var Hoek = require('hoek');

var protocol = {
    'http:': Http,
    'https:': Https
};

/**
 * Create and potentially begin a request.
 * @param options request options.
 * @param callback optional callback. If a callback is provided, the request is executed and the callback invoked with the response.
 * @returns {ClientRequest}
 * @private
 */
function _request(options, callback) {
    var req, connectEvent;

    options = options || {};

    Utils.debug('%s %s//%s:%s%s', options.method.toUpperCase(), options.protocol, options.hostname, options.port || (options.protocol === 'https:' ? 443 : 80), options.path);

    req = protocol[options.protocol].request(options);

    //Write body
    if (options.body) {
        Utils.debug('request body (length=%d)', options.headers['content-length']);
        req.write(options.body);
    }

    return wrap(req, options, callback);
}

function wrap(req, options, callback) {
    var connectTimeout, connectEvent;

    connectEvent = options.protocol === 'https:' ? 'secureConnect' : 'connect';

    if (Hoek.isInteger(options.connectTimeout) && options.connectTimeout > 0) {
        req.once('socket', onSocket);
    }

    if (Hoek.isInteger(options.socketTimeout) && options.socketTimeout > 0) {
        setSocketTimeout();
    }

    //Start request if a callback was provided.
    if (callback && Thing.isFunction(callback)) {
        callback = Hoek.once(callback);
        req.once('response', onResponse);
        req.once('error', finish);
        req.on('error', Hoek.ignore);
        req.end();
        return req;
    }

    //Add an optional callback parameter to end().
    req.end = wrapEnd();

    //Add pipe function
    req.pipe = handlePipe();

    function finish(error, res) {
        clearOnTimeout();

        if (error) {
            Utils.debug('request error: %s', error.message);
            req.destroy();
        }

        req.removeListener('error', finish);
        req.removeListener('response', onResponse);
        req.removeListener('socket', onSocket);
        req.socket.removeListener(connectEvent, clearOnTimeout);

        callback && callback(error, res);
    }

    function onResponse(res) {
        handleRedirect(res, options, function (error, redirect) {
            if (error) {
                finish(error, res);
                return;
            }
            if (redirect) {
                _request(redirect, callback);
                return;
            }

            Utils.read(res, function (error, body) {
                if (error) {
                    finish(error, res);
                    return;
                }

                res.body = body;

                finish(null, res);
            });
        });
    }

    function onConnectTimeout() {
        var error = new Error('connect ETIMEDOUT');
        error.code = 'ETIMEDOUT';

        Utils.debug('connect timeout after %dms.', options.connectTimeout);

        req.socket.emit('error', error);
    }

    function onSocket(socket) {
        Utils.debug('connect timeout=%d', options.connectTimeout);
        connectTimeout = setTimeout(onConnectTimeout, options.connectTimeout);
        socket.once(connectEvent, clearOnTimeout);
    }

    function setSocketTimeout() {
        Utils.debug('response timeout=%d', options.socketTimeout);

        req.setTimeout(options.socketTimeout, function timedout() {
            Utils.debug('response timeout after %dms.', options.socketTimeout);
            req.abort();
        });
    }

    function clearOnTimeout() {
        clearTimeout(connectTimeout);
    }

    function handleRedirect(res, options, callback) {
        var redirect, redirectUrl;

        if (Utils.isRedirect(res.statusCode) && Utils.supportsFollowRedirect(options.method)) {
            redirectUrl = res.headers.location;
            options.redirects = options.redirects ? options.redirects + 1 : 0;

            if (redirectUrl && options.redirects++ < options.maxRedirects) {

                redirect = Utils.parseOptions(redirectUrl);
                redirect.method = 'GET';
                redirect.headers = options.headers;

                Object.keys(options).forEach(function (key) {
                    if (!redirect[key]) {
                        redirect[key] = options[key];
                    }
                });

                redirect.headers.host = redirect.hostname + redirect.port ? ':' + redirect.port : '';

                res.destroy();

                callback(null, redirect);

                return;
            }

            Utils.debug('followed maxRedirects (%d)', options.maxRedirects);
        }

        callback();
    }

    function handlePipe() {

        return function pipe(socket, opts) {

            function finishPipe(error, res) {
                clearOnTimeout();

                req.removeListener('error', finishPipe);
                req.removeListener('response', onPipeResponse);
                req.removeListener('socket', onSocket);
                req.socket.removeListener(connectEvent, clearOnTimeout);
                socket.removeListener('error', onSocketError);

                if (error) {
                    Utils.debug('request error: %s', error.message);
                    req.destroy();
                }
            }

            function onPipeResponse(res) {
                handleRedirect(res, options, function (error, redirect) {
                    if (error) {
                        finishPipe(error);
                        return;
                    }
                    if (redirect) {
                        _request(redirect).pipe(socket, opts);
                        return;
                    }

                    res.headers && socket.writeHead && Utils.copyHeaders(res, socket);

                    Utils.pipe(res, socket, opts);
                });
            }

            function onSocketError(error) {
                req.emit('error', error);
                finish(error);
            }

            Utils.debug('request pipe');

            req.once('response', onPipeResponse);
            req.once('error', finishPipe);
            req.on('error', Hoek.ignore);
            socket.once('error', onSocketError);

            if (opts && opts.end === false) {
                return req;
            }

            req.end();
        };
    }

    function wrapEnd() {
        var _end = req.end;

        return function end(cb) {
            if (cb && Thing.isFunction(cb)) {
                callback = Hoek.once(cb);
                req.once('response', onResponse);
                req.once('error', finish);
                req.on('error', Hoek.ignore);
            }
            _end.apply(req);
            req.end = _end;
        };
    }

    return req;
}

module.exports = _request;
