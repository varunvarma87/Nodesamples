'use strict';

var URL = require('url');
var Querystring = require('querystring');
var OS = require('os');
var Path = require('path');
var Thing = require('core-util-is');
var Assert = require('assert');
var Debuglog = require('debuglog');

exports.debug = Debuglog('httpunch');

exports.endsWith = function (haystack, needle) {
    if (!haystack || !needle) {
        return false;
    }

    if (needle.length === 1) {
        return haystack[haystack.length - 1] === needle;
    }

    return haystack.slice(haystack.length - needle.length) === needle;
};

exports.prefix = function (str, pre) {
    str = str || '';
    if (str.indexOf(pre) === 0) {
        return str;
    }

    str = pre + str;
    return str;
};

exports.unprefix = function (str, pre) {
    str = str || '';
    if (str.indexOf(pre) === 0) {
        str = str.substr(pre.length);
        return str;
    }

    return str;
};

exports.suffix = function (str, suff) {
    str = str || '';
    if (exports.endsWith(str, suff)) {
        return str;
    }

    str = str + suff;
    return str;
};

exports.unsuffix = function (str, suff) {
    str = str || '';
    if (exports.endsWith(str, suff)) {
        str = str.substr(0, str.length - suff.length);
        return str;
    }

    return str;
};

var HttpMethod = exports.HttpMethod = {
    GET: 'GET',
    POST: 'POST',
    PUT: 'PUT',
    DELETE: 'DELETE',
    HEAD: 'HEAD',
    OPTIONS: 'OPTIONS',
    TRACE: 'TRACE',
    CONNECT: 'CONNECT',
    PATCH: 'PATCH'
};

/**
 * Determines if the given http method supports body.
 * @param method
 * @returns {boolean}
 */
exports.supportsBody = function (method) {
    switch (method && method.toUpperCase()) {
    case 'POST':
    case 'PUT':
    case 'TRACE':
    case 'OPTIONS':
    case 'PATCH':
    case 'GET':
    case 'DELETE':
        return true;
    default:
        return false;
    }
};

/**
 * Determines if the given http method supports automatic redirect following.
 * @param method
 * @returns {boolean}
 */
exports.supportsFollowRedirect = function (method) {
    method = method.toUpperCase();
    return method === 'GET' || method === 'HEAD';
};

/**
 * Determines if the given method is a supported HTTP method.
 * @param method
 * @returns {boolean}
 */
exports.isHttpMethod = function isHttpMethod(method) {
    return (typeof method === 'string') && HttpMethod.hasOwnProperty(method.toUpperCase());
};

/**
 * Detects redirect status codes.
 * @param statusCode
 * @returns {boolean}
 */
exports.isRedirect = function isRedirect(statusCode) {
    switch (statusCode) {
    case 301:
    case 302:
    case 303:
    case 307:
        return true;
    default:
        return false;
    }
};

/**
 * Makes case consistent.
 * @param headers
 * @returns {{}}
 */
exports.normalizeHeaders = function normalizeHeaders(headers) {
    headers = headers || {};

    Object.keys(headers).forEach(function (header) {
        var value = headers[header];
        delete headers[header];
        headers[header.toLowerCase()] = value;
    });

    return headers;
};

/**
 * Determines if content-type is url encoded.
 * @param res
 * @returns {boolean}
 */
exports.isJSON = function isJSON(res) {
    if (res && res.headers && res.headers['content-type']) {
        return res.headers['content-type'].indexOf('application/json') > -1;
    }
    return false;
};

/**
 * Determines if content-type is form encoded.
 * @param res
 * @returns {boolean}
 */
exports.isFormEncoded = function isFormEncoded(res) {
    if (res && res.headers && res.headers['content-type']) {
        return res.headers['content-type'].indexOf('application/x-www-form-url-encoded') > -1;
    }
    return false;
};

/**
 * Parses the content type from the content type header.
 * @param res
 * @returns {*}
 */
exports.parseContentType = function parseContentType(res) {
    var split;

    if (res && res.headers && res.headers['content-type']) {
        split = res.headers['content-type'].split(';');

        if (split.length > 1) {
            split[1] = split[1].substring(split[1].indexOf('=') + 1).toLowerCase();
        }
        else {
            split.push('utf8');
        }

        return {
            type: split[0],
            encoding: split[1]
        };
    }
    return {};
};

/**
 * Attempts to parse into JSON.
 * @param data
 * @returns {*}
 */
exports.tryParse = function (data) {
    try {
        data = JSON.parse(data);
    }
    catch (e) {
    }

    return data;
};

/**
 * Parse and normalize options.
 * @param options
 * @returns {*}
 */

exports.parseOptions = function (options) {
    var url;

    options || (options = {});

    Assert.ok(Thing.isObject(options) || Thing.isString(options), 'Expected an object or a string for options.');

    if (Thing.isString(options)) {
        url = URL.parse(options);
        options = {
            protocol: url.protocol,
            hostname:  url.hostname,
            port:  url.port,
            path: url.path
        };
    }
    else if (options.url) {
        url = URL.parse(options.url);
        delete options.url;

        options.protocol = url.protocol;
        options.hostname =  url.hostname;
        options.port =  url.port;
        options.path = url.path;
    }

    options.headers || (options.headers = {});

    Object.keys(options.headers).forEach(function (name) {
        if (Thing.isUndefined(options.headers[name])) {
            delete options.headers[name];
        }
    });

    if (options.pathparams) {
        Assert.ok(Thing.isObject(options.pathparams), 'Expected an object for path parameters.');

        options.path = options.path.replace(/{([^}]+)}/g, function () {
            return options.pathparams[arguments[1]] || arguments[0];
        });
    }

    if (options.qs) {
        options.path = exports.unsuffix(options.path, '/');

        if (Thing.isObject(options.qs)) {
            options.qs = Querystring.stringify(options.qs);
        }

        options.path = options.path + '?' + options.qs;
    }

    options.path = exports.prefix(options.path, '/');
    options.protocol = exports.suffix(options.protocol || options.scheme || 'http:', ':');
    options.hostname = options.hostname || options.host || '127.0.0.1';
    options.maxRedirects = options.maxRedirects || 0;

    options.scheme && delete options.scheme;

    return options;
};

exports.sliceArgs = function (argv) {
    var args = new Array(argv.length);

    for (var i = 0; i < argv.length; ++i) {
        args[i] = argv[i];
    }

    return args;
};

/**
 * Reads a response stream.
 * @param res
 * @param callback
 */
exports.read = function read(res, callback) {
    var data = [];

    exports.debug('response status: %d', res.statusCode);

    function onReadable() {
        var chunk;

        while ((chunk = res.read()) !== null) {
            data.push(chunk);
        }
    }

    function onEnd() {
        var body = Buffer.concat(data);

        exports.debug('response end (body length=%d)', body.length);

        callback(null, body);

        res.removeListener('error', onError);
        res.removeListener('readable', onReadable);

        body = null;
        data = null;
    }

    function onError(error) {
        exports.debug('response error: %s', error.message);

        callback(error);

        res.removeListener('end', onEnd);
        res.removeListener('readable', onReadable);

        data = null;
    }

    res.on('readable', onReadable);
    res.once('end', onEnd);
    res.once('error', onError);
};

/**
 * Pipes incoming to outgoing streams.
 * @param incoming
 * @param outgoing
 * @param options
 */
exports.pipe = function pipe(incoming, outgoing, options) {
    incoming.pause();

    incoming.pipe(outgoing, options);

    incoming.resume();
};

/**
 * Copies headers across from an incoming message to a server response.
 * @param incoming
 * @param outgoing
 */
exports.copyHeaders = function copyHeaders(incoming, outgoing) {
    var headers = {};

    Object.keys(incoming.headers || {}).forEach(function (key) {
        headers[key] = incoming.headers[key];
    });

    Object.keys(incoming.trailers || {}).forEach(function (key) {
        headers[key] = incoming.trailers[key];
    });

    if (outgoing.headersSent) {
        outgoing.addTrailers(headers);
    }
    else {
        outgoing.writeHead(outgoing.statusCode, headers);
    }
};

/**
 * Trims irrelevant options from a config being passed to agent creation.
 * @param options
 * @returns {{}}
 */
exports.cleanAgentConfig = function cleanAgentConfig(options) {
    var clean = {};

    if (!options) {
        return clean;
    }

    Assert.ok(Thing.isObject(options), 'Expected an object for options.');

    Object.keys(options).forEach(function (key) {
        switch (key) {
        case 'protocol':
        case 'maxSockets':
        case 'maxFreeSockets':
        case 'keepAlive':
        case 'keepAliveMsecs':
        case 'ciphers':
        case 'key':
        case 'cert':
        case 'passphrase':
        case 'ca':
        case 'pfx':
        case 'rejectUnauthorized':
        case 'secureProtocol':
        case 'checkServerIdentity':
            clean[key] = options[key];
            break;
        default:
            break;
        }
    });

    return clean;
};

/**
 * Creates a user agent string for this client.
 * @param name alternate client name.
 * @returns {string}
 */
exports.userAgentString = function (override) {
    var pkg = {
        name: 'httpunch',
        version: 'unknown'
    };

    if (override && Thing.isObject(override)) {
        pkg.name = override.name || pkg.name;
        pkg.version = override.version || pkg.version;
    }
    else {
        try {
            pkg = require(Path.join(process.cwd(), 'package.json'));
        }
        catch (e) {
        }
    }

    return pkg.name + '/' + pkg.version + ' (' + OS.arch() + '-' + OS.platform() + ') node/' + process.versions.node;
};
