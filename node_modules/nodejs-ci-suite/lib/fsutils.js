'use strict';
var fs = require('fs'),
    path = require('path'),
    util = require('util'),
    async = require('async'),
    mkdirp = require('mkdirp');

module.exports = {
    copy: copy,
    copySync: copySync,

    copydir: copydir,
    copydirSync: copydirSync,

    forEach: forEach,

    isEmpty: isEmpty,
    isEmptySync: isEmptySync,

    mkdirp: mkdirp,
    mkdirpSync: mkdirp.sync,

    move: move,
    moveSync: moveSync,

    rmdirf: rmdirf,
    rmdirfSync: rmdirfSync
};

function move(src, dest, cb) {
    cb(new Error('move not implemented'));
}

function moveSync(src, dest) {
    throw new Error('moveSync not implemented');
}

/**
 * Determines whether or not a folder is empty.
 * @param {String} dir the path of the directory to check
 * @param {Function} cb the callback to invoke with the result
 */
function isEmpty(dir, cb) {
    cb || (cb = function () {});

    fs.readdir(dir, function (err, files) {
        if (err && err.code !== 'ENOENT') {
            return cb(err);
        }

        cb(null, !files || files.length === 0);
    });
}

/**
 * Determines whether or not a folder is empty.
 * @param {String} dir the path of the directory to check
 */
function isEmptySync(dir) {
    return fs.readdirSync(dir).length === 0;
}

/**
 *
 * @param src
 * @param dest
 * @param cb
 */
function copy(src, dest, cb) {
    cb || (cb = function () {});

    fs.stat(src, function (err, stats) {
        if (err) { return cb(err); }

        if (!stats.isFile()) {
            return cb(new Error('srcpath is not a file: ' + src));
        }

        mkdirp(path.dirname(dest), function (err) {
            if (err) { return cb(err); }

            var is = fs.createReadStream(src),
                os = fs.createWriteStream(dest);

            is.on('error', cb);
            os.on('error', cb);

            os.on('close', cb);

            is.pipe(os);
        });
    });
}

/**
 *
 * @param src
 * @param dest
 */
function copySync(src, dest) {
    throw new Error('copySync not implemented');
}

/**
 * Copies the contents of the specified dir into the dest dir, creating the
 * dest dir if necessary.
 * @param src
 * @param dest
 * @param cb
 */
function copydir(src, dest, cb) {
    cb || (cb = function () {});

    src  = path.resolve(src);
    dest = path.resolve(dest);

    function processDir(dir, next) {
        if (src === dir) { return next(); }

        var rel = path.relative(src, dir);
        copydir(path.join(src, rel), path.join(dest, rel), next);
    }

    function processFile(file, next) {
        var rel = path.relative(src, file);
        copy(path.join(src, rel), path.join(dest, rel), next);
    }

    mkdirp(dest, function (err) {
        if (err) { return cb(err); }

        fs.stat(src, function (err, stats) {
            if (err) { return cb(err); }

            if (!stats.isDirectory()) {
                return cb(new Error('srcpath is not a directory: ' + src));
            }

            forEach(src, processDir, processFile, cb);
        });
    });
}

/**
 *
 * @param src
 * @param dest
 */
function copydirSync(src, dest) {
    throw new Error('copydirSync not implemented');
}

/**
 * @param {String} dir
 * @param {Function} cb
 */
function rmdirf(dir, cb) {
    cb || (cb = function () {});

    if (dir === '/') {
        return cb(new Error("rmdirf('/') is bad, mmkay?"));
    }

    forEach(dir, fs.rmdir, fs.unlink, cb);
}

/**
 * @param {String} dir
 */
function rmdirfSync(dir) {
    if (dir === '/') {
        throw new Error("rmdirfSync('/') is bad, mmkay?");
    }

    if (!fs.existsSync(dir)) {
        return;
    }

    var files = fs.readdirSync(dir);
    var file;
    var stats;

    while (files.length) {
        file  = path.join(dir, files.shift());
        stats = fs.statSync(file);

        if (stats.isDirectory()) {
            rmdirfSync(file);
        }
        else if (stats.isFile()) {
            fs.unlinkSync(file);
        }
    }

    fs.rmdirSync(dir);
}

/**
 *
 * @param dir
 * @param dirIterator
 * @param fileIterator
 * @param cb
 */
function forEach(dir, onDir, onFile, cb) {
    cb || (cb = function () {});

    fs.readdir(dir, function (err, files) {
        // Ignore ENOENT
        if (err) { return err.code === 'ENOENT' ? cb() : cb(err); }

        var file;
        var remaining = files.length;
        var tasks = [];

        if (!remaining) {
            return onDir(dir, cb);
        }

        function onStat(file) {
            return function (err, stats) {
                var task;

                if (stats.isDirectory()) {
                    task = function (next) {
                        // Descend
                        forEach(file, onDir, onFile, next);
                    };
                }
                else if (stats.isFile()) {
                    task = function (next) {
                        // Process
                        onFile(file, next);
                    };
                }

                task && tasks.push(task);
                remaining--;

                if (!remaining) {
                    // All files have been evaluated, so start processing
                    async.waterfall(tasks, function (err) {
                        if (err) { return cb(err); }

                        onDir(dir, cb);
                    });
                }
            };
        }

        while (files.length) {
            file = path.join(dir, files.shift());

            fs.stat(file, onStat(file));
        }
    });
}
