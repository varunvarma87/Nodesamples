'use strict';

var passport = require('passport'),
    createHandler = require('./handler'),
    Strategy = passport.Strategy,
    servicecore = require('servicecore'),
    tokenservice = require('tokenservice-paypal'),
    StrategyNames = require('./strategyNames'),
    utils = require('./utils'),
    cookieutils = require('./cookies/util'),
    debug = require('debuglog')('ppauth');

function PaypalAuthentication() {
    PaypalAuthentication.super_.apply(this, arguments);
    this.name = StrategyNames.LOGIN;
    servicecore.register('tokenservice-paypal', tokenservice);
    this._tokenservice = servicecore.create('tokenservice-paypal');
}

require('util').inherits(PaypalAuthentication, Strategy);

PaypalAuthentication.prototype.authenticate = function (req, options) {
    var self, headers, credentials;

    self = this;

    if (!req._passport) {
        return this.error(new Error('passport.initialize() middleware not in use'));
    }
    if (!req.param('session_token')) {
        if (!req.body.type && !req.body.claim1 && !req.body.claim2) {
            return this.error(new Error('A login mechanism must be selected'));
        }
        else if (!req.body.username || !req.body.password) {
            return this.error(new Error('Missing credentials'));
        }
    }

    if (req.param('session_token')) {
        //SLIM TOKEN
        credentials = {
            session_token: req.param('session_token')
        };
    } else {
        //FAT TOKEN
        //0 is ALIAS/PASSWORD and 1 is PHONE/PIN, else send what application sets
        var claim1, claim2, channel, tokenType,
        actor = req.body.actorInfoVO ? req.body.actorInfoVO : {};

        if (req.body.claim1) {
            claim1 = req.body.claim1;
        } else {
            claim1 = (req.body.type === "1") ? 2 : 0;
        }
        if (req.body.claim2) {
            claim2 = req.body.claim2;
        } else {
            claim2 = (req.body.type === "1") ? 3 : 1;
        }
        if (req.body.channel) {
            channel = req.body.channel;
        } else {
            channel = (claim1 === 2) ? 'MOBILE' : 'WEB';
        }
        if (req.body.tokenType) {
            tokenType = req.body.channel;
        } else {
            tokenType = (claim1 === 2) ? 3 : 0;
        }
        credentials = {
            authenticationClaims: [{
                type: claim1,
                value: req.body.username
            },
                {
                    type: claim2,
                    value: req.body.password
                }],
            actorInfoVO: actor,
            channel: channel,
            tokenType: tokenType
        };
    }

    if (options.postLoginAuthorizationUris) {
        credentials.postLoginAuthorizationUris = options.postLoginAuthorizationUris;
    }

    headers = { cookie: cookieutils.includedCookiesString(req.cookies || {}) };

    debug('Calling create token with type %d:', req.body.type);

    this._tokenservice.login(credentials, headers, function (error, result) {
        var body, errorMessage;

        if (error) {
            debug('Error: %s.', error.message);
            self.error(error);
            return;
        }

        if (result.statusCode === 200) {
            utils.convertSecurityContext(result.body, function (error, securityContext, sessionToken, actorInfo) {
                if (error) {
                    self.error(error);
                    return;
                }

                debug('Auth State: %s', securityContext.actor.auth_state);

                req.securityContext = securityContext;
                req.sessionToken = sessionToken;
                req.actorInfo = actorInfo;
                req.riskPassBack = result.body.details && result.body.details.riskPassBack;

                if (securityContext.actor.auth_state === 'LOGGEDIN') {
                    debug('Logged in.');

                    utils.getUser(req, options, function (error, user) {
                        if (error) {
                            self.error(error);
                            return;
                        }

                        self.success(securityContext.actor, {'set-cookie': result.headers['set-cookie']});
                    });

                    return;
                }

                debug('Login failed.');

                self.fail();
                return;
            });

            return;
        }

        errorMessage = 'Unknown Error';
        body = result.body;

        if (body) {
            errorMessage = body.localizedMessage || body.message || JSON.stringify(body);
        }

        debug('Error: %s.', errorMessage);

        self.error(errorMessage);
    });
};

/**
 * Convenience method for calling the login strategy's authenticate method.
 * @param options for passport strategies
 * @param customHandler to use instead of default handler.
 */
function login(options, customHandler) {
    if (typeof options === 'function') {
        customHandler = options;
        options = {};
    }
    if (!options) {
        options = {};
    }

    return function loginStrategy(req, res, next) {
        var handler;

        //TODO: Logout First!?

        handler = createHandler(customHandler, options, req, res, next);

        debug('Calling login:');

        passport.authenticate(StrategyNames.LOGIN, options, handler).apply(passport, arguments);
    };
}

module.exports = login;
module.exports.Strategy = PaypalAuthentication;
