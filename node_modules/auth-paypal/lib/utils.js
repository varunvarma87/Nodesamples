'use strict';

var debug = require('debuglog')('ppauth'),
    camelscore = require('camelscore'),
    authtoken = require('authtoken-paypal'),
    tokenservice = require('tokenservice-paypal').UserPayPal,
    constants = require('./constants');

exports = module.exports = {

    /**
     * Regenerates the current session, carrying _csrfSecret forward.
     * @param req
     * @param fn
     * @private
     */
    regenerateSession: function regenerateSession(req, fn) {
        var session, csrfSecret;

        session = req.session;

        debug('Invalidating session.');

        if (session) {
            csrfSecret = session._csrfSecret;

            session.regenerate(function (error) {
                req.session._csrfSecret = csrfSecret;
                fn();
            });

            return;
        }

        fn();
    },

    convertSecurityContext: function convertSecurityContext(legacyContext, callback) {
        var context, actor;

        context = {};
        actor = camelscore.underscorify(legacyContext.details.actorInfoVO);
        legacyContext = camelscore.underscorify(legacyContext);

        if (actor.token) {
            authtoken.deserialize(actor.token, function (error, token) {
                if (error) {
                    callback(error);
                    return;
                }

                context.actor = {
                    id: actor.actor_id,
                    party_id: actor.actor_account_number,
                    account_number: actor.actor_account_number,
                    auth_state: 'ANONYMOUS',
                    auth_claims: undefined
                };

                switch (actor.actor_auth_type) {
                    case 72:
                    case 104:
                    case 88:
                        context.actor.auth_state = 'PARTIALLY_AUTHENTICATED';
                        break;
                    case 66:
                    case 68:
                    case 70:
                    case 80:
                    case 83:
                    case 87:
                        if (legacyContext.logged_in) {
                            context.actor.auth_state = 'LOGGEDIN';
                        }
                        break;
                    case 82:
                        context.actor.auth_state = 'REMEMBERED';
                        break;
                    default:
                        context.actor.auth_state = 'ANONYMOUS';
                        break;
                }

                if (actor.actor_auth_type === 80) {
                    context.actor.auth_claims = [
                        'USERNAME', 'PASSWORD'
                    ];
                }
                else if (actor.actor_auth_type === 87) {
                    context.actor.auth_claims = [
                        'PHONE', 'PIN'
                    ];
                }

                context.subjects = [{
                    "subject": context.actor
                }];

                context.auth_token = actor.token;
                context.auth_token_type = 'SESSION_TOKEN';
                context.scopes = [
                    '*'
                ];

                context.global_session_id = token.session_id;
                context.last_validated = token.session_time;

                callback(null, context, token, actor);
            });
            return;
        }
        callback(new Error('No token after login'));
    },

    /**
     * Checks for presence of any RISK flags in SIM response.
     * @param req
     * @param callback
     * @private
     */
    riskCheck: function riskCheck(req, callback) {
        //Even if user is authenticated and logged-in, ensure RISK didn't find a problem
        var loginVO = req.user && req.user.loginVO && req.user.loginVO,
            riskFlag = (loginVO && loginVO.needsValidation !== undefined) ? loginVO.needsValidation : loginVO && loginVO.needs_validation;
        if (riskFlag && constants.DENIED_LOGIN_VALIDATION_TYPES.indexOf(riskFlag) > -1) {
            debug('RISK: Spoof, Bad IP or Restricted');
            callback(constants.REDIRECTS.DENIED);
        } else {
            callback();
        }
    },

    /**
     * Gets user given actor.
     * @param req
     * @param callback
     * @private
     * TODO: Clean up, separate concerns.
     */
    getUser: function getUser(req, options, callback) {

        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        
        if (req.session && req.session._user_read_auth) {
            debug('User exists in session');
            if (req.securityContext && req.securityContext.actor) {
                if (req.session._user_read_auth.accountNumber === req.securityContext.actor.account_number) {
                    req.user = req.session._user_read_auth;
                    callback(null, req.session._user_read_auth);
                    return;
                }
            }
            req.session._user_read_auth = null;
        }

        debug('No user in session or account number mismatch, getting user');

        tokenservice.getUserPayPal(req.actorInfo, options, function (error, user) {
            if (error) {
                debug(error);
                callback(error);
                return;
            }

            if (req.session) {
                req.session._user_read_auth = user;
            }

            req.user = user;

            callback(null, user);
        });
    }

};
