'use strict';

var CookieNames = require('./names'),
    debug = require('debuglog')('ppauth');

var _includeList = [CookieNames.LANG, CookieNames.LOGIN_EMAIL_COOKIE, CookieNames.BETA_COOKIE_NAME, 'HaC80bwXscjqZ7KM6VOxULOB534', 'TVKbnJIgoopqCTftP3PCeQTrLnu'];

/**
 * Configure options.
 * @param options
 */
function configure(options) {
    if (!options) {
        options = {
            include: []
        };
    }
    if (!options.include) {
        options.include = [];
    }

    options.include.forEach(function (name) {
        _includeList.push(name);
    });
}

/**
 * Return a new string with only included cookies.
 * @param cookies
 * @returns {string}
 */
function includedCookiesString(cookies) {
    var cookieString = '';

    cookies = inclusions(cookies);

    for (var i = 0, names = Object.keys(cookies) || []; i < names.length; i++) {
        cookieString += names[i] + '=' + encodeURIComponent(cookies[names[i]]);
        if (i < names.length - 1) {
            cookieString += ';';
        }
    }

    return cookieString;
}

/**
 * Get inclusions only.
 * @param cookies
 * @returns {*}
 */
function inclusions(cookies) {
    var _inclusions = {};
    _includeList.forEach(function (name) {
        if (cookies[name]) {
            _inclusions[name] = cookies[name];
        }
    });
    return _inclusions;
}

/**
 * Set cookies received from the bridge.
 * @param req
 * @param res response to set cookies on
 * @param setCookieHeader cookies to set
 */
function setCookies(req, res, setCookieHeader) {
    var host, domain, cookies;

    debug('Set cookies: %s', setCookieHeader);

    //Let's grab the domain for this request.
    host = req.get('host');
    domain = host.substr(0, host.indexOf(':') || host.length);

    cookies = inclusions(parseCookies(setCookieHeader));

    Object.keys(cookies).forEach(function (name) {

        var cookie = cookies[name];

        //Fix domain on localhost
        if (domain === 'localhost') {
            delete cookie.options.domain;
        }

        //Ignore secure flag on http.
        if (req.protocol !== 'https') {
            delete cookie.options.secure;
        }

        res.cookie(name, cookie.value, cookie.options);
    });
}

/**
 * Parse cookies out of a set-cookies header string (array).
 * @param setCookieHeader set-cookies header
 */
function parseCookies(setCookieHeader) {
    if (!setCookieHeader) {
        return {};
    }
    if (!Array.isArray(setCookieHeader)) {
        setCookieHeader = [setCookieHeader];
    }

    var cookies = {};

    setCookieHeader.forEach(function (cookie) {
        var pairs = cookie.split(/[;] */);

        var name = pairs[0].substr(0, pairs[0].indexOf('=')).trim();

        var value = pairs[0].substr(pairs[0].indexOf('=') + 1, pairs[0].length).trim();

        var newcookie = {};

        newcookie.options = {};

        newcookie.name = name;

        try {
            newcookie.value = decodeURIComponent(value);
        }
        catch (e) {
            newcookie.value = value;
        }

        for (var i = 1; i < pairs.length; i++) {
            //Lower case the first letter.
            var pair = pairs[i].substr(0, 1).toLowerCase() + pairs[i].substr(1, pairs[i].length);

            var eq_idx = pair.indexOf('=');

            if (eq_idx > 0) {
                var key = pair.substr(0, eq_idx).trim();
                var val = pair.substr(++eq_idx, pair.length).trim();

                // quoted values
                if ('"' === val[0]) {
                    val = val.slice(1, -1);
                }

                //Convert dates
                if (key === 'expires') {
                    newcookie.options[key] = new Date(val);
                }
                else {
                    try {
                        newcookie.options[key] = decodeURIComponent(val);
                    }
                    catch (e) {
                        newcookie.options[key] = val;
                    }
                }
            }
            else {
                newcookie.options[pair] = !!pair;
            }
        }

        cookies[newcookie.name] = { value: newcookie.value, options: newcookie.options };
    });

    return cookies;
}

function userSessionCookie(req) {
    return req.cookies.HaC80bwXscjqZ7KM6VOxULOB534 || req.cookies.TVKbnJIgoopqCTftP3PCeQTrLnu;
}

exports = module.exports = {
    configure: configure,
    includedCookiesString: includedCookiesString,
    setCookies: setCookies,
    parseCookies: parseCookies,
    userSessionCookie: userSessionCookie
};
