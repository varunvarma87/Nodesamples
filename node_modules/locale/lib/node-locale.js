/**
 *
 *  Resposible for resolving country, dialect and timezone
 *
 *  Using
 *      1. Loading all JQuery Globalize cultures for formatting
 *      2. COW for country specific rules
 */
'use strict';

var tryRequire = require('try-require'),
    cal = tryRequire('cal'),
    CountryResolver = require('./resolvers/country-resolver'),
    DialectResolver = require('./resolvers/dialect-resolver'),
    TimeZoneResolver = require('./resolvers/timezone-resolver'),
    directionalityResolver = require('./resolvers/directionality-resolver'),
    Globalize = require('globalize'),
    CowFactory = require('./cow/index'),
    currencies = require('./constants/currencies'),
    patterns = require('./constants/patterns'),
    CAL_TRANSCATION_TYPE = 'LOCALE';

//loading all cultures to reduce the multiple disk lookup + add global support
require('globalize/lib/cultures/globalize.cultures.js');



var resolver;

module.exports = function nodeLocale(options) {

    resolver = new Resolver(options);

    module.exports.resolve = function (req, res) {
        resolver.resolve(req, res);
    };

    module.exports.languages = resolver.supportedLocales;

    return function locale(req, res, next) {
        resolver.resolve(req, res);
        next();
    };
};


function Resolver(options) {

    this.options = options || {};
    this.cowFactory = CowFactory(this.options, cal);
}

Resolver.prototype.resolve = function (req, res) {

    var calEvent;

    if (cal) {
        calEvent = cal.createEvent(CAL_TRANSCATION_TYPE, 'locale');
        calEvent.status = cal.Status.SUCCESS;
        calEvent.correlationId = req.correlationId;
    }

    var country = new CountryResolver(
        this.cowFactory,
        this.options,
        calEvent
    ).resolve(req, res);

    var dialect = new DialectResolver(
        country.cow,
        this.options,
        calEvent
    ).resolve(req, res);

    var timezone = new TimeZoneResolver(
        country.cow,
        this.options,
        calEvent
    ).resolve(req, res);

    var directionality = directionalityResolver.resolve(dialect.language);


    var locality = req.locality = {
        timezone : timezone.value,
        country  : country.value,
        locale : dialect.value,
        culture : dialect.language + '-' + country.value,
        language : dialect.language,
        directionality : directionality,
        getCountrySpecifics : function () {
            return country.cow;
        },
        formatter : function (countryParam, cultureParam) {
            return formatter(countryParam || country.value, cultureParam || dialect.language + '-' + country.value);
        },
        determiners: {
            country: country.determiner,
            locale: dialect.determiner,
            timezone: timezone.determiner
        }
    };


    //adding locality in res.locals.context for client side to consume
    res.locals = res.locals || {};
    res.locals.context = res.locals.context || {};
    res.locals.context.locality = {
        timezone : timezone,
        country  : country.value,
        locale : dialect.value,
        language : dialect.language,
        directionality : directionality
    };

    var rlc = res.locals && res.locals.context;

    var templatePath = {
        language: dialect.language.toLowerCase(),
        country: country.value
    };

    if (rlc && rlc.links && rlc.links.templateBaseUrl) {

        // Save the original template base url (e.g. /templates) which we can use to rebuild templateBaseUrl
        rlc.links.originalTemplateBaseUrl = rlc.links.originalTemplateBaseUrl || rlc.links.templateBaseUrl;

        // Rebuild the base url, so we can re-resolve without adding to the final templateBaseUrl
        rlc.links.templateBaseUrl = rlc.links.originalTemplateBaseUrl + '/' +
            templatePath.country + '/' +
            templatePath.language;
    }

    if (calEvent) {
        calEvent.complete();
    }

};


var getCalendar = module.exports.getCalendar = function getCalendar(culture) {
    var calendar = Globalize.culture(culture).calendars.standard,
        months = calendar.months || {};

    return {
        months: {
            names: months.names && months.names.filter(function (elem) { if (elem) {return true; }}),
            namesAbbr:  months.namesAbbr && months.namesAbbr.filter(function (elem) { if (elem) {return true; }})
        },
        days: calendar.days,
        AM: calendar.AM,
        PM: calendar.PM,
        patterns: calendar.patterns
    };
};

var formatter = module.exports.formatter = function formatter(country, culture) {

    var cow,
        currencySymbol;

    country = country || 'US';
    cow = resolver.cowFactory.getCow(country);
    culture = culture || DialectResolver.getDefaultLanguage(cow);

    //In case culture is actually locale
    //Converting locale to JQuery globalize culture
    if (culture.indexOf('_') !== -1) {
        culture = culture.split('_')[0] + '-' + country;
    }

    currencySymbol = (function () {
        var currencyCode = cow.getCurrencyCode(),
            currencyObj = currencies[currencyCode],
            currencySymbol;

        if (currencyObj) {
            currencySymbol = currencyObj.symbol;
        }
        return currencySymbol;
    }());

    return  {
        format : function (value, format) {
            if (format === 'C' || format === 'c') {
                return this.formatCurrency(value);
            } else if (['d', 'D', 't', 'T', 'f', 'F', 'M', 'Y'].indexOf(format) !== -1) {
                return this.formatDate(value, format);
            } else {
                return Globalize.format(value, format, culture);
            }

        },
        getCulture : function () {
            return culture;
        },
        formatDate: function (value, format) {
            var patternObj = patterns[culture];
            if (patternObj && patternObj.date && patternObj.date[format]) {
                format = patternObj.date[format];
            }
            return Globalize.format(value, format, culture);
        },
        formatCurrency : function (value, currency) {
            var symbol,
                patternObj,
                currencyObj;

            patternObj = patterns[culture];
            if (patternObj && patternObj.currency) {
                Globalize.addCultureInfo(culture, {
                    numberFormat: {
                        currency : {
                            pattern: patternObj.currency
                        }
                    }
                });
            }

            if (currency) {
                /*
                    convert currency to symbol
                    i.e. USD to $
                */
                currencyObj = currencies[currency];
                if (currencyObj) {
                    symbol = currencyObj.symbol;
                }
            }
            symbol = symbol || currencySymbol;
            if (symbol) {
                Globalize.addCultureInfo(culture, {
                    numberFormat: {
                        currency : {
                            symbol : symbol
                        }
                    }
                });
            }
            return Globalize.format(value, 'c', culture);
        },
        parseInt : function (value, radix) {
            radix = radix || 10;
            return Globalize.parseInt(value, radix, culture);
        },
        parseFloat : function (value, radix) {
            radix = radix || 10;
            return Globalize.parseFloat(value, radix, culture);
        },
        parseDate : function (value, format) {
            return Globalize.parseDate(value, format, culture);
        },
        getCalendar : function () {
            return getCalendar(culture);
        }
    };
};

/*
 * Take the currencyCode and returns currencySymbol
 */
module.exports.getCurrencySymbol = function getCurrencySymbol(currencyCode) {

    var currencyObj = currencies[currencyCode],
        symbol = '$';

    if (currencyObj) {
        symbol = currencyObj.symbol;
    }

    return symbol;
};



/* -----------------------------------------

    DEPRECATED: should register determiner order in app.json
 */

function findDeterminerIndex(determiners, name) {

    for (var i = 0; i < determiners.length; i++) {
        if (determiners[i] === name) {
            return i;
        }
    }

    throw 'Determiner: "' + name + '" not found';
}

function addDeterminer(resolver) {
    var priority = resolver.prototype.priority;
    var determiners = resolver.prototype.determiners;

    return {

        first: function (determiner) {
            determiners[determiner.name] = determiner;

            priority.unshift(determiner.name);
        },

        last: function (determiner) {
            determiners[determiner.name] = determiner;

            priority.push(determiner.name);
        },

        after: function (name, determiner) {
            determiners[determiner.name] = determiner;

            var index = findDeterminerIndex(priority, name);
            priority.splice(index + 1, 0, determiner.name);
        },

        before: function (name, determiner) {
            determiners[determiner.name] = determiner;

            var index = findDeterminerIndex(priority, name);
            priority.splice(index, 0, determiner.name);
        }
    };
}

function removeDeterminer(resolver) {
    var priority = resolver.prototype.priority;

    return function (name) {
        var index = findDeterminerIndex(priority, name);
        priority.splice(index, 1);
    };
}


module.exports.registerDeterminer = {

    country:  addDeterminer(CountryResolver),
    dialect:  addDeterminer(DialectResolver),
    timeZone: addDeterminer(TimeZoneResolver)
};

module.exports.removeDeterminer = {

    country:  removeDeterminer(CountryResolver),
    dialect:  removeDeterminer(DialectResolver),
    timeZone: removeDeterminer(TimeZoneResolver)
};


/* ----------------------------------------- */



module.exports.registerCountryDeterminer = function (name, determiner) {
    CountryResolver.prototype.determiners[name] = determiner;
};

module.exports.registerDialectDeterminer = function (name, determiner) {
    DialectResolver.prototype.determiners[name] = determiner;
};

module.exports.registerTimeZoneDeterminer = function (name, determiner) {
    TimeZoneResolver.prototype.determiners[name] = determiner;
};



module.exports.currencies = currencies;
