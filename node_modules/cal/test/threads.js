'use strict';

var assert = require('assert'),
    EventEmitter = require('events').EventEmitter,
    Config = require('./fixtures/config'),
    threads = require('../lib/threads'),
    cal = require('../lib');

describe('threads', function () {

    before(function () {
        threads.resetThreadIdPool();
        cal.defaults.writeStream = process.stdout;
        cal.setDefaultWriteStream('console', {
            environment: '',
            poolname: Config.calPool
        });
        cal.defaults.formatter = cal.formatter.silent;

        cal.once('error', function (err) {
            throw err;
        });
    });

    after(function (next) {
        this.timeout(10000);
        cal.stop(next);
    });

    it('should release thread id in 150 msec by default', function (done) {
        cal.middleware({
            enableBuffering: false,
            enableNestedCal: true
        })(new EventEmitter(), new EventEmitter(), function () {

            var id1 = threads.getNextThreadId();
            threads.releaseThreadId(id1);

            setTimeout(function () {
                assert.equal(id1, threads.getNextThreadId());
                done();
            }, 500);

        });
    });

    it('should not have nested cal events enabled', function (done) {
        cal.middleware({
        })(new EventEmitter(), new EventEmitter(), function () {
            var id1 = threads.getNextThreadId();
            // also verify it is in sync with cal buffer flush delay
            var evt = cal.createEvent();
            var calBuffer = evt.getCalBuffer();
            assert.equal(undefined, calBuffer.flushDelayInterval);
            assert.ok(!evt._isNestedCalEvents);
            assert.ok(!evt._isBufferingEnabled);
            assert.ok(evt.threadId, id1);

            done();
        });
    });

    it('should not release threadId in 10 msec by default', function (done) {
        cal.middleware({
            enableNestedCal: true
        })(new EventEmitter(), new EventEmitter(), function () {

            var id1 = threads.getNextThreadId();
            // also verify it is in sync with cal buffer flush delay
            var evt = cal.createEvent();
            var calBuffer = evt.getCalBuffer();
            assert.equal(0, calBuffer.flushDelayInterval);
            assert.ok(evt._isNestedCalEvents);
            assert.ok(evt.threadId, id1);
            threads.releaseThreadId(id1);

            setTimeout(function () {
                assert.ok(id1 !== threads.getNextThreadId());
                done();
            }, 10);

        });
    });

    it('should release thread id in 400 msec', function (done) {
        cal.middleware({
            enableBuffering: false,
            bufferFlushDelay: 400
        })(new EventEmitter(), new EventEmitter(), function () {

            var id1 = threads.getNextThreadId();
            // also verify it is in sync with cal buffer flush delay
            var calBuffer = cal.createEvent().getCalBuffer();
            threads.releaseThreadId(id1);

            setTimeout(function () {
                assert.ok(id1 !== threads.getNextThreadId());
                done();
            }, 200);

            setTimeout(function () {
                assert.equal(id1, threads.getNextThreadId());
                done();
            }, 410);
        });
    });
});
