'use strict';

var assert = require('assert'),
    cal = require('../lib'),
    Config = require('./fixtures/config'),
    calMockServer = require('./fixtures/mockcalserver'),
    listener = require('./fixtures/listener'),
    EventEmitter = require('events').EventEmitter,
    CalTestUtils = require('./fixtures/caltestutils');

var caltestutils = new CalTestUtils(cal, null, calMockServer),
    TIMEOUT = 3 * CalTestUtils.TIMEOUT;

describe.skip('cal mock server', function () {

    before(function (next) {
        cal.setDefaultWriteStream('cal', {
            poolname: Config.calPool,
            environment: '',
            host: '127.0.0.1',
            port: 1200
        });
        cal.defaults.formatter = cal.formatter.cal;

        calMockServer.listen(1200, next);
    });


    after(function (next) {
        this.timeout(10000);
        cal.stop(function () {
            setTimeout(function () {
                calMockServer.clearLocalCache();
                calMockServer.stopServer();
                next();
            }, 1000);
        });
    });

    beforeEach(function (next) {
        cal.middleware()(new EventEmitter(), new EventEmitter(), next);
    });

    describe('http request structure', function () {

        it.skip('should not lose events due to disconnect', function (next) {
            var createSocket = cal.defaults.writeStream._createSocket;
            var emitter = new EventEmitter();
            var socket;
            cal.defaults.writeStream._createSocket = function () {
                socket = createSocket.apply(cal.defaults.writeStream, arguments);
                emitter.emit('socket', socket);
                return socket;
            };
            cal.defaults.writeStream._createSocket.oldFunc = createSocket;
            cal.setThreadId(400);

            var triggered = 0;
            emitter.on('socket', function () {
                setTimeout(function () {
                    if (!triggered) {
                        triggered = true;
                        calMockServer.dropConnection();
                    }
                }, 30);
            });

            var count = 1000;
            var event;
            function genEvent() {
                event = cal.createEvent('test', 'name');
                event.addData('number', count);
                event.complete();
            }
            while (count) {
                count -= 1;
                process.nextTick(genEvent);
            }
            process.nextTick(function () {

                event = cal.createEvent('test-fin', 'name-fin');
                event.complete();
                listener.waitForMessage(cal.logger, event, function () {
                    setTimeout(function () {
                        var events = calMockServer.getDataByEventId(400, 'all');
                        try {
                            assert.equal(1000, events.length); // one chunk is lost
                            next();
                        }
                        catch (err) {
                            next(err);
                        }
                    }, 1000);
                });
            });

        });

        it('should record a URL transaction with some events and Async transaction', function (next) {
            this.timeout(TIMEOUT);
            caltestutils.tranx_mock(100, null, function () {
                next();
            });
        });

        it('should record a URL transaction with buffering', function (next) {
            this.timeout(TIMEOUT);
            caltestutils.tranx_mock(200, 'new_name', function () {
                next();
            });
        });

        it('should record a URL transaction with tons of events without buffering', function (next) {
            this.timeout(TIMEOUT);
            caltestutils.tranLoadx_mock(300, null, function () {
                next();
            });
        });

        it('should record a URL transaction with tons of events with buffering', function (next) {
            this.timeout(TIMEOUT);
            caltestutils.tranLoadx_mock(300, 'sk__sk', function () {
                next();
            });
        });

        it('should record few URL transactions in series|buffering|different threadIds ', function (next) {
            this.timeout(TIMEOUT);
            var identifier = 'series|buffering|different threadId';
            caltestutils.looper_mock('timesSeries', true, true, identifier, next);
        });

        it('should record few URL transactions in series|buffering|same threadId', function (next) {
            this.timeout(TIMEOUT);
            var identifier = 'series|buffering|same threadId';
            caltestutils.looper_mock('timesSeries', false, true, identifier, next);
        });

        it('should record few URL transactions in series|no buffering|different threadIds', function (next) {
            this.timeout(TIMEOUT);
            var identifier = 'series|no buffering|different threadIds';
            caltestutils.looper_mock('timesSeries', true, false, identifier, next);
        });

        it('should record few URL transactions in series|no buffering|same threadId', function (next) {
            this.timeout(TIMEOUT);
            var identifier = 'series|no buffering|same threadId';
            caltestutils.looper_mock('timesSeries', false, false, identifier, next);
        });

        it('should record few URL transactions in parallel|buffering|different threadId', function (next) {
            this.timeout(TIMEOUT);
            var identifier = 'parallel|buffering|different threadId';
            caltestutils.looper_mock('times', true, true, identifier, next);
        });

        it('should record few URL transactions in parallel|no buffering|different threadId', function (next) {
            this.timeout(TIMEOUT);
            var identifier = 'parallel|no buffering|different threadId';
            caltestutils.looper_mock('times', true, false, identifier, next);
        });

    });
});
