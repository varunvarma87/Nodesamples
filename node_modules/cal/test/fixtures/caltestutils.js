'use strict';

/*eslint handle-callback-err:0, no-shadow:0 */

var assert = require('assert'),
    async = require('async'),
    mockData = require('./mockpayload'),
    EventEmitter = require('events').EventEmitter;

var cal,
    nconf,
    calMockServer;

var TIMEOUT = 60000,
    LOOP_EVENT_CNT = 100,
    LOOP_CNT = 10;

/**
 * Utility with different cal root URL transactions
 */
var CalTestUtils = module.exports = function CalTestUtils(calInstance, nconfInstance, calMockServerInstance) {
    cal = calInstance;
    nconf = nconfInstance;
    calMockServer = calMockServerInstance;
};

CalTestUtils.prototype = {
    tranx: function tranx(threadId, newRoottxnName, callback) {
        cal.setThreadId(threadId);

        cal.setEnableBuffering(!!newRoottxnName);

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);

        cal.createTransaction('URL', 'samplepage_' + correlationId, function (err, urlTransaction) {

            urlTransaction.flush();
            urlTransaction.correlationId = correlationId;
            urlTransaction.addData('foo', 'bar');

            cal.createEvent('success-type1', 'success-name1', '0').complete();

            setImmediate(function () {
                cal.createEvent('success-type2', 'success-name2', '0').complete();
            });

            setTimeout(function () {
                cal.createEvent('fatal-type', 'fatal-name', '1').complete();
            }, 3);

            setTimeout(function () {
                cal.createEvent('error-type', 'error-name', '2')
                    .addData('error', new Error('some error'))
                    .complete();
            }, 5);

            setTimeout(function () {
                cal.createEvent('exception-type', 'exception-name', '3').complete();
            }, 8);

            setTimeout(function () {
                // nested transaction
                cal.createTransaction('nested', 'nested', function (err, child) {
                    child.addData('child.foo', 'child.bar');

                    cal.createEvent('child.error-type', 'child.error-name', '2').complete();
                    cal.createEvent('child.success-type2', 'child.success-name2', '0').complete();

                    cal.createTransaction('nested2', 'nested2', function (err, child2) {
                        child2.addData('child2.foo', 'child2.bar');

                        cal.createEvent('child2.success-type', 'child2.success-name', '0').complete();

                        child2.complete();
                        setTimeout(function () {
                            child.complete();
                        }, 30);
                    });

                });
            }, 20);

            setTimeout(function () {
                cal.createEvent('warning-type', 'warning-name', '4').complete();
                cal.createTransaction('atomic', 'name', function (err, atomicTxn) {
                    setTimeout(function () {
                        atomicTxn.complete();
                    }, 30);
                });
            }, 80);

            setTimeout(function () {
                if (newRoottxnName) {
                    urlTransaction.name = newRoottxnName;
                }
                urlTransaction.complete();
                callback();
            }, 150);
        });

    },

    tranLoadx: function tranLoadx(threadId, newRoottxnName, identifier, callback) {
        cal.setThreadId(threadId);

        cal.setEnableBuffering(!!newRoottxnName);

        tranLoadx.counter = tranLoadx.counter || 0;
        var index = tranLoadx.counter++;

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);
        var i;

        cal.createTransaction('URL', 'sample_load_page_' + correlationId + '_' + index, function (err, urlTransaction) {

            urlTransaction.flush();

            urlTransaction.correlationId = correlationId;
            urlTransaction.addData('foo', 'bar');
            urlTransaction.addData('identifier', identifier);

            for (i = 0; i < LOOP_EVENT_CNT; i++) {
                cal.createEvent('TYPE' + i, 'name.' + i, '0')
                   .addData(mockData.payload)
                   .complete();
            }

            function end() {
                setTimeout(function () {
                    if (newRoottxnName) {
                        urlTransaction.name = newRoottxnName + '_' + index;
                    }
                    urlTransaction.complete();
                    callback();
                }, 300);
            }

            setTimeout(function () {
                for (i = 0; i < LOOP_EVENT_CNT; i++) {
                    cal.createEvent('TYPE_' + i, 'name__' + i, '0').addData(mockData.payload1).complete();
                }
                end();
            }, 200);
        });

    },

    transAll: function transAll(threadId, newRoottxnName, identifier, callback) {
        cal.setThreadId(threadId);

        cal.setEnableBuffering(!!newRoottxnName);

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);

        cal.createTransaction('URL', 'samplepage_' + correlationId, function (err, urlTransaction) {

            urlTransaction.flush();

            urlTransaction.correlationId = correlationId;
            urlTransaction.addData('foo', 'bar');

            cal.createEvent('success-type1', 'success-name1', '0').addData(identifier).complete();
            setTimeout(function () {
                cal.createEvent('success-type2', 'success-name2', '0').addData(identifier).complete();
                cal.createTransaction('atomic', 'name', function (err, atomicTxn) {
                    atomicTxn.addData(identifier);

                    setTimeout(function () {
                        atomicTxn.complete();
                    }, 100);
                });
            }, 10);

            setTimeout(function () {
                cal.createEvent('success-type3', 'success-name3', '0').addData(identifier).complete();
            }, 80);

            setTimeout(function () {
                if (newRoottxnName) {
                    urlTransaction.name = newRoottxnName;
                }
                urlTransaction.addData(identifier);
                urlTransaction.complete();
                callback();
            }, 300);
        });

    },

    looperBase: function (looperfn, autothreadId, updateName, identifier, txnFn, callback) {
        var threadId = (identifier && identifier.length) || 10 + 1000,
            newName;

        var callTranx = function (n, cb) {
            cal.middleware()(new EventEmitter(), new EventEmitter(), function (err) {
                if (autothreadId) {
                    threadId++;
                }
                if (updateName) {
                    newName = 'test_name' + threadId;
                }
                txnFn(threadId, newName, threadId + '|' + identifier,
                    looperfn === 'timesSeries' ? setTimeout.bind(null, cb, 200) : cb);
            });
        };

        async[looperfn](LOOP_CNT, callTranx,
        function () {
            setTimeout(function () {
                callback();
            }, 300);
        });
    },

    looper: function (looperfn, autothreadId, updateName, identifier, callback) {
        this.looperBase(looperfn, autothreadId, updateName, identifier, this.transAll, callback);
    },

    loadLooperBase: function (looperfn, autothreadId, updateName, identifier, txnFn, callback) {
        var threadId = (identifier && identifier.length) || 10 + 1000,
            newName;

        var callTranLoadx = function (n, cb) {
            cal.middleware()(new EventEmitter(), new EventEmitter(), function (err) {
                if (autothreadId) {
                    threadId++;
                }
                if (updateName) {
                    newName = 'test_load_name' + threadId;
                }
                txnFn(threadId, newName, threadId + '|' + identifier, looperfn === 'timesSeries' ? setTimeout.bind(null, cb, 200) : cb);
            });
        };

        async[looperfn](LOOP_CNT, callTranLoadx,
        function () {
            setTimeout(function () {
                callback();
            }, 300);
        });
    },

    loadLooper: function (looperfn, autothreadId, updateName, identifier, callback) {
        this.loadLooperBase(looperfn, autothreadId, updateName, identifier, this.tranLoadx, callback);
    },

    tranx_4x: function tranx_4x(threadId, newRoottxnName, callback) {
        cal.setThreadId(threadId);
        cal.setEnableNestedCal(true);

        if (nconf) {
            nconf.set('cal:enableBuffering', !!newRoottxnName);
        }

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);
        var atomicTxn;

        var urlTransaction = cal.createTransaction('URL', 'samplepage_' + correlationId);
        urlTransaction.flush();

        urlTransaction.correlationId = correlationId;
        urlTransaction.addData('foo', 'bar');

        cal.createEvent('success-type1', 'success-name1', '0').complete();

        setTimeout(function () {
            cal.createEvent('success-type2', 'success-name2', '0').complete();
        }, 3);

        setTimeout(function () {
            cal.createEvent('fatal-type', 'fatal-name', '1').complete();
        }, 5);

        setTimeout(function () {
            cal.createEvent('error-type', 'error-name', '2').complete();
        }, 8);

        setTimeout(function () {
            cal.createEvent('exception-type', 'exception-name', '3').complete();
        }, 10);

        setTimeout(function () {
            cal.createEvent('warning-type', 'warning-name', '4').complete();
            atomicTxn = cal.createTransaction('atomic', 'name');
        }, 15);

        setTimeout(function () {
            atomicTxn.complete();
        }, 40);

        setTimeout(function () {
            if (newRoottxnName) {
                urlTransaction.name = newRoottxnName;
            }
            urlTransaction.complete();
            callback();
        }, 100);
    },

    tranLoadx_4x: function tranLoadx_4x(threadId, newRoottxnName, identifier, callback) {
        cal.setThreadId(threadId);
        cal.setEnableNestedCal(true);

        if (nconf) {
            nconf.set('cal:enableBuffering', !!newRoottxnName);
        }

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);
        var atomicTxn, i;

        var urlTransaction = cal.createTransaction('URL', 'sample_load_page_' + correlationId);
        urlTransaction.flush();
        var startTime = urlTransaction.timestamp;

        urlTransaction.correlationId = correlationId;
        urlTransaction.addData('foo', 'bar');
        urlTransaction.addData('identifier', identifier);

        for (i = 0; i < LOOP_EVENT_CNT; i++) {
            cal.createEvent('TYPE' + i, 'name.' + i, '0')
               .addData(mockData.payload)
               .complete();
        }

        setTimeout(function () {
            for (i = 0; i < LOOP_EVENT_CNT; i++) {
                cal.createEvent('TYPE_' + i, 'name__' + i, '0').addData(mockData.payload1).complete();
            }
        }, 100);

        setTimeout(function () {
            if (newRoottxnName) {
                urlTransaction.name = newRoottxnName;
            }
            urlTransaction.complete();
            callback();
        }, 600);
    },

    transAll_4x: function transAll_4x(threadId, newRoottxnName, identifier, callback) {
        cal.setThreadId(threadId);
        cal.setEnableNestedCal(true);

        if (nconf) {
            nconf.set('cal:enableBuffering', !!newRoottxnName);
        }

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);
        var atomicTxn;

        var urlTransaction = cal.createTransaction('URL', 'samplepage_' + correlationId);
        urlTransaction.flush();

        urlTransaction.correlationId = correlationId;
        urlTransaction.addData('foo', 'bar');

        cal.createEvent('success-type1', 'success-name1', '0').addData(identifier).complete();
        setTimeout(function () {
            cal.createEvent('success-type2', 'success-name2', '0').addData(identifier).complete();
            atomicTxn = cal.createTransaction('atomic', 'name');
            atomicTxn.addData(identifier);
        }, 3);

        setTimeout(function () {
            cal.createEvent('success-type3', 'success-name3', '0').addData(identifier).complete();
        }, 5);

        setTimeout(function () {
            atomicTxn.complete();
        }, 100);

        setTimeout(function () {
            if (newRoottxnName) {
                urlTransaction.name = newRoottxnName;
            }
            urlTransaction.addData(identifier);
            urlTransaction.complete();
            callback();
        }, 300);
    },

    looper_4x: function (looperfn, autothreadId, updateName, identifier, callback) {
        var threadId = (identifier && identifier.length) || 10 + 1000,
            newName;

        var callTranx = function (n, cb) {
            if (autothreadId) {
                threadId++;
            }
            if (updateName) {
                newName = 'test_name' + threadId;
            }
            this.transAll_4x(threadId, newName, threadId + '|' + identifier, cb);
        }.bind(this);

        async[looperfn](LOOP_CNT, callTranx,
        function () {
            setTimeout(function () {
                callback();
            }, 1000);
        });
    },

    loadLooper_4x: function (looperfn, autothreadId, updateName, identifier, callback) {
        var threadId = (identifier && identifier.length) || 10 + 1000,
            newName;

        var callTranLoadx = function (n, cb) {
            if (autothreadId) {
                threadId++;
            }
            if (updateName) {
                newName = 'test_load_name' + threadId;
            }
            this.tranLoadx_4x(threadId, newName, threadId + '|' + identifier, cb);
        }.bind(this);

        async[looperfn](LOOP_CNT, callTranLoadx,
        function () {
            setTimeout(function () {
                callback();
            }, 1000);
        });
    },

    tranx_mock: function tranx_mock(threadId, newRoottxnName, callback) {
        cal.setThreadId(threadId);
        cal.setEnableNestedCal(true);
        cal.setEnableBuffering(!!newRoottxnName);

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);

        cal.createTransaction('URL', 'samplepage_' + correlationId, function (err, urlTransaction) {
            if (err) {
                return callback(err);
            }

            urlTransaction.flush();

            urlTransaction.correlationId = correlationId;
            urlTransaction.addData('foo', 'bar');

            cal.createEvent('success-type1', 'success-name1', '0').complete();
            cal.createEvent('success-type2', 'success-name2', '0').complete();
            cal.createEvent('fatal-type', 'fatal-name', '1').complete();

            setTimeout(function () {
                cal.createEvent('error-type', 'error-name', '2').complete();
            }, 1);

            setTimeout(function () {
                cal.createEvent('exception-type', 'exception-name', '3').complete();
            }, 5);

            setTimeout(function () {
                cal.createEvent('warning-type', 'warning-name', '4').complete();
                cal.createTransaction('atomic', 'name', function (err, atomicTxn) {
                    setTimeout(function () {
                        atomicTxn.complete();
                    }, 50);
                });
            }, 30);

            setTimeout(function () {
                if (newRoottxnName) {
                    urlTransaction.name = newRoottxnName;
                }
                urlTransaction.complete();
                setTimeout(function () {
                    var tx = calMockServer.getDataByEventId(threadId, urlTransaction.parentEventId);
                    assert.ok(tx);
                    assert.equal(0, urlTransaction.parentEventId);

                    assert.ok(tx[0].msg);
                    assert.equal('t', tx[0].msg.charAt(0));
                    assert.equal(threadId, tx[0].t);
                    assert.equal(0, tx[0].p);
                    assert.equal(1, tx[0].e);

                    var childEvents = calMockServer.getDataByEventId(threadId, urlTransaction.eventId);
                    assert.ok(childEvents);
                    assert.equal(childEvents.length, 7);  //7 child events being fired here.

                    assert.equal(threadId, childEvents[0].t);
                    assert.equal(1, childEvents[0].p);
                    assert.equal(2, childEvents[0].e);

                    assert.equal(1, childEvents[5].p);
                    assert.equal(7, childEvents[5].e);
                    assert.equal(threadId, childEvents[5].t);
                    assert.equal(7, childEvents.length);

                    assert.equal(0, tx[1].p);
                    assert.equal(1, tx[1].e);
                    assert.equal(threadId, tx[1].t);
                    assert.equal('T', tx[tx.length - 1].msg.charAt(0));
                    calMockServer.clearThreadId(threadId);
                    callback();
                }, 1000);
            }, 100);
        });
    },

    tranLoadx_mock: function tranLoadx_mock(threadId, newRoottxnName, callback) {
        cal.setThreadId(threadId);
        cal.setEnableNestedCal(true);
        cal.setEnableBuffering(!!newRoottxnName);

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);
        var i, CNTR = 1000;

        cal.createTransaction('URL', 'sample_load_page_' + correlationId, function (err, urlTransaction) {

            urlTransaction.flush();

            urlTransaction.correlationId = correlationId;
            urlTransaction.addData('foo', 'bar');

            for (i = 0; i < CNTR; i++) {
                cal.createEvent('TYPE' + i, 'name.' + i, '0').addData(process.env).complete();
            }

            setTimeout(function () {
                if (newRoottxnName) {
                    urlTransaction.name = newRoottxnName;
                }

                setTimeout(function () {
                    var tx = calMockServer.getDataByEventId(threadId, urlTransaction.parentEventId);
                    assert.ok(tx);
                    assert.equal(2, tx.length);
                    var childEvents = calMockServer.getDataByEventId(threadId, urlTransaction.eventId);
                    assert.ok(childEvents);
                    assert.equal(childEvents.length, CNTR);  //CNTR + 2 events being fired here.
                    assert.ok(tx[0].msg);
                    assert.ok(tx[0].msg.charAt(0) === 't');
                    assert.ok(childEvents[0].p === 1);
                    assert.ok(tx[1].msg.charAt(0) === 'T');
                    calMockServer.clearThreadId(threadId);
                    callback();
                }, 1000);
                urlTransaction.complete();
            }, 500);
        });
    },

    transAll_mock: function transAll_mock(threadId, newRoottxnName, identifier, callback) {
        cal.setThreadId(threadId);

        cal.setEnableNestedCal(true);
        cal.setEnableBuffering(!!newRoottxnName);

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);

        cal.createTransaction('URL', 'samplepage_' + correlationId, function (err, urlTransaction) {

            urlTransaction.flush();

            urlTransaction.correlationId = correlationId;
            urlTransaction.addData('foo', 'bar');

            cal.createEvent('success-type1', 'success-name1', '0').addData(mockData.payload).complete();
            setTimeout(function () {
                cal.createEvent('success-type2', 'success-name2', '0').addData(identifier).complete();
                cal.createTransaction('atomic', 'name', function (err, atomicTxn) {
                    atomicTxn.addData(identifier);
                    setTimeout(function () {
                        atomicTxn.complete();
                    }, 100);
                });
            }, 10);

            setTimeout(function () {
                cal.createEvent('success-type3', 'success-name3', '0').addData(mockData.payload1).complete();
            }, 100);

            setTimeout(function () {
                if (newRoottxnName) {
                    urlTransaction.name = newRoottxnName;
                }
                urlTransaction.addData(identifier);
                urlTransaction.complete();
                setTimeout(function () {
                    var tx = calMockServer.getDataByEventId(threadId, urlTransaction.parentEventId);
                    assert.ok(tx);
                    assert.equal(2, tx.length);
                    var childEvents = calMockServer.getDataByEventId(threadId, urlTransaction.eventId);
                    assert.ok(childEvents);
                    assert.equal(4, childEvents.length, ', THREAD: ' + threadId);  //4 events being fired here.
                    assert.ok(tx[0].msg);
                    assert.ok(tx[0].msg.charAt(0) === 't');
                    assert.ok(tx[1].msg.charAt(0) === 'T');
                    calMockServer.clearThreadId(threadId);
                    callback();
                }, 1000);
            }, 300);
        });
    },

    looper_mock: function (looperfn, autothreadId, updateName, identifier, callback) {
        this.looperBase(looperfn, autothreadId, updateName, identifier, this.transAll_mock, callback);
    },

    trans_long_mock: function (newRoottxnName, threadId, callback) {
        cal.setThreadId(threadId);
        cal.setEnableNestedCal(true);

        cal.setEnableBuffering(!!newRoottxnName);

        var correlationId = Math.floor(Math.random() * (0xcafebabe - 0xfafe) + 0xfafe);
        var i, CNTR = 8000;

        cal.createTransaction('URL', 'sample_long_load_page_' + correlationId, function (err, urlTransaction) {

            urlTransaction.flush();

            urlTransaction.correlationId = correlationId;
            urlTransaction.addData('foo', 'bar');

            for (i = 0; i < CNTR; i++) {
                cal.createEvent('TYPE' + i, 'name.' + i, '0').addData(mockData.payload).complete();
            }

            cal.createTransaction('atomic', 'name', function (err, atomicTxn) {
                atomicTxn.addData(mockData.payload);
                setTimeout(function () {
                    atomicTxn.complete();
                }, 40);
            });

            setTimeout(function () {
                if (newRoottxnName) {
                    urlTransaction.name = newRoottxnName;
                }

                for (i = 0; i < CNTR; i++) {
                    cal.createEvent('TYPE-' + i, 'name.' + i, '0').addData(mockData.payload1).complete();
                }
                urlTransaction.complete();
                if (callback) {
                    callback(urlTransaction);
                }
            }, 500);
        });
    },

    transAll_long_mock: function transAll_long_mock(newRoottxnName, delayCheck, callback) {
        /*eslint no-unused-vars:0 */
        var threadId = 1900,
            threadIdNew = 2000;

        var urlTransaction,
            that = this;

        cal.middleware()(new EventEmitter(), new EventEmitter(), function () {
            that.trans_long_mock(newRoottxnName, threadId, function (urlTxn) {
                urlTransaction = urlTxn;
            });
        });

        var intervalTimer = setInterval(function () {
                threadIdNew++;
                cal.middleware()(new EventEmitter(), new EventEmitter(), function () {
                    that.trans_long_mock(newRoottxnName, threadIdNew);
                });
            }, delayCheck * 0.2);

        setTimeout(function () {
            clearTimeout(intervalTimer);
            var data = calMockServer.getDataByThreadId(threadId);
            assert.ok(data);
            var tx = data.all;
            assert.equal(2, tx.length);

            calMockServer.clearLocalCache();
            callback();
        }, delayCheck);
    }
};

module.exports.TIMEOUT = TIMEOUT;
module.exports.LOOP_CNT = LOOP_CNT;
module.exports.LOOP_EVENT_CNT = LOOP_EVENT_CNT;
