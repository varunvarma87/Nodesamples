'use strict';

var net = require('net');

var debug = require('debug')('mockcal'),
    debugQueue = require('debug')('cal:mock:dropconnection');

var calMockServer = module.exports = {};

calMockServer.localCache = {};

calMockServer.listen = function (port, fn) {
    var self = this;

    calMockServer.server = net.createServer(function (c) {

        var chunkChunk;
        debug('calMockServer connected');
        c.on('end', function () {
            debug('calMockServer disconnected');
        });
        c.on('data', function (chunk) {
            debug('data size', chunk.length);
            if (chunkChunk) {
                debug('carry forward chunk size', chunkChunk.length);
                chunk = Buffer.concat([chunkChunk, chunk]);
                chunkChunk = null;
                debug('new data size', chunk.length);
            }
            var pos = 0,
                oPos;
            var threadId,
                parentEventId,
                eventId,
                bodyLength,
                message;
            do {
                if (chunk.length >= pos + 12) {
                    threadId = chunk.readUInt32BE(pos);
                    parentEventId = chunk.readUInt16BE(pos + 4);
                    eventId = chunk.readUInt16BE(pos + 6);
                    bodyLength = chunk.readUInt32BE(pos + 8);
                    message = chunk.toString('utf8', pos + 12, pos + bodyLength + 12).replace(/\r\n$/, '');
                } else {
                    bodyLength = 0;
                }
                oPos = pos;
                pos += bodyLength + 12;

                if (pos > chunk.length) {
                    chunkChunk = new Buffer(chunk.length - oPos);
                    chunk.copy(chunkChunk, 0, oPos);
                    break;
                }

                var tcache = calMockServer.localCache[threadId] = calMockServer.localCache[threadId] || {};
                var cache = tcache[parentEventId] = tcache[parentEventId] || [];
                var entry = {t: threadId, 'e': eventId, 'p': parentEventId, 'len': bodyLength, 'msg': message};
                cache.push(entry);
                tcache.all = tcache.all || [];
                tcache.all.push(entry);
                debug('#', threadId, ', e#', eventId, ', p#', parentEventId, ': ',
                    'chunk[', pos + 12, '-', pos + 12 + bodyLength, '] = ',
                    message);
            } while (pos < chunk.length);
        });
    });
    calMockServer.server.on('connection', function (socket) {
        self._socket = socket;
    });

    calMockServer.server.listen(port, fn);
    return calMockServer.server;
};

calMockServer.dropConnection = function () {
    if (this._socket) {
        debugQueue('dropping connection');
        this._socket.destroy();
    }
};

calMockServer.stopServer = function () {
    if (calMockServer.server) {
        calMockServer.server.close();
    }
};

calMockServer.clearLocalCache = function () {
    calMockServer.localCache = {};
};

calMockServer.clearThreadId = function (threadId) {
    delete calMockServer.localCache[threadId];
};

calMockServer.getDataByEventId = function (threadId, eventId) {
    return calMockServer.localCache[threadId] && calMockServer.localCache[threadId][eventId];
};

calMockServer.getDataByThreadId = function (threadId) {
    return calMockServer.localCache[threadId];
};

calMockServer.getLocalCache = function () {
    return calMockServer.localCache;
};
