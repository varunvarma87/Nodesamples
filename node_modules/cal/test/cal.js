'use strict';
/*eslint no-shadow:0, handle-callback-err:0 */

var assert = require('assert'),
    cal = require('../lib'),
    Config = require('./fixtures/config'),
    mockData = require('./fixtures/mockpayload'),
    MessageClass = require('../lib/constants').MessageClass,
    EventEmitter = require('events').EventEmitter;

//the two non-context should be first
var useCases = [
    // non context
    {
        title: 'cal, no context',
        host: Config.ppStageHost
    },
    // request context
    {
        title: 'cal, request context',
        host: Config.ppStageHost,
        ctx: true
    }
];

useCases.forEach(testSuite);

function testSuite(config) {
    describe(config.title, function () {

        before(function (next) {
            cal.setDefaultWriteStream('cal', {
                environment: config.environment,
                poolname: Config.calPool,
                host: config.host,
                port: Config.port
            });
            cal.defaults.formatter = cal.formatter.cal;

            next();
        });

        if (config.ctx) {
            beforeEach(function (next) {
                cal.middleware({
                    enableNestedCal: config.enableNestedCal
                })(new EventEmitter(), new EventEmitter(), function () {
                    cal.setThreadId(0xab);
                    next();
                });
            });
        }

        after(function (next) {
            this.timeout(10000);
            setTimeout(function () {
                cal.stop(function () {
                    cal.removeAllListeners('error');
                    next();
                });
            }, 3000);
        });

        describe('event', function () {

            it('should write a message and 2 strings', function () {
                var event = cal.createEvent('type', 'name');
                event.addData('foo', 'bar');
                event.addData('foo');
                event.addData('bar');
                event.complete();
            });

            it('should write a message and a string', function () {
                var event = cal.createEvent('type', 'name');
                event.addData('foo', 'bar');
                event.addData('foo');
                event.complete();
            });

            it('should write a string', function () {
                var event = cal.createEvent('type', 'name');
                event.addData('simple string, should print as it is');
                event.complete();
            });

            it('should serialize and write JSON message', function () {
                var event = cal.createEvent('type', 'name');
                var sampleJSON = {
                    foo: 'bar',
                    obj: {
                        a: 'a',
                        b: 'b',
                        c: 'c'
                    },
                    array: [
                        'item1',
                        'item2',
                        'item3'
                    ]
                };
                sampleJSON.circular = sampleJSON;
                sampleJSON.circularList = [sampleJSON, sampleJSON];
                event.addData(sampleJSON);
                event.complete();
            });

            it('should write Error object in message', function () {
                var event = cal.createEvent('type', 'name');
                event.addData('error', new Error('some error'));
                event.complete();
            });

            it('should sanitize invalid chars in type and name', function () {
                var event = cal.createEvent('\u2603a/b< >\t\u00f7$', '\u2603a/b< >\t\u00f7$');
                assert.equal(event.type, '_a_b_____$');
                assert.equal(event.name, '_a_b_____$');
                event.addData('foo', 'bar');
                event.complete();
            });

            it('set name should sanitize invalid chars in name', function () {
                var event = cal.createEvent('type', 'name');
                event.name = '\u2603a/b< >\t\u00f7$';
                assert.equal(event.name, '_a_b_____$');
                event.addData('foo', 'bar');
                event.complete();
            });

            it('set type should sanitize invalid chars in type', function () {
                var event = cal.createEvent('type', 'name');
                event.type = '\u2603a/b< >\t\u00f7$';
                assert.equal(event.type, '_a_b_____$');
                event.addData('foo', 'bar');
                event.complete();
            });

            it('Limit name to 127 chars max', function () {
                var event = cal.createEvent('type', 'abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789');
                assert.equal(event.name.length, 127);
                event.addData('foo', 'bar');
                event.complete();
            });

            it('Limit type to 127 chars max', function () {
                var event = cal.createEvent('abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz0123456789', 'name');
                assert.equal(event.type.length, 127);
                event.addData('foo', 'bar');
                event.complete();
            });

            it('verify only expected characters are sanitized', function () {
                var event = cal.createEvent('type', ' !"#$%&\'()*+,-./0123456789:;=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~');
                assert.equal(event.name, '_!_#$%&_()*+,-._0123456789:;=_?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~');
                event.addData('foo', 'bar');
                event.complete();
            });

            it('should handle many sync events', function () {
                this.timeout(5000);

                var count = 1000;
                var event;
                while (count) {
                    count -= 1;
                    event = cal.createEvent('test', 'name', undefined, mockData.payload1);
                    event.addData('number', count);
                    event.complete();
                }
            });


            it('should handle many async events', function () {
                var count = 1000;
                function log() {
                    cal.createEvent('test', 'name', undefined, mockData.payload2).complete();
                }

                while (count) {
                    count -= 1;
                    process.nextTick(log);
                    setImmediate(log);
                }
            });

            it('should not parse encoded string', function () {
                var event = cal.createEvent('tracking', 'a');
                event.addData(mockData.payload3);
                event.complete();
            });

            it('should not write data with known PII into CAL', function () {
                var event = cal.createEvent('type', 'name');
                event.addData('email', 'krakenjs@paypal.com');
                event.addData('password', 'paypal');
                event.addData('user', 'krakenjs');
                event.complete();
            });

            it('should write an event after a delay', function (next) {
                this.timeout(6000);
                setTimeout(function () {
                    cal.createEvent('test-type', 'test-name', '0').complete();
                    cal.createEvent('test-type2', 'test-name2', '0').complete();
                    next();
                }, 5000);
            });

            it.skip('should try to write an event after the connection times out', function (next) {
                this.timeout(21000);
                setTimeout(function () {
                    var event = cal.createEvent('timeout-type', 'test-name');
                    event.addData('should try to write an event after the connection times out');
                    event.complete();
                    next();
                }, 20000);
            });

        });


        describe('heartbeat', function () {

            it('should write a message', function () {
                var heartbeat = cal.createHeartbeat('type', 'name');
                heartbeat.addData('foo', 'bar');
                heartbeat.complete();
            });

            it('should sanitize invalid chars in name', function () {
                var heartbeat = cal.createHeartbeat('type', 'a/b< >\t\u00f7$');
                heartbeat.addData('foo', 'bar');
                heartbeat.complete();
            });

        });


        describe('transaction', function () {

            it('should record an atomic transaction', function (next) {
                cal.setThreadId(0xca1);

                cal.createTransaction('transaction', 'atomic', 0, function (err, transaction) {
                    transaction.correlationId = 0xca1;
                    transaction.addData('foo', 'bar');

                    // Transaction is ATOMIC unless flush is called.
                    assert.strictEqual(transaction.messageClass, MessageClass.ATOMIC);

                    transaction.complete();
                    // No flush, so should still be atomic
                    assert.strictEqual(transaction.messageClass, MessageClass.ATOMIC);
                    next();
                });
            });

            it('should record an atomic transaction and sanitize name', function (next) {
                cal.setThreadId(0xca2);
                cal.createTransaction('atomic_txn', 'a/b< >\t\u00f7$', '1.STATUS', function (err, transaction) {
                    transaction.correlationId = 0xca2;
                    transaction.addData('foo', 'bar');

                    // Transaction is ATOMIC unless flush is called.
                    assert.strictEqual(transaction.messageClass, MessageClass.ATOMIC);

                    setImmediate(function () {
                        transaction.complete();
                        // No flush, so should still be atomic
                        assert.strictEqual(transaction.messageClass, MessageClass.ATOMIC);
                        next();
                    });
                });
            });

            it('should record transaction start and end events', function (next) {
                cal.setThreadId(0xca3);
                cal.createTransaction('t_T_txn', 'name', '2.STATUS', function (err, transaction) {

                    transaction.correlationId = 0xca3;
                    transaction.addData('foo', 'bar');

                    setImmediate(function () {

                        // Transaction is ATOMIC unless flush is called.
                        assert.strictEqual(transaction.messageClass, MessageClass.ATOMIC);

                        transaction.flush();
                        // Flushed, so should've written TRANSACTION_START
                        assert.strictEqual(transaction.messageClass, MessageClass.TRANSACTION_END);
                        transaction.addData('baz', 'bam');

                        setImmediate(function () {
                            transaction.complete();

                            // MessageClass shouldn't have changed.
                            assert.strictEqual(transaction.messageClass, MessageClass.TRANSACTION_END);
                            next();
                        });
                    });
                });
            });


            it('should only honor only one flush event', function () {
                cal.setThreadId(0xca4);
                cal.createTransaction('one_flush', 'name', '3.STATUS', function (err, transaction) {

                    transaction.correlationId = 0;
                    transaction.addData('foo', 'bar');

                    // Transaction is ATOMIC unless flush is called.
                    assert.strictEqual(transaction.messageClass, MessageClass.ATOMIC);

                    transaction.flush();
                    transaction.flush();

                    var event = cal.createEvent('Error', 'Test Error', '1');
                    event.addData('error', new Error('Testing error'));
                    event.complete(1);

                    // Flushed, so should've written TRANSACTION_START
                    assert.strictEqual(transaction.messageClass, MessageClass.TRANSACTION_END);

                    transaction.complete();

                    // MessageClass shouldn't have changed.
                    assert.strictEqual(transaction.messageClass, MessageClass.TRANSACTION_END);
                });
            });


            it('should commit nested transactions', function () {
                cal.setThreadId(0xca5);
                cal.createTransaction('nested_txn', 'name', function (err, parent) {
                    parent.correlationId = 0xff;
                    parent.addData('parent-data', 'foo');
                    parent.flush();

                    parent.addData('parent-data', 'baz');

                    cal.createTransaction('child_txn', 'name', undefined, undefined, function (err, child) {
                        cal.createEvent('event', 'nested_event', '0').complete();
                        child.addData('child', 'bar');
                        child.complete();
                        parent.complete();
                    });
                });
            });

        });

        describe('http request structure', function () {

            it('old-style, no callback', function (next) {
                function createTx(next) {
                    var transaction = cal.createTransaction('URL', 'url-old-style', '1');
                    transaction.flush();

                    transaction.correlationId = 0xab;
                    transaction.addData('foo', 'bar');

                    var event = cal.createEvent('event1-old', 'name-old1', 4);
                    event.addData('object-old-style1', 'test1');
                    event.complete();

                    event = cal.createEvent('event2-old', 'name-old2', 4);
                    event.addData('object-old-style2', 'test2');
                    event.complete();

                    setTimeout(function () {
                        transaction.complete();
                        // No flush, so should still be atomic
                        assert.strictEqual(transaction.messageClass, MessageClass.TRANSACTION_END);
                        next();
                    }, 50);
                }

                createTx(function () {
                    // 2nd one
                    setTimeout(function () {
                        createTx(next);
                    }, 10);
                });
            });

            it('should record a URL transaction with some events and Async transaction', function (next) {

                cal.setThreadId(0xcafe);

                var correlationId = '0xcafebabe';

                cal.createTransaction('URL', 'samplepage', function (err, urlTransaction) {
                    assert.ok(!err, err && err.stack);
                    urlTransaction.flush();

                    urlTransaction.correlationId = correlationId;
                    urlTransaction.addData('foo', 'bar');

                    cal.createEvent('success-type1', 'success-name1', '0').complete();

                    setTimeout(function () {
                        cal.createEvent('success-type2', 'success-name2', '0').complete();
                    }, 10);

                    setTimeout(function () {
                        cal.createEvent('fatal-type', 'fatal-name', '1').complete();
                    }, 30);

                    setTimeout(function () {
                        cal.createEvent('error-type', 'error-name', '2').complete();
                    }, 50);

                    setTimeout(function () {
                        cal.createEvent('exception-type', 'exception-name', '3').complete();
                    }, 60);

                    setTimeout(function () {
                        cal.createEvent('warning-type', 'warning-name', '4').complete();
                        cal.createTransaction('atomic', 'name', function (err, atomicTxn) {
                            setTimeout(function () {
                                atomicTxn.complete();
                            }, 50);
                        });
                    }, 100);

                    setTimeout(function () {
                        cal.createTransaction('nested', 'name', function (err, nestedTxn) {
                            setTimeout(function () {
                                cal.createEvent('success-type3', 'success-name3').complete();
                                nestedTxn.complete();
                            }, 50);
                        });
                    }, 150);

                    setTimeout(function () {
                        urlTransaction.name = 'samplepage_new_name';
                        urlTransaction.complete();
                        next();
                    }, 350);
                });

            });

            it('should record a URL transaction with some events and Async transaction - with buffering', function (next) {

                cal.setThreadId(0xcafe1);

                cal.setEnableBuffering(true);

                var correlationId = '0xcafebabe';

                cal.createTransaction('URL', 'samplepage', function (err, urlTransaction) {
                    urlTransaction.flush();

                    urlTransaction.correlationId = correlationId;
                    urlTransaction.addData('foo', 'bar');

                    cal.createEvent('success-type1', 'success-name1', '0').complete();

                    setTimeout(function () {
                        cal.createEvent('success-type2', 'success-name2', '0').complete();
                    }, 10);

                    setTimeout(function () {
                        cal.createEvent('fatal-type', 'fatal-name', '1').complete();
                    }, 30);

                    setTimeout(function () {
                        cal.createEvent('error-type', 'error-name', '2').complete();
                    }, 40);

                    setTimeout(function () {
                        cal.createEvent('exception-type', 'exception-name', '3').complete();
                    }, 50);

                    setTimeout(function () {
                        cal.createEvent('warning-type', 'warning-name', '4').complete();
                        cal.createTransaction('atomic', 'name', function (err, atomicTxn) {
                            setTimeout(function () {
                                atomicTxn.complete();
                            }, 50);
                        });
                    }, 100);

                    setTimeout(function () {
                        cal.createTransaction('nested', 'name', function (err, nestedTxn) {
                            setTimeout(function () {
                                cal.createEvent('success-type3', 'success-name3').complete();
                                nestedTxn.complete();
                            }, 50);
                        });
                    }, 150);

                    setTimeout(function () {
                        urlTransaction.name = 'samplepage_buffering';
                        urlTransaction.complete();
                        next();
                    }, 350);
                });

            });
        });

    });

}
