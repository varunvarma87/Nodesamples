'use strict';

/*eslint no-multi-spaces:0, no-unused-expressions:0 */

var os = require('os'),
    net = require('net'),
    util = require('util'),
    moment = require('moment'),
    stream = require('readable-stream'),
    objutil = require('objutil'),
    apputil = require('../apputil'),
    tryRequire = require('try-require'),
    threads = require('../threads'),
    constants = require('../constants'),
    deployEnv = require('environment-paypal'),
    connectionTester = require('connection-tester');

var nconf = tryRequire('nconf'),
    debug = require('debug')('cal:stream');

var ipAddress = require('ip').address();

var machineName = os.hostname();

var RETRY_LIMIT = 10,
    DEFAULT_CONNECTION_TIMEOUT = 65000,    //1+ min
    DEFAULT_DELAY_START = 10,   //10ms
    MAX_DELAY_START = 500;  //500ms

var skipper = 0,
    skipperSize = 0,
    resolvedHost;

function Transformer(options) {
    Transformer.super_.apply(this);
    options = options || {};

    this._state = Transformer.State.DISCONNECT;
    this._connRetryCounter = 0;
    this._delayStart = DEFAULT_DELAY_START;

    var tconf = nconf && nconf.get('cal') || {};

    this._port = tconf.port || options.port || 1118;
    if (resolvedHost) {
        this._host = resolvedHost;
    } else {
        this._host = 'localhost';
        if (!deployEnv._env) {
            if (connectionTester.test(this._host, this._port).success) {
                resolvedHost = this._host;
            } else {
                this._host = tconf.host || options.host || this._host;
                debug('localhost caldaemon connection test failed, switching to %s host', this._host);
            }
        }
        if (!resolvedHost && connectionTester.test(this._host, this._port).success) {
            resolvedHost = this._host;
        } else {
            debug('%s connection test failed', this._host);
        }
    }

    this._environment = options.environment || 'PayPal';
    this._poolname    = options.poolname || apputil.getAppName() || constants.UNSET;
    this._buildLabel  = options.buildLabel || apputil.getBuildVersion() || constants.UNSET;
    this._buildLabel  = this._buildLabel + ';***;' + constants.PLATFORM;
    this._tryReconnect = true;
    this._connectionTimeout = options.timeout || DEFAULT_CONNECTION_TIMEOUT;

    this.on('finish', this._onEnd.bind(this));
}

Transformer.RECONNECTABLE = [ 'EPIPE', 'ECONNRESET', 'ECONNREFUSED' ];


Transformer.State = {
    DISCONNECT: 0,
    CONNECTING: 1,
    CONNECTED: 2
};


objutil.extend(Transformer, stream.Transform, {

    _createSocket: function () {
        var socket;
        socket = this._socket = new net.Socket();
        socket.setNoDelay(true);
        socket.setTimeout(this._connectionTimeout);
        socket.on('pipe',    this._onPipe.bind(this));
        socket.on('unpipe',  this._onUnpipe.bind(this));
        socket.on('error',   this._onError.bind(this));
        socket.on('close',   this._onClose.bind(this));
        socket.on('timeout', this._onTimeout.bind(this));
        debug('creating new socket');
        return socket;
    },


    _destroySocket: function () {
        var socket = this._socket;
        if (socket) {
            socket.removeAllListeners('pipe');
            socket.removeAllListeners('unpipe');
            socket.removeAllListeners('error');
            socket.removeAllListeners('close');
            socket.removeAllListeners('timeout');
            socket.destroy();
        }
        this._socket = undefined;
        debug('socket destroyed');
    },


    _connect: function (callback) {
        var socket;

        if (this._state !== Transformer.State.DISCONNECT) {
            debug('still connecting...');
            return callback && callback();
        }

        if (this._socket) {
            debug('reusing existing socket');
            return callback && callback();
        }

        socket = this._createSocket();

        this._state = Transformer.State.CONNECTING;
        debug('socket connect', this._host, this._port);
        socket.connect(this._port, this._host, function () {
            this._state = Transformer.State.CONNECTED;
            this.unpipe(socket);
            this.pipe(socket);
            this._delayStart = DEFAULT_DELAY_START;
            this._connRetryCounter = 0;
            callback && callback();
        }.bind(this));
    },

    //stream.Transform fn
    _transform: function (chunk, encoding, callback) {
        var that = this;

        function write() {
            if (chunk.length > 0) {
                if (that._state === Transformer.State.CONNECTED) {
                    that.push(that._packMessage(chunk.toString('utf8')));
                } else {
                    debug('write issue, socket closed');
                }

                skipperSize += chunk.length;
                if (skipper % 1000 === 0) {
                    debug('writing %s bytes', skipperSize);
                    skipperSize = 0;
                }
                skipper++;
            }
            callback();
        }

        if (this._state === Transformer.State.DISCONNECT) {
            debug('disconnected state, connecting again');
            this._connect(write);
        } else {
            write();
        }
    },

    _onEnd: function () {
        this._socket && this._socket.end();
        this._state = Transformer.State.DISCONNECT;
        this._destroySocket();
        debug('socket end');
    },

    _onTimeout: function () {
        this._socket && this._socket.end();
        this._state = Transformer.State.DISCONNECT;
        this._destroySocket();
        debug('socket timeout');
    },


    _onError: function (err) {
        if (this._state === Transformer.State.DISCONNECT) {
            return;
        }
        this._state = Transformer.State.DISCONNECT;

        if (!~Transformer.RECONNECTABLE.indexOf(err.code) || this._connRetryCounter > RETRY_LIMIT) {
            this._tryReconnect = false;
            resolvedHost = null;
            this.emit('error', err);
        }

        if (err.code === 'ECONNREFUSED') {
            this._connRetryCounter++;
        }

        debug(err.code, 'retry count:', this._connRetryCounter);
    },


    _onClose: function (hadError) {
        if (this._state === Transformer.State.DISCONNECT) {
            return;
        }
        this._state = Transformer.State.DISCONNECT;
        this._destroySocket();
        if (hadError) {
            debug('closing with errors');
            if (this._tryReconnect) {
                setTimeout(function () {
                    this._connect();
                }.bind(this), this._delayStart);
                debug('retrying cal connection after %sms', this._delayStart);
                this._delayStart = Math.min(this._delayStart + DEFAULT_DELAY_START, MAX_DELAY_START);
            }
        } else {
            debug('closing without errors');
        }
    },


    _onPipe: function () {
        this._socket.write(this._packMessage(this._createMachineHeader()));
        debug('piping machine headers');
    },


    _onUnpipe: function () {
        // nada for now
    },


    _createMachineHeader: function () {
        var header = [];

        if (this._environment === 'PayPal') {
            header.push(util.format('SQLLog for %s:%s', this._poolname, machineName));
        } else {
            header.push(util.format('SQLLog for %s:%s:%s', this._poolname, machineName, ipAddress));
        }
        header.push(util.format('Environment: %s', this._environment));
        header.push(util.format('Label: %s', this._buildLabel));
        header.push(util.format('Start: %s', moment().format('DD-MM-YYYY HH:mm:ss')));

        return header.join('\n');
    },


    _packMessage: function (message) {
        var parts = message.split('\t'),
            threadId,
            eventId,
            parentEventId;

        if (parts.length > 3) {
            eventId = +(parts.shift());
            parentEventId = +(parts.shift());
            threadId = +(parts.shift());
            message = parts.join('\t');
        }

        eventId = eventId || 0;
        parentEventId = parentEventId || 0;
        threadId = threadId || threads.getDefaultThreadId();

        var buffer = new Buffer(constants.HEADER_SIZE + Buffer.byteLength(message));
        buffer.writeUInt32BE(threadId, 0);
        buffer.writeUInt16BE(parentEventId, 4);
        buffer.writeUInt16BE(eventId, 6);
        buffer.writeUInt32BE(Buffer.byteLength(message), 8);
        buffer.write(message, 12);
        return buffer;
    },

    shutdown: function (next) {
        this._state = Transformer.State.DISCONNECT;
        this._tryReconnect = false;
        resolvedHost = null;
        debug('shutting down connection');
        this.end();
        if (next) {
            next();
        }
    }

});

module.exports = {

    createWriteStream: function cal(options) {
        return new Transformer(options);
    }
};
