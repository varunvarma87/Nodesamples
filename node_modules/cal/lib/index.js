'use strict';

require('continuation-local-storage');

var events = require('events'),
    domain = require('domain'),
    objutil = require('objutil'),
    constants = require('./constants'),
    Logger = require('./logger'),
    StreamQueue = require('./stream-queue'),
    stream = require('./stream'),
    formatter = require('./formatter'),
    nsutils = require('./nsutils'),
    deployEnv = require('environment-paypal');

var debug = require('debug')('cal:index');

var writeStreamCache = {
        type: 'cal'
    };

var logger = new Logger();

var queue = new StreamQueue({
    writer: stream[writeStreamCache.type],
    formatter: formatter.cal
});

var defaultDomain;

function resetDefaultDomain() {
    var _domain;
    _domain = domain.create();
    _domain.add(logger);
    _domain.add(queue);
    _domain.on('error', function (err) {
        var errObj = {
            name: 'Cal' + err.name,
            code: err.code,
            errno: err.errno,
            stack: err.stack || err.message
        };
        console.error(Date.now(), errObj);

        if (deployEnv.isDev()) {
            writeStreamCache.type = 'console';
            cal.defaults.formatter = formatter.pretty;
            debug('switching to non-deployed mode');
        }

        queue.writer = null;

        cal.setDefaultWriteStream(writeStreamCache.type, writeStreamCache.options);
    });

    if (defaultDomain) {
        //cleanup old domain
        defaultDomain.remove(logger);
        defaultDomain.remove(queue);
    }

    defaultDomain = _domain;
}

resetDefaultDomain();


var cal = {

    get defaults() {
        return queue.options;
    },

    set defaults(value) {
        value = objutil.merge(queue.options, value || {});
        queue.options = value;
    },

    get queue() {
        return queue;
    },

    get logger() {
        return logger;
    },

    createEvent: function (type, name, status, data) {
        this.start();
        return logger.createEvent(type, name, status, data);
    },


    createHeartbeat: function (type, name, status, data) {
        this.start();
        return logger.createHeartbeat(type, name, status, data);
    },

    createTransaction: function (/*type, name, status, data, callback*/) {
        this.start();
        return logger.createTransaction.apply(logger, arguments);
    },

    createQueue: function (options) {
        var newQueue;
        options = objutil.merge(queue.options, options || {});
        debug('new stream-queue', options);
        newQueue = new StreamQueue(options);
        return newQueue;
    },

    createLogger: function (options) {
        var publisher;
        var publishTopic;
        if (options && (options.inherit === undefined || options.inherit)) {
            options = objutil.merge(logger.options, options || {});
            publisher = logger._publisher;
            publishTopic = logger._publishTopic;
        }
        debug('new logger', options);
        var newLogger = new Logger(options);
        newLogger._publisher = publisher || process;
        newLogger._publishTopic = publishTopic || constants.CAL_EVENT_TYPE;
        return newLogger;
    },

    setDefaultWriteStream: function (type, options) {
        debug('setting defaults write stream', type, options);
        writeStreamCache = {
            type: type,
            options: options
        };

        cal.defaults.writerOptions = options;
        cal.defaults.writer = cal.stream[type];
        cal.defaults.formatter = cal.formatter[type];

        //re initialize stream queue on resetting writeStream
        options = options || {};
        options.writer = cal.defaults.writer;
        options.formatter = cal.defaults.formatter;
        this.stop(function () {
            queue = this.createQueue(options);
            resetDefaultDomain();
        }.bind(this));
    },

    start: function () {
        if (!this._started) {
            this._started = true;
            logger.publishTo(process, constants.CAL_EVENT_TYPE);
            queue.subscribe(process, constants.CAL_EVENT_TYPE);
            debug('starting logger & queue listeners');
        }
    },

    stop: function (next) {
        if (this._started) {
            logger.clearPublishTargets();
            queue.close(function () {
                this._started = false;
                debug('stopping logger & queue listners');
                next();
            }.bind(this));
        } else {
            next();
        }
    },

    stream: require('./stream'),

    formatter: require('./formatter'),

    Status: require('./constants').Status,

    setThreadId: require('./threads').setThreadId,

    setEnableBuffering: function (value) {
        nsutils.set(constants.IS_BUFFERING, value);
    },

    setEnableNestedCal: function (value) {
        nsutils.set(constants.IS_NESTED_CAL, value);
    },

    middleware: require('./middleware'),

    get correlationId() {
        var correlationId = nsutils.getValue('correlationId');
        return correlationId;
    }
};

module.exports = objutil.mixin(cal, new events.EventEmitter());
