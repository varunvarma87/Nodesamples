'use strict';

var moment = require('moment'),
    _ = require('underscore'),
    querystring = require('querystring'),
    constants = require('../constants'),
    threads = require('../threads'),
    stringify = require('json-stringify-safe');

var MessageClass = constants.MessageClass;

var CONTROL_CHARS = {
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
    '\f': '\\f'
};

var CONTROL_CHAR_MATCHER = new RegExp('[' + Object.keys(CONTROL_CHARS).join('') + ']', 'g');


function escapeControlChars(str) {
    return (str || '').replace(CONTROL_CHAR_MATCHER, function (c) {
        return CONTROL_CHARS[c] || c;
    });
}


function truncate(str, length) {
    // Truncate string to byte length to setup our guesstimation.
    var result = str.substring(0, length),
        bytes = Buffer.byteLength(result),
        percent,
        guess,
        next,
        resultLen = 0,
        nextLen = 0;

    // Only proceed if original truncation wasn't enough.
    if (bytes > length) {
        // See how much bigger our truncated string is than the requested length.
        // (e.g. desired length is 80% of the string length)
        percent = length / bytes;

        // Calculate a guess as to the size of the resulting string.
        // This assumes a somewhat even distribution of single and multi-byte chars
        guess = Math.round(result.length * percent);

        // Grab our guess and cache the length
        result = result.substring(0, guess);
        resultLen = Buffer.byteLength(result);

        // Grab the next char and cache the length
        next = str.charAt(guess);
        nextLen = Buffer.byteLength(next);

        // If our estimate was too optimistic (e.g. the guess was smaller than
        // desired bytes - next character, append necessary chars until we reach
        // the requested length
        while (next && ((resultLen + nextLen) <= length)) {
            guess += 1;
            result += next;
            next = str.charAt(guess);
            nextLen = Buffer.byteLength(next);
            resultLen += nextLen;
        }

        // If the guess was too pessimistic, truncate char by char and work
        // backward until we get a valid length
        while (Buffer.byteLength(result) > length) {
            // Remove the trailing character and try again
            result = result.slice(0, -1);
        }
    }
    return result;
}

/*eslint no-extend-native:0 */
//JSON.stringify(err, ["message", "errno", "type", "name", "stack"])
Object.defineProperty(Error.prototype, 'toJSON', {
    value: function () {
        var alt = {
            name: this.name,
            type: this.type,
            errno: this.errno,
            message: this.message,
            stack: this.stack
        };

        return alt;
    },
    configurable: true
});

/**
 * For extracting useful information out of Error object
 */
function errorToJSON(errObj) {
    return {
        name: errObj.name,
        type: errObj.type,
        errno: errObj.errno,
        message: errObj.message,
        stack: errObj.stack
    };
}

function parseJSON(value) {
    var obj;
    try {
        obj = JSON.parse(stringify(value));
    } catch (e) {
        //No op
    }
    return obj;
}

module.exports = {

    // Per: https://confluence.paypal.com/cnfl/display/CAL/CAL+APIs#CALAPIs-CalEvent
    // <Class>\t<Timestamp>\t<Type>\\t<Name>[\t<Status>][\t<Duration>][\t<Data>]
    format: function cal(args) {
        var fields, obj, value,
            datafield = [],
            defautlThreadId = threads.getDefaultThreadId(),
            threadId = args.threadId || defautlThreadId;

        if (args.messageClass === MessageClass.HEARTBEAT) {
            //Writing all the Heartbeat messages on Default Thread id.
            threadId = defautlThreadId;
        }

        fields = [
            args.eventId || 0,
            args.parentEventId || 0,
            threadId,
            args.messageClass + moment(args.timestamp).format('HH:mm:ss.SS'),
            args.type,
            args.name,
            args.status
        ];

        // Optional duration field
        if (args.duration !== undefined) {
            fields.push(args.duration);
        }

        // Truncate all non-data fields to max allowed length
        fields = fields.map(function (fieldValue) {
            return truncate(String(fieldValue), constants.MAX_FIELD_LENGTH);
        });

        var data = _.clone(args.data);

        if (data && args.messageClass !== MessageClass.TRANSACTION_START) {
            if (typeof data === 'string') {
                fields.push(escapeControlChars(data));
            } else {
                for (var key in data) {
                    value = data[key];
                    if (key === 'msg' && value && value.length === 1 &&
                        Object.keys(data).length === 1) {
                        // usecase of only 1 string value
                        fields.push(escapeControlChars(value.join()));
                        delete data[key];
                    }
                    else if (typeof value === 'object') {
                        if (value instanceof Error) {
                            datafield.push(querystring.unescape(escapeControlChars(querystring.stringify(errorToJSON(value)))));
                            delete data[key];
                        } else {
                            obj = parseJSON(value);
                            if (obj) {
                                if (!Array.isArray(obj)) {
                                    // serializing 1st level JSON object into String with '*' as delimiter
                                    obj = querystring.unescape(escapeControlChars(querystring.stringify(obj)));
                                    obj = obj.replace(/&/g, '*');
                                    datafield.push(key + '=' + obj);
                                    delete data[key];
                                }
                            }
                        }
                    }
                }
                // encode data and truncate to max allowed message length
                datafield.push(querystring.unescape(escapeControlChars(querystring.stringify(data))));

                fields.push(datafield.join('&'));
            }
        }

        return truncate(fields.join(constants.FIELD_DELIMITER), constants.MAX_MESSAGE_LENGTH - constants.CRLF.length) + constants.CRLF;
    }

};
