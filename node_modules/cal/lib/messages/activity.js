'use strict';

var objutil = require('objutil'),
    constants = require('../constants'),
    calbuffer = require('../calbuffer'),
    threads = require('../threads'),
    nsutils = require('../nsutils');

var EventEmitter = require('events').EventEmitter;

var calProhibitedCharsRegex = /[/ '"<>\t\n]/g,  //'
    calProhibitedNonAsciiChars = /[^\x20-\x7E]/g;

var PIIKeywords = require('../../config/config.json').PIIKeywords;
var defaultThreadId = threads.getDefaultThreadId();

function BaseActivity(type, name, status, data) {
    this._type = type || constants.UNSET;
    this._name = name || constants.UNSET;
    this._status = status || constants.Status.SUCCESS;
    this._data = (typeof data === 'string') ? data : (data || Object.create(null));
    this._klass = undefined;
    this._timestamp = Date.now();
    this._type = sanitize(this._type);
    this._name = sanitize(this._name);
    this._flushBuffer = false;

    this._isNestedCalEvents = nsutils.get(constants.IS_NESTED_CAL) || false;
    this._bufferFlushDelay = nsutils.get(constants.BUFFER_FLUSH_DELAY, 0);
    this._isBufferingEnabled = nsutils.get(constants.IS_BUFFERING) || this._isNestedCalEvents || false;

}

// Remove characters CAL will not accept.
// https://confluence.paypal.com/cnfl/display/CAL/CAL+Message+Guidelines#CALMessageGuidelines-G6CALMessageTypeandNamefieldguidelines
function sanitize(str) {
    var s = str;
    if (s && typeof s === 'string') {
        s = str.replace(calProhibitedCharsRegex, '_');
        s = s.replace(calProhibitedNonAsciiChars, '_');
        if (s.length > 127) {
            s = s.substr(0, 127);
        }
    }
    return s;
}

//Filtering known PII from CAL
function isPIISafe(key) {
    if (PIIKeywords.indexOf(key) > -1) {
        return false;
    }
    return true;
}

objutil.extend(BaseActivity, EventEmitter, {

    get messageClass() {
        return this._klass;
    },

    set messageClass(value) {
        this._klass = value;
    },


    get type() {
        return this._type;
    },

    set type(value) {
        this._type = sanitize(value);
    },


    get name() {
        return this._name;
    },

    set name(value) {
        this._name = sanitize(value);
    },


    get status() {
        return this._status;
    },

    set status(value) {
        this._status = String(value);
    },


    get timestamp() {
        return this._timestamp;
    },

    set timestamp(value) {
        this._timestamp = value;
    },

    get threadId() {
        this._threadId = this._threadId || threads.getThreadId() || defaultThreadId;
        return this._threadId;
    },

    set threadId(threadId) {
        this._threadId = threadId;
    },

    get eventId() {
        return this._eventId;
    },

    set eventId(value) {
        this._eventId = value;
    },

    get parent() {
        return this._parent;
    },

    set parent(value) {
        this._parent = value;
    },

    get parentEventId() {
        return this._parent && this._parent.eventId || 0;
    },

    get flushBuffer() {
        return this._flushBuffer;
    },

    set flushBuffer(value) {
        this._flushBuffer = value;
    },


    addData: function (key, value) {

        if (value !== undefined) {

            if (isPIISafe(key)) {
                // Both args are set, so just update data
                this._data[key] = value;
            }

        } else {

            if (typeof key === 'object') {
                // Copy values to data
                Object.keys(key).forEach(function (prop) {
                    if (isPIISafe(prop)) {
                        this._data[prop] = key[prop];
                    }
                }.bind(this));
            } else {
                this._data.msg = this._data.msg || [];
                this._data.msg.push(key);
            }
        }
        return this;
    },

    getCalBuffer: function () {
        return calbuffer.getCalBuffer(this.threadId, this._isNestedCalEvents, this._bufferFlushDelay);
    },

    complete: function (status) {

        if (status !== undefined) {
            this.status = status;
        }

        this._doComplete();

        var eventArgs = this._getEventArgs();

        if (this._isBufferingEnabled && this.threadId !== defaultThreadId) {
            var buffer = this.getCalBuffer();
            var parentEventId = eventArgs.parentEventId || 0;

            buffer.push({instance: this, eventName: 'complete', args: eventArgs});
            if (this._flushBuffer && parentEventId === 0) {
                buffer.flushAll();

                // restore to parent just in case the chain continue,
                // while it should never happen at runtime, only in unit tests
                if (this.parent) {
                    nsutils.set(constants.TX, this.parent);
                }
            }
        } else {
            this.emit('complete', eventArgs);
            // restore to parent just in case the chain continue,
            // while it should never happen at runtime, only in unit tests
            if (this.parent) {
                nsutils.set(constants.TX, this.parent);
            }
        }
    },


    _doComplete: function () {
        // noop
    },


    _getEventArgs: function () {
        var eventArgs, extraArgs;

        eventArgs = {
            type: this.type,
            name: this.name,
            status: this.status,
            data: this._data,
            messageClass: this._klass,
            timestamp: this.timestamp,
            threadId: this.threadId,
            eventId: this.eventId,
            parentEventId: this.parentEventId || 0
        };

        extraArgs = this._doGetEventArgs();
        if (extraArgs) {
            Object.getOwnPropertyNames(extraArgs).forEach(function (prop) {
                eventArgs[prop] = extraArgs[prop];
            });
        }
        return eventArgs;
    },


    _doGetEventArgs: function () {
        // noop
        return undefined;
    }

});

module.exports = BaseActivity;
