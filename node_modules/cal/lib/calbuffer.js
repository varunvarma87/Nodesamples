'use strict';

/*eslint new-cap:0 */

var constants = require('./constants'),
    LRU = require('lru-cache');

var cacheOptions = {
        max: 1000,
        maxAge: 2 * 60 * 1000   //2 min cache
    },
    calBufferStore = LRU(cacheOptions);
//Adding LRU cache to cleanup zombie threadId Cal Buffers

var MessageClass = constants.MessageClass;

function clearCalBuffer(threadId) {
    var oldValue = calBufferStore.get(threadId);
    calBufferStore.del(threadId);
    return oldValue;
}
module.exports.clearCalBuffer = clearCalBuffer;

function flush(cal) {
    send(cal);
    if (cal.children) {
        cal.children.forEach(flush);
    }
}

function flushTree(cal) {
    send(cal);
    var closeEvt;
    if (cal.children) {
        var evtId = cal.args.eventId;
        // normalize tx by auto-completing unfinshed open transactions
        cal.children.filter(function (evt) {
            if (evt.args.eventId !== evtId || evt.args.messageClass !== MessageClass.TRANSACTION_END) {
                return true;
            }
            // remember we have it
            if (closeEvt) {
                // skipping it
            }
            else {
                closeEvt = evt;
            }
        }).forEach(flushTree);
        // complete tx
        if (!closeEvt) {
            // generate auto-complete event with unfinished status
            closeEvt = generateCloseEvent(cal);
        }
        send(closeEvt);
    }
    // no children
    else if (cal.args.messageClass === MessageClass.TRANSACTION_START) {
        // generate auto-complete event with unfinished status
        closeEvt = generateCloseEvent(cal);
        send(closeEvt);
    }
}

function generateCloseEvent(calStartEvt) {
    var startEvtArgs = calStartEvt.args;
    return {
        instance: calStartEvt.instance,
        eventName: 'complete',
        args: {
            type: startEvtArgs.type,
            name: startEvtArgs.name,
            threadId: startEvtArgs.threadId,
            eventId: startEvtArgs.eventId,
            parentEventId: startEvtArgs.parentEventId,

            status: 'UNFINISHED',
            timestamp: Date.now(),
            duration: Date.now() - startEvtArgs.timestamp,
            data: '',
            messageClass: MessageClass.TRANSACTION_END
        }
    };
}

function send(cal) {
    if (cal.args.messageClass === MessageClass.TRANSACTION_START) {
        cal.args.name = cal.instance.name;
    }
    setImmediate(function () {
        cal.instance.emit(cal.eventName, cal.args);
    });
}

function ArrayBuffer(threadId) {
    this.threadId = threadId;
    this.children = [];
}

ArrayBuffer.prototype = {
    push: function push(calEvt) {
        this.children.push(calEvt);
    },

    flushAll: function flushAll() {
        clearCalBuffer(this.threadId);
        this.children.forEach(flush);
    }
};

// let's keep order of nested messages by re-ordering them before flushing
function CalBuffer(threadId, flushDelayInterval) {
    this.threadId = threadId;
    this.children = [];
    this.map = {};
    this.flushDelayInterval = flushDelayInterval || 0;
}

CalBuffer.prototype = {
    push: function push(calEvt) {
        var parent;
        // building the dom
        var isTxEnd = calEvt.args.messageClass === MessageClass.TRANSACTION_END;
        parent = this.map[isTxEnd ? calEvt.args.eventId : calEvt.args.parentEventId];
        if (parent) {
            parent.children = parent.children || [];
            parent.children.push(calEvt);
        }
        else {
            this.children.push(calEvt);
        }
        // avoid overwriting 't'
        if (!isTxEnd) {
            this.map[calEvt.args.eventId] = calEvt;
        }
    },

    flushAll: function flushAll() {
        var flushAllTimer;
        flushAllTimer = setTimeout(function () {
            clearCalBuffer(this.threadId);
            this.children.forEach(flushTree);
        }.bind(this), this.flushDelayInterval);
        flushAllTimer.unref();
    }
};

function getCalBuffer(threadId, tree, flushDelayInterval) {
    var buffer = calBufferStore.get(threadId);
    if (!buffer) {
        calBufferStore.set(threadId, tree ? new CalBuffer(threadId, flushDelayInterval) : new ArrayBuffer(threadId));
        buffer = calBufferStore.get(threadId);
    }
    return buffer;
}
module.exports.Buffer = CalBuffer;
module.exports.ArrayBuffer = ArrayBuffer;
module.exports.getCalBuffer = getCalBuffer;

function move(threadIdFrom, threadIdTo, cleanup) {
    var threadIdFromBuffer = calBufferStore.get(threadIdFrom);
    calBufferStore.set(threadIdTo, threadIdFromBuffer);
    var targetBuffer = calBufferStore.get(threadIdTo);

    if (targetBuffer) {
        targetBuffer.threadId = threadIdTo;
    }
    if (cleanup) {
        calBufferStore.del(threadIdFrom);
    }
}
module.exports.move = move;
