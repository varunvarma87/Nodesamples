'use strict';
/*eslint new-cap:0, no-unused-expressions:0 */

var os = require('os'),
    async = require('async'),
    domain = require('domain'),
    LRU = require('lru-cache'),
    events = require('events'),
    objutil = require('objutil'),
    constants = require('./constants');

var debug = require('debug')('cal:queue');

var DEFAULT_POOL_SIZE = 10,
    MAX_PROCESS_QUEUE_SIZE = 1000,
    CACHE_POOL_SIZE = DEFAULT_POOL_SIZE + 1;

var cacheOptions = {
        max: CACHE_POOL_SIZE
    },
    calStreamPool = LRU(cacheOptions);
//Adding LRU cache to cleanup zombie streamPool


function getPoolSize() {
    var cpus,
        instances,
        poolSize = DEFAULT_POOL_SIZE;

    if (process.env.pm_id) {    //means running multiple node processes
        cpus = os.cpus();

        if (process.env.cluster_instance) {
            instances = +process.env.cluster_instance || 'max';
        }

        if (instances && instances === 'max') {
            instances = cpus.length;
        } else if (!instances) {
            instances = 2;
        }

        // minimum 2 node processes with pm2
        instances = Math.max(Math.min(instances, DEFAULT_POOL_SIZE), 2) || 2;

        if (cpus && cpus.length > 1) {
            poolSize = DEFAULT_POOL_SIZE / instances;
            poolSize = Math.max(parseInt(poolSize, 10), 1);
        }
    }
    return poolSize;
}

function _closeStream(streamX) {
    var stream = streamX && streamX.stream;
    if (stream) {
        try {
            stream.end();
        } catch (e) {
            streamX.stream = null;
            debug('error closing stream');
        }
    }
}

function StreamQueue(options) {
    StreamQueue.super_.apply(this, arguments);
    this._options = options || {};
    this._subscription;
    this._subscriptionTopic;

    this._domain = domain.create();
    this._domain.on('error', this._replay('error'));
    this._listener = this._write.bind(this);
    this._poolSize = getPoolSize();
}

module.exports = StreamQueue;

objutil.extend(StreamQueue, events.EventEmitter, {

    get options() {
        return this._options;
    },

    set options(value) {
        this._options = value;
    },

    subscribe: function (publisher, topic) {
        if (this._subscription) {
            // unsubscribe first
            this._subscription.removeListener(this._subscriptionTopic, this._listener);
        }

        publisher.on(topic, this._listener);
        this._subscription = publisher;
        this._subscriptionTopic = topic;
    },

    unsubscribe: function () {
        if (this._subscription) {
            // unsubscribe
            this._subscription.removeListener(this._subscriptionTopic, this._listener);
            this._subscription = undefined;
        }
    },

    _replay: function (event) {
        var that = this;
        return function () {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(event);
            that.emit.apply(that, args);
        };
    },

    close: function close(next) {
        this.unsubscribe();
        this._shutdownStream(next);
    },

    _filterEventsFromQueue: function (streamX) {
        var beforeLength, afterLength;
        //Filter out events from queue in case of queue length >=10k and after 3 reconnects
        //10 threads * 10k limit/queue = 100k
        beforeLength = streamX._queue.length;
        if (streamX.reconnects > 2 && beforeLength > 10000) {
            streamX._queue = streamX._queue.filter(function (eventArgs) {
                return eventArgs.messageClass !== constants.MessageClass.EVENT;
            });
            afterLength = streamX._queue.length;
            if (afterLength > beforeLength / 2) {
                //dump the queue if filtering not effective
                streamX._queue = [];
            }
            streamX.reconnects = 1; //resetting reconnects to 1 to avoid frequent filtering
            debug('reducing stream queue for poolId: %s, new queue size: %s',
                streamX.poolId, streamX._queue.length);
        }
    },

    _createNewWriteStream: function (streamX) {
        if (!streamX._queueWrites) {
            return;
        }
        debug('forcing new stream create');
        _closeStream(streamX);
        // update options in case they have changed so that during re-creation of the stream
        // they are picked up
        streamX.options = this._options;
        streamX.writerOptions = streamX.options.writerOptions || {};
        streamX.format = streamX.options.formatter.format;
        streamX.reconnects++;
        debug('poolId %s reconnect %s ', streamX.poolId, streamX.reconnects);
        this._filterEventsFromQueue(streamX);
        streamX.stream = streamX.options.writer.createWriteStream(streamX.writerOptions);
        this._onDrain(streamX);
    },

    _timerForNoDrain: function (streamX) {
        if (!streamX._timer) {
            //If no drain in 10s, create a new writeStream
            streamX._timer = setTimeout(this._createNewWriteStream.bind(this, streamX), 10000);
            streamX._timer.unref();
        }
    },

    _getStream: function (eventArgs) {
        var options, streamX,
            writerOptions, threadId,
            poolId = 0;

        threadId = eventArgs.threadId || 1;
        poolId = (parseInt(threadId / (this._poolSize / 2), 10) % this._poolSize) || 0;
        streamX = calStreamPool.get(poolId);
        if (!streamX) {
            options = this._options;
            writerOptions = options.writerOptions || {};

            streamX = {};
            streamX.options = options;
            streamX.poolId = poolId;
            streamX.format = options.formatter.format;
            streamX.writerOptions = writerOptions;
            streamX.stream = streamX.options.writer.createWriteStream(streamX.writerOptions);
            streamX.reconnects = 0;
            streamX._queueWrites = false;
            streamX._awaitingDrain = false;
            streamX._queue = [];
            calStreamPool.set(poolId, streamX);

            this._domain.add(streamX.stream);

            debug('new streamX', poolId, options);
        }
        return streamX;
    },

    _clearTimer: function (streamX) {
        if (streamX._timer) {
            streamX._timer.ref();
            clearTimeout(streamX._timer);
            streamX._timer = null;
        }
    },

    _write: function write(eventArgs) {
        var streamX = this._getStream(eventArgs);

        this._domain.run(function () {
            if (!streamX._queueWrites) {
                // Write message, paying attention to backpressure
                streamX._queueWrites = !streamX.stream.write(streamX.format(eventArgs));
                this._clearTimer(streamX);
            } else {
                // Queue the message
                streamX._queue.push(eventArgs);

                if (!streamX._awaitingDrain) {
                    // Not listening for drain events, so start. Use `once` since streams can be swapped
                    // out at any time. This allows our handler to clean up after itself.
                    streamX.stream.removeAllListeners('drain');
                    streamX.stream.once('drain', this._onDrain.bind(this, streamX));
                    streamX._awaitingDrain = true;
                    this._timerForNoDrain(streamX);
                }
            }
        }.bind(this));
    },

    _forceDrain: function (streamX) {
        if (streamX._queue && streamX._queue.length && !streamX._queueWrites) {
            // Start processing the queue, MAX_PROCESS_QUEUE_SIZE at a time
            for (var i = 0; i < MAX_PROCESS_QUEUE_SIZE; i++) {
                if (streamX._queue.length && !streamX._queueWrites) {
                    this._write.call(this, streamX._queue.shift());
                }
                else {
                    break;
                }
            }
        }
    },

    _onDrain: function (streamX) {
        streamX._queueWrites = false;
        streamX._awaitingDrain = false;

        this._forceDrain(streamX);

        if (!streamX._queue.length) {
            debug('backlog is empty');
            return;
        }

        if (streamX._queue.length && !streamX._awaitingDrain) {
            // There's still a queue to be processed, so reset one.
            streamX.stream.removeAllListeners('drain');
            streamX.stream.once('drain', this._onDrain.bind(this, streamX));
            streamX._awaitingDrain = true;
            this._timerForNoDrain(streamX);
        }
    },

    _shutdownStream: function (next) {
        var self = this;
        async.times(CACHE_POOL_SIZE, function (threadId, cb) {
            var streamX = calStreamPool.get(threadId);
            if (streamX && streamX.stream) {
                self._forceDrain(streamX); //drain one last time to flush all the events
                self._clearTimer(streamX);
                streamX.stream.removeAllListeners();
                if (streamX.stream.shutdown) {
                    streamX.stream.shutdown(cb);
                } else {
                    cb();
                }
            } else {
                cb();
            }
        }, function () {
            // reset the streamPool
            calStreamPool.reset();

            var writeStream = self.options.writeStream;
            if (writeStream && writeStream.shutdown) {
                writeStream.shutdown(next);
            } else {
                next && next();
            }
        });
    }
});
