'use strict';

var crypto = require('crypto'),
    base64 = require('./base64'),
    Ciphers = require('./ciphers'),
    DesxCipherSpec = require('./ciphers/desx'),
    Aes128CipherSpec = require('./ciphers/aes128');

var SHA1_DIGEST_LENGTH = 20;
var PSEUDO_IV_LENGTH = 8;

function equals (first, second, len) {
    var i;

    if (!len && first.length !== second.length) {
        return false;
    }

    i = 0;
    len = len || Math.min(first.length, second.length);

    while (i < len) {
        if (first[i] !== second[i]) {
            return false;
        }
        i += 1;
    }

    return true;
}

function PPCrypto (configuration) {
    this.encryptionAlgorithm = configuration.encryptionAlgorithm || 'desx';
    this.macAlgorithm = configuration.macAlgorithm || 'sha1';
    this.encryptionKey = configuration.encryptionKey;
    this.padding = !!configuration.padding;
    this.iv = configuration.iv;

    //TODO: UGLY, change this.
    if (this.encryptionAlgorithm === "desx") {
        this.macKey = DesxCipherSpec._truncateKey(configuration.macKey);
    }
    else if (this.encryptionAlgorithm === "aes-128-cbc") {
        this.macKey = Aes128CipherSpec._truncateKey(configuration.macKey);
    }
    else {
        this.macKey = configuration.macKey;
    }
}

PPCrypto.prototype = {

    /**
     * Creates a new cipher spec based off of this instance's configuration.
     * @returns {*}
     * @private
     */
    createCipherSpec: function (encAlg, encKey, padding, iv) {
        return Ciphers.createCipherSpec(encAlg || this.encryptionAlgorithm, encKey || this.encryptionKey, padding || this.padding, iv || this.iv);
    },

    /**
     * HMACs the input.
     * @param input
     * @returns {*}
     * @private
     */
    _hmac: function (input) {
        return crypto.createHmac(this.macAlgorithm, this.macKey).update(input).digest();
    },

    /**
     * HMACs and base64 encodes result.
     * @param input
     * @returns {*}
     */
    hmacString: function (input) {
        return base64.encode(this._hmac(input), base64.CharacterSet.PPUUENCODING, false).toString();
    },

    /**
     *
     * @param name
     * @param input
     * @param callback
     */
    sealAndEncodeNamed: function (name, input, callback) {
        this.sealAndEncode(Buffer.concat([new Buffer(name), input]), callback);
    },

    /**
     * Encrypts and then PP UUEncodes the result.
     * @param input
     * @param callback
     */
    sealAndEncode: function (input, callback) {
        this.seal(input, function (encrypted) {
            callback(base64.encode(encrypted, base64.CharacterSet.PPUUENCODING, false).toString());
        });
    },

    /**
     *
     *
     * Encrypt and obscure data using triple_des encryption algorithm.
     *
     *  The bytes in output buffer generated by this function look like:
     *  HHHHHHHHEEEEEEEEE...EEEEPPPPChhhhhhhhhhhhhhhhhhhh
     *
     *  H = First 8 bytes of a 20-byte SHA1 HMAC of the plaintext data under our mac key
     *  E = Encrypted value of the plaintext data under 3DES and our crypt key. Exactly as long as the length of the input buffer.
     *  P = From 0..7 bytes of pad to bring the plaintext data section up to an even multiple of 8. Contains 9th..Nth bytes of the
     *      SHA1 HMAC we started using in the 'H' section.
     *  C = Count of the number of pad bytes, plus one. The one extra is for counting the 'C' byte itself. (If the data length % 8 is 7,
     *      then there will be no bytes in the 'P' section, and the C
     *      byte will have the value 1.
     *  h = 20 bytes of SHA1 HMAC of all of {H, E, P, C} bytes.
     *
     *
     * @param input
     * @param callback
     */
    seal: function seal (input, callback) {
        var self, cipher, hmac, padCount, formatted;

        self = this;
        cipher = this.createCipherSpec();
        hmac = this._hmac(input);
        padCount = PSEUDO_IV_LENGTH - (input.length % PSEUDO_IV_LENGTH);

        formatted = [];
        formatted[0] = hmac.slice(0, PSEUDO_IV_LENGTH);
        formatted[1] = input;
        formatted[2] = hmac.slice(PSEUDO_IV_LENGTH, PSEUDO_IV_LENGTH + (padCount - 1));
        formatted[3] = new Buffer([padCount]);

        cipher.cipher(Buffer.concat(formatted), function (ciphered) {
            var result;

            result = [];
            result[0] = ciphered;
            result[1] = self._hmac(ciphered).slice(0, SHA1_DIGEST_LENGTH);

            callback(Buffer.concat(result));
        });
    },

    /**
     *
     * @param name
     * @param input
     * @param callback
     */
    decodeAndUnsealNamed: function (name, input, callback) {
        this.decodeAndUnseal(input, function (data) {
            callback(data.slice(Buffer.byteLength(name), data.length));
        });
    },

    /**
     *
     * @param input
     * @param callback
     */
    decodeAndUnseal: function (input, callback) {
        var decodedInput = base64.decode(input, base64.CharacterSet.PPUUENCODING, false);
        this.unseal(decodedInput, callback);
    },

    /**
     *
     * @param input
     * @param callback
     */
    unseal: function unseal (input, callback) {
        var self, trimmed, hmac;

        self = this;
        trimmed = input.slice(0, input.length - SHA1_DIGEST_LENGTH);
        hmac = this._hmac(trimmed);
        if (!equals(hmac, input.slice(input.length - SHA1_DIGEST_LENGTH, input.length))) {
            throw new Error('HMAC comparison failed');
        }

        this.createCipherSpec().decipher(trimmed, function (deciphered) {
            var padCount = deciphered[deciphered.length - 1];
            callback(deciphered.slice(PSEUDO_IV_LENGTH, deciphered.length - padCount));
        });
    },

    /**
     *
     * @param input
     * @param callback
     */
    macKeyStringXorEncryptAndEncode: function (input, callback) {
        if (!Buffer.isBuffer(input)) {
            input = new Buffer(input);
        }

        var padSize = (Math.ceil((this.macKey.length + input.length) / 8) * 8) - (this.macKey.length + input.length);

        var padding = new Buffer(new Array(padSize || 8));

        var rxordata = new Buffer(4);

        var buffer = Buffer.concat([this.macKey, input, padding]);

        for (var i = 0; i < buffer.length; i++) {
            var whitener = rxordata[i % rxordata.length];
            buffer[i] = buffer[i] ^ whitener;
        }

        this.createCipherSpec().cipher(buffer, function (encrypted) {
            callback(base64.encode(encrypted, null, false).toString());
        });

    },

    /**
     *
     * @param input
     * @param callback
     */
    macKeyStringXorDecryptAndDecode: function (input, callback) {
        var decoded, macKey;

        decoded = base64.decode(input, null, false);
        macKey = this.macKey;

        this.createCipherSpec().decipher(decoded, function (decrypted) {

            var rxordata, i, whitener, data;

            rxordata = new Buffer(4);

            for (i = 0; i < 4; i++) {
                rxordata[i] = decrypted[i] ^ macKey[i];
            }

            for (i = 0; i < decrypted.length; i++) {
                whitener = rxordata[i % 4];
                decrypted[i] = decrypted[i] ^ whitener;
            }

            // Ensure first 10 bytes match?
            if (!equals(decrypted, macKey, Math.floor(macKey.length / 2))) {
                throw new Error('Mac key not recovered.');
            }

            data = decrypted.slice(macKey.length, decrypted.length);
            for (i = 0; i < data.length; i++) {
                if (data[i] === 0) {
                    return callback(data.slice(0, i).toString());
                }
            }

            throw new Error('Could not recover data');

        });

    }

    /*

    encryptFiid: function (input, callback) {
        var prefix, trimmed;

        if (typeof input === 'string') {
            input = new Buffer(input);
        }

        prefix = input.slice(0,2);
        trimmed = input.slice(2);

        this.createCipherSpec().cipher(trimmed, function (encrypted) {
            callback(Buffer.concat([prefix, encrypted]));
        });
    },

    decryptFiid: function (input, callback) {
        var prefix, trimmed;

        if (typeof input === 'string') {
            input = new Buffer(input);
        }

        prefix = input.slice(0,2);
        trimmed = input.slice(2);

        this.createCipherSpec().decipher(trimmed, function (decrypted) {
            callback(Buffer.concat([prefix, decrypted]));
        });
    }

    */

};

module.exports = PPCrypto;
