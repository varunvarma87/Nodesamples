'use strict';

/**
 * Base64 encode/decoder that can use custom character sets and padding.
 * @param options available options are characterSet and noPadding flag.
 * @constructor
 */
exports.CharacterSet = {
    DEFAULT: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    PPBASE64: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-.',
    URLSAFE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    PPUUENCODING: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_-'
};

var DecodeCharacters = Object.keys(exports.CharacterSet).reduce(function (obj, key) {
    obj[exports.CharacterSet[key]] = _decodeCharacterSet(exports.CharacterSet[key]);
    return obj;
}, {});

exports.encode = function (input, charset, pad) {
    var padding, size, char3, i, result, pos;

    // Ensure arguments are clean
    input = Buffer.isBuffer(input) ? input : new Buffer(input);
    charset = charset || exports.CharacterSet.DEFAULT;
    pad = pad !== false;

    // Cache some useful values
    padding = ((3 - (input.length % 3)) % 3);

    // Optimize for non-PayPal case.
    if (charset === exports.CharacterSet.DEFAULT) {
        result = input.toString('base64');
        if (!pad && padding) {
            result = result.slice(0, -padding);
        }
        return result;
    }

    size = input.length + padding;

    result = new Buffer(size * 2);
    result.fill(0);
    pos = 0;

    for (i = 0; i <= size; i += 3) {
        //3 Characters (8bit * 3 = 24 bits) as a 24 bit int
        char3 = ((input[i] & 0xff) << 16) |
                ((input[i + 1] & 0xff) << 8) |
                ((input[i + 2] & 0xff));

        //Convert int to 4 Characters (6 bit * 4 = 24 bits)
        result[pos++] = charset.charCodeAt((char3 >> 18) & 0x3f);
        result[pos++] = charset.charCodeAt((char3 >> 12) & 0x3f);
        result[pos++] = charset.charCodeAt((char3 >> 6) & 0x3f);
        result[pos++] = charset.charCodeAt((char3 & 0x3f));

        if (i + 3 >= size) {
            pos -= (4 - (4 - padding));
        }
    }

    result = result.slice(0, pos);

    if (pad && padding) {
        if (padding === 1) {
            result.length -= 2;
        }

        if (padding === 2) {
            result[result.length - 2] = 0x3d;
        }

        result[result.length - 1] = 0x3d;
        return result;
    }

    result.length -= (4 - padding);
    return result;

};

exports.decode = function (input, charset, pad) {
    var length, padding, decodeChars, char4, i, buffer, pos;

    if (!Buffer.isBuffer(input)) {
        input = new Buffer(input);
    }

    charset = charset || exports.CharacterSet.DEFAULT;
    pad = pad !== false;

    length = input.length;
    padding = ((4 - (length % 4)) % 4);

    // Depend on native decoding, when possible.
    if (charset === exports.CharacterSet.DEFAULT) {
        input = input.toString();
        while (!pad && padding) {
            input += '=';
            padding -= 1;
        }
        return new Buffer(input, 'base64');
    }

    decodeChars = DecodeCharacters[charset] || (DecodeCharacters[charset] = _decodeCharacterSet(charset));

    // Trim off the trailing '=' padding before decode.
    if (pad && padding) {
        input.length = length - padding;
        length = input.length;
    }

    buffer = new Buffer(length);
    buffer.fill(0);
    pos = 0;

    for (i = 0; i < length; i += 4) {
        //4 Characters (6 bit * 4 = 24 bits) as 24 bit int.
        char4 = decodeChars[input[i]] << 18 |
                decodeChars[input[i + 1]] << 12 |
                decodeChars[input[i + 2]] << 6 |
                decodeChars[input[i + 3]];

        buffer[pos++] = char4 >> 16;
        buffer[pos++] = char4 >> 8;
        buffer[pos++] = char4;

        if (i + 4 >= length) {
            pos -= 3 - (3 - padding);
        }
    }

    return buffer.slice(0, pos);
};

function _decodeCharacterSet (characterSet) {
    var set = {};
    for (var i = 0; i < characterSet.length; i++) {
        set[characterSet.charCodeAt(i)] = i;
    }
    return set;
}
