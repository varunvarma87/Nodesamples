'use strict';

var types = require('./types'),
    constants = require('./constants'),
    Header = require('./header'),
    bignum = require('bn.js');

/**
 * VO binary serializer.
 * @param options
 * @constructor
 */
function Serializer(options) {
    options = options || {};

    this._buffer = new Buffer(options.bufferSize || (1024 * 10));
    this._buffer.fill(0);
    this._pos = 0;

    this.version = options.version || constants.defaultVersion;
    this.header = new Header(options);

    this._names = {};
    this._fieldTypes = {};
    this._fieldTypesLength = 0;
    this._bignums = {};
}

/**
 * Private recursive serialize function.
 * @param obj
 * @private
 */
Serializer.prototype._serialize = function _serialize(obj) {
    var fields;

    this._write(this._names[obj.name] ? types.NEW_FIELD : types.NEW_OBJ);

    this._writeFieldName(obj.name, true);

    fields = Object.keys(obj.fields);

    for (var i = 0; i < fields.length; i++) {
        this._writeField(fields[i], obj.fields[fields[i]]);
    }

    this._write(types.END_OBJ);
};

/**
 * Write the header.
 * @private
 */
Serializer.prototype._writeHeader = function () {
    var headerBytes = this.header.getBytes();

    if (headerBytes) {
        this._write(headerBytes, 4);
    }

    this._write(constants.BINARY_HEADER[0]);
    this._write(constants.BINARY_HEADER[1]);
    this._write(this.header.version);
};

/**
 * Write field name and value.
 * @param name
 * @param field
 * @private
 */
Serializer.prototype._writeField = function (name, field) {
    var type, typeName, value, id;

    type = field.type;
    value = field.value;

    typeName = type + '::' + name;

    //Lookup reference
    id = this._fieldTypes[typeName];

    if (id !== undefined) {
        this._write(types.OLD_FIELD);
        this._write(id);
        return;
    }

    //Save reference
    this._fieldTypes[typeName] = this._fieldTypesLength++;

    this._write(types.NEW_FIELD);
    this._writeFieldName(name, true);
    this._writeFieldType(type, value);
    this._writeFieldValue(type, value);
    this._write(types.END_FIELD);
};

/**
 * Writes field name or field name reference.
 * @param name
 * @param cache
 * @private
 */
Serializer.prototype._writeFieldName = function (name, cache) {
    var id;

    id = this._names[name];

    //Lookup reference
    if (id) {
        this._write(id);
        return;
    }

    else if (cache) {
        //Save reference
        this._names[name] = Object.keys(this._names).length;
    }

    this._write(types.NULL_BYTE);
    this._write(name.length);
    this._buffer.write(name, this._pos);
    this._pos += name.length;
};

/**
 * Write's the field's type.
 * OBJ-FIELD class-name | non-obj-field
 * @param type
 * @param value
 * @private
 */
Serializer.prototype._writeFieldType = function (type, value) {
    var pType = types.typeMap[type];

    var isCurrency = (pType === types.CURRENCY && !Array.isArray(value));

    if (typeof value === 'object' && !(value instanceof Buffer) && !isCurrency) {
        if (Array.isArray(value)) {
            this._write(types.ARRAY);
            if (pType !== undefined) {
                this._write(pType);
                this._write(types.NULL_BYTE);
            }
            else {
                this._write(types.OBJ_FIELD);
                this._write(types.NULL_BYTE);
                this._writeFieldName(type, true);
            }
            return;
        }
        //This is a VO
        this._write(types.OBJ_FIELD);
        this._writeFieldName(type);
    }
    else {
        this._write(types.PRIMITIVE);
        this._write(pType);
        this._write(types.NULL_BYTE);
    }
};

/**
 * Writes the field's value.
 * @param type
 * @param value
 * @private
 */
Serializer.prototype._writeFieldValue = function (type, value) {
    var pType = types.typeMap[type];

    var isCurrency = (pType === types.CURRENCY && !Array.isArray(value));

    if (typeof value === 'object' && !(value instanceof Buffer) && !isCurrency) {
        if (Array.isArray(value)) {
            this._write(value.length);
            for (var i = 0; i < value.length; i++) {
                var v = value[i];
                this._writeFieldValue(type, v);
            }
        }
        //This is a VO
        else {
            this._serialize(value);
        }
    }
    else if (pType) {
        this._writePrimitive(pType, value);
    }
    else {
        this._write(value);
    }
};

/**
 * Writes primitive types.
 * BOOLEAN | SIGNED-INT-8 | CHAR | UNSIGNED-INT-8 | SIGNED-INT-16
 * SHORT | UNSIGNED-INT-16 | USHORT | SIGNED-INT-32 | INT | LONG |
 * UNSIGNED-INT-32 | UINT | ULONG | SIGNED-INT-64 | LLONG | UNSIGNED-INT-64 |
 * ULLONG | FLOAT | DOUBLE | STRING | CURRENCY | BUFFER
 * @param pType
 * @param value
 * @private
 */
Serializer.prototype._writePrimitive = function (pType, value) {

    if (pType === types.BOOLEAN) {
        this._write(value ? 0x01 : types.NULL_BYTE);
    }
    else if (pType >= types.SINT8 && pType <= types.UINT64) {
        //Even is an int, odd a uint.
        if (pType % 2) {
            this._writeUInt(value);
        }
        else {
            this._writeInt(value);
        }
    }
    else if (pType === types.FLOAT) {
        this._buffer.writeFloatLE(value, this._pos);
        this._pos += 4;
    }
    else if (pType === types.DOUBLE) {
        this._buffer.writeDoubleLE(value, this._pos);
        this._pos += 8;
    }
    else if (pType === types.BUFFER) {
        this._writeUInt(value.length);
        value.copy(this._buffer, this._pos);
        this._pos += value.length;
    }
    else if (pType === types.STRING) {
        this._writeUInt(Buffer.byteLength(value));
        this._buffer.write(value, this._pos);
        this._pos += value.length;
    }
    else if (pType === types.CURRENCY) {
        this._writePrimitive(types.STRING, value.code);
        this._writePrimitive(types.LLONG, value.amount);
    }
};

/**
 * If negative, writes a 0xe1 byte and then calls writeUInt.
 * @param n
 * @private
 */
Serializer.prototype._writeInt = function (n) {

    if ((typeof n === 'string' && n[0] === '-') || n < 0) {
        this._write(types.NEG_SIGN);
        if (typeof n === 'string') {
            n = n.substr(1);
        }
        else {
            n *= -1;
        }
    }

    this._writeUInt(n);
};

/**
 * BigEndian
 * 0x00-0x7f : single byte
 * 0x80-0x3fff : two bytes
 * 0x4000-0x1fffffff : four bytes
 * 0x20000000-0xffffffffffffffff : writeUInt64
 * @param n
 * @private
 */
Serializer.prototype._writeUInt = function (n) {
    var i = typeof n === 'string' ? parseInt(n, 10) : n;

    if (i >= 0 && i <= 0x7f) {
        this._write(i, 1);
        return;
    }
    if (i >= 0 && i <= 0x3fff) {
        this._write(i, 2);
        return;
    }
    if (i >= 0 && i <= 0x1fffffff) {
        this._write(i, 4);
        return;
    }

    this._writeUInt64(n);
};

/**
 * BigEndian
 * 0x20000000-0xffffffffffffffff : 1 byte (prefix 0xE0) + eight bytes.
 * @param n
 * @private
 */
Serializer.prototype._writeUInt64 = function (n) {
    var buffer;

    this._write(0xe0);

    if (typeof n !== 'string') {
        n = String(n);
    }

    buffer = this._bignums[n] || (this._bignums[n] = new Buffer(new bignum(n).toArray()));

    buffer.copy(this._buffer, this._pos + (8 - buffer.length), 0, buffer.length);

    this._pos += 8;
};

/**
 * Write bytes to the given byte length.
 * @param data
 * @param bytes
 * @private
 */
Serializer.prototype._write = function (data, bytes) {
    if (!bytes) {
        bytes = 1;
    }

    if (bytes === 1) {
        this._buffer.writeUInt8(data, this._pos);
    }
    else if (bytes === 2) {
        this._buffer.writeInt16BE(data, this._pos);
        this._buffer[this._pos] |= 0x80;
    }
    else if (bytes === 4) {
        this._buffer.writeInt32BE(data, this._pos);
        this._buffer[this._pos] |= 0xc0;
    }
    else {
        return;
    }

    this._pos += bytes || 1;
};

/**
 * Publish serialize function.
 * @param obj
 * @param options
 * @returns {Buffer}
 */
Serializer.serialize = function serialize(obj, options) {
    var serializer = new Serializer(options);

    serializer._writeHeader();

    serializer._serialize(obj);

    return serializer._buffer.slice(0, serializer._pos);
};

module.exports = Serializer;
