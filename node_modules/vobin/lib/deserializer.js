'use strict';

var types = require('./types'),
    constants = require('./constants'),
    bignum = require('bn.js'),
    assert = require('assert');

/**
 * VO binary deserializer.
 * @param data
 * @constructor
 */
function Deserializer(data) {
    this._pos = 0;
    this._data = data || new Buffer(0);
    this._names = [];
    this._fieldTypes = [];
}

/**
 * Begin read.
 * @returns {*}
 * @private
 */
Deserializer.prototype._read = function () {
    var header = this._readHeader();

    assert(header[0] === constants.BINARY_HEADER[0] && header[1] === constants.BINARY_HEADER[1] && header[2] === 1);

    return this._readObject();
};

/**
 * Reads the serialized header / format.
 * @returns {*}
 * @private
 */
Deserializer.prototype._readHeader = function () {
    var header;

    //If it looks like a universal header, emit the 4 header bytes
    if (this._data[this._pos] === constants.UNIVERSAL_HEADER_BYTE) {
        header = this._data.slice(this._pos, this._pos += 4);
    }
    //Binary header flag and version
    else {
        header = this._data.slice(this._pos, this._pos += 3);
    }
    return header;
};

/**
 * Read the object.
 * @returns {{}}
 * @private
 */
Deserializer.prototype._readObject = function () {
    var obj = {};

    if (this._data[this._pos++] === types.NEW_OBJ) {

        obj.name = this._readFieldName();

        obj.fields = {};

        while (this._data[this._pos] !== types.END_OBJ) {
            var field = this._readField();

            obj.fields[field.name] = {
                type: field.type,
                value: field.value
            };

            this._pos++;
        }
    }
    else {
        throw new Error('Expected new Object.');
    }

    this._pos++;

    return obj;
};

/**
 * Read field name, type, value.
 *
 * @returns {{}}
 * @private
 */
Deserializer.prototype._readField = function () {
    var field, meta, metaType, id;

    field = {};

    meta = this._data[this._pos++];

    if (meta === types.OLD_FIELD) {
        id = this._data[this._pos++] - 1;

        field.name = this._fieldTypes[id].name;

        field.type = this._fieldTypes[id].type;

        metaType = this._fieldTypes[id].metaType;
    }
    else if (meta !== types.NEW_FIELD) {
        throw new Error('Expected an old or new Field.');
    }
    else {
        field.name = this._readFieldName();

        metaType = this._data[this._pos++];

        field.type = this._readFieldType(metaType);

        //Store reference
        this._fieldTypes.push({
            name: field.name,
            type: field.type,
            metaType: metaType
        });
    }

    if (metaType === types.OBJ_FIELD) {
        field.value = this._readObject();
    }
    else if (metaType === types.ARRAY) {
        var length = this._data[this._pos++];

        field.value = [];

        for (var i = 0; i < length; i++) {
            if (types.isVO(field.type)) {
                field.value.push(this._readObject());
            }
            else {
                field.value.push(this._readFieldValue(types.typeMap[field.type]));
            }

        }
    }
    else {
        field.value = this._readFieldValue(types.typeMap[field.type]);
    }

    if (this._data[this._pos] !== types.END_FIELD) {
        throw new Error('Expected end of Field, Found: ' + this._data[this._pos]);
    }

    return field;
};

/**
 * Read field name or object type name.
 * @returns {*}
 * @private
 */
Deserializer.prototype._readFieldName = function () {
    var name;

    //Read reference
    if (this._data[this._pos] !== types.NULL_BYTE) {
        var id = this._data[this._pos++] - 1;
        name = this._names[id];
    }
    else {
        this._pos++;
        var length = this._data[this._pos++];
        name = this._data.slice(this._pos, this._pos += length).toString();
        //Save reference
        this._names.push(name);
    }

    return name;
};

/**
 * Reads field types.
 * OBJ-FIELD class-name | non-obj-field
 * @param meta
 * @returns {*}
 * @private
 */
Deserializer.prototype._readFieldType = function (meta) {
    var fieldName;

    if (meta === types.OBJ_FIELD) {
        fieldName = this._readFieldName();
    }
    else if (meta === types.ARRAY || meta === types.PRIMITIVE) {
        var type = types.typeReverseMap[this._data[this._pos++]];

        this._pos++; //Skip null byte

        if (type !== undefined) {
            fieldName = type;
        }
        else {
            fieldName = this._readFieldName();
        }
    }
    return fieldName;
};

/**
 * Read field primitive types.
 * @param pType
 * @returns {*}
 * @private
 */
Deserializer.prototype._readFieldValue = function (pType) {
    var value, length;

    if (pType === types.BOOLEAN) {
        value = this._data[this._pos++];
    }
    else if (pType >= types.SINT8 && pType <= types.UINT64) {
        //Even is an int, odd a uint.
        value = pType % 2 ? this._readUInt(pType) : this._readInt(pType);
    }
    else if (pType === types.FLOAT) {
        value = this._readFloat(1);
    }
    else if (pType === types.DOUBLE) {
        value = this._readFloat(2);
    }
    else if (pType === types.STRING) {
        length = this._readUInt();
        value = this._data.slice(this._pos, this._pos += length).toString();
    }
    else if (pType === types.BUFFER) {
        length = this._readUInt();
        value = this._data.slice(this._pos, this._pos += length);
    }
    else if (pType === types.CURRENCY) {
        value = this._readCurrency();
    }

    return value;
};

/**
 * Read currency object.
 * @returns {*}
 * @private
 */
Deserializer.prototype._readCurrency = function () {
    var obj = {
        code: this._readFieldValue(types.STRING),
        amount: this._readFieldValue(types.LLONG)
    };

    return obj;
};

/**
 * Read signed integer byte and then readUInt.
 * @param size
 * @returns {*}
 * @private
 */
Deserializer.prototype._readInt = function (size) {

    if (this._data[this._pos] === types.NEG_SIGN) {
        this._pos++;
        var n = this._readUInt(size);
        if (typeof n === 'string') {
            n = '-' + n;
        }
        else {
            n *= -1;
        }
        return n;
    }
    else {
        return this._readUInt(size);
    }
};

/**
 * Reads a uint of the given size. Will also take into account values that were serialized into smaller types.
 * @param size
 * @returns {*}
 * @private
 */
Deserializer.prototype._readUInt = function (size) {
    var bitSize, b, data;

    b = this._data[this._pos];

    if (b === 224) {
        bitSize = 64;
    }
    //Figure out where this fits.
    else {
        for (var i = 128; i >= 32; i = i / 2) {
            if (!(b & i)) {
                bitSize = ((128 / i) * 8);
                break;
            }
        }
    }

    if (bitSize === 64) {
        this._pos++;
        data = new bignum(this._data.slice(this._pos, this._pos += 8)).toString();
    }
    else if (bitSize === 32) {
        this._data[this._pos] &= 0x1f;
        data = this._data.readUInt32BE(this._pos);
        this._pos += 4;
    }
    else if (bitSize === 16) {
        this._data[this._pos] &= 0x3f;
        data = this._data.readUInt16BE(this._pos);
        this._pos += 2;
    }
    else {
        data = this._data.readUInt8(this._pos++);
    }

    if (size === types.UINT64) {
        data = data.toString();
    }
    else if (typeof data === 'string') {
        data = parseInt(data, 10);
    }

    return data;
};

/**
 * Read float and double LE.
 * @param size
 * @returns {*}
 * @private
 */
Deserializer.prototype._readFloat = function (size) {
    var data, fn;

    if (!size) {
        size = 1;
    }

    if (size === 1) {
        data = this._data.readFloatLE(this._pos);
    }
    else {
        data = this._data.readDoubleLE(this._pos);
    }

    this._pos += (4 * size);

    return data;
};

/**
 * Public deserialize function.
 * @param data
 * @returns {*}
 */
Deserializer.deserialize = function (data) {
    var deserializer = new Deserializer(data);

    return deserializer._read();
};

module.exports = Deserializer;
