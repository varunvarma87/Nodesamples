/**
 *
 * PayPal Experimentation for Node.js
 * Depends on appName, ts cookie and user
 *
 */
'use strict';

var async = require('async'),
    querystring = require('querystring'),
    servicecore = require('servicecore'),
    PxpService = require('./pxpService'),
    deployEnv = require('environment-paypal'),
    modConfig = require('module-config-paypal'),
    experimentationModel = require('./experimentationModel');

var expService,
    pxpExecService,
    expModuleConfig,
    expServiceConfig;

servicecore.register('experimentation', PxpService);
servicecore.register('experimentation-paypal', PxpService);

var usePxpExecServ = false,
    MAX_CONTINUOUS_ERROR_ALLOWED = 5,
    CIRCUIT_BREAK_TIME = 30 * 60 * 1000,
    errorCounter = 0;

function circuitBreakerTimer() {
    setTimeout(function () {
        usePxpExecServ = true;
    }, CIRCUIT_BREAK_TIME);
}

function addAnalyticsData(req) {
    var tracking = req.tracking,
        experimentation = req.experimentation,
        ts = req.ts || {};

    if (!tracking || !experimentation) {
        return;
    }

    if (experimentation.guid && !ts.vr) {
        tracking.addData('pxpguid', '', experimentation.guid);
    }
}

function _pxp(req, params, isMiddleware, next) {

    var ts = req.ts || {},
        user = req.user || {},
        uId = user.encryptedAccountNumber,
        locality = req.locality || {},
        data,
        queryStr,
        headers = {},
        sessionExp = req.session && req.session.experimentation,
        sessionExpTs = req.session && req.session.experimentationTimeStamp,
        sessionExpFresh = false,
        guidOverride;

    if (req.headers) {
        //Passing User-Agent header to pxp server
        //Servicecore will add PP_REMOTE_ADDR and calCorrelation as well
        headers['User-Agent'] = req.headers['User-Agent'] || req.headers['user-agent'];
    }

    if (deployEnv.isNotLive()) {
        // Non-live guid override
        guidOverride = req.query && req.query._guid;
    }

    if (deployEnv.isSandbox()) {
        //disabling Experimentation in sandbox as it's not deployed/configured
        experimentationModel(req, null);
        return next();
    }

    if (sessionExpTs) {
        sessionExpFresh = (Date.now() - sessionExpTs) > expModuleConfig.sessionLifetime;
    }

    if (!guidOverride && expModuleConfig.useSession &&
        sessionExp && typeof sessionExp === 'object' &&
        Object.keys(sessionExp).length && !sessionExpFresh) {

        experimentationModel(req, req.session.experimentation);
        addAnalyticsData(req);
        if (isMiddleware) {
            next();
        } else {
            next(null, req.experimentation);
        }
    } else {

        data = {
            app : req.appName || 'nodejs',
            guid : guidOverride || ts.vr,
            sid : ts.vt,
            uid : uId,
            locale : locality.locale || 'en_US'
        };

        data['Ctx.IP'] = req.headers && req.headers.pp_remote_addr || req.ip;
        if (req.cookies && req.cookies.pxp) {
            data['Ctx.pxpcookie'] = req.cookies.pxp;
        }

        if (params && typeof params === 'object') {
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    data[key] = params[key];
                }
            }
        }

        queryStr = querystring.stringify(data);

        var error, serviceResponse;

        //Temporarily has a fallback logic to old service if pxpExecService fails
        async.series({
            pxpExec: function (cb) {
                if (!usePxpExecServ) {
                    cb();
                    return;
                }
                pxpExecService.callPxp(queryStr, headers, function (err, pxpExecRes) {
                    error = err;
                    serviceResponse = pxpExecRes;
                    if (error || pxpExecRes && pxpExecRes.statusCode !== 200) {
                        errorCounter++;
                        if (errorCounter >= MAX_CONTINUOUS_ERROR_ALLOWED) {
                            usePxpExecServ = false;
                            errorCounter = 0;
                            circuitBreakerTimer();
                        }
                    } else {
                        errorCounter = 0;
                    }
                    cb();
                });
            },
            pxp: function (cb) {
                if (!error && serviceResponse && serviceResponse.statusCode === 200) {
                    cb();
                    return;
                }
                expService.callPxp(queryStr, headers, function (err, pxpRes) {
                    error = err;
                    serviceResponse = pxpRes;
                    cb();
                });
            }
        }, function () {
            if (error || !(serviceResponse && serviceResponse.statusCode === 200)) {
                experimentationModel(req, null);
                if (isMiddleware) {
                    next();
                } else {
                    next(error, null);
                }
                return;
            }
            var body = serviceResponse && serviceResponse.body;
            experimentationModel(req, body);
            addAnalyticsData(req);
            if (isMiddleware) {
                if (expModuleConfig.useSession && req.session) {
                    req.session.experimentation = body;
                    req.session.experimentationTimeStamp = Date.now();
                }
                next();
            } else {
                next(null, req.experimentation);
            }
        });
    }
}

/**
 * Initialize config
 */
function _init() {
    var config;

    if (!expModuleConfig || !expServiceConfig || !expService || !pxpExecService) {
        config = modConfig(module);
        expModuleConfig = config.get('experimentation');
        expServiceConfig = config.get('services:experimentation');
        usePxpExecServ = expModuleConfig.usePxpExecServ;

        expService = servicecore.create('experimentation', expServiceConfig);
        pxpExecService = servicecore.create('experimentation-paypal');
    }
}

/**
 * experimentation middleware
 */
module.exports = function nodeExperimentation(options) {
    options = options || {};
    var params = {};

    var isMiddlewareEnabled = true;
    if (typeof options.isMiddleware !== 'undefined') {
        isMiddlewareEnabled = !!options.isMiddleware;
    }
    _init();

    if (options.pg) {
        params.pg = options.pg;
    }
    if (options.beta) {
        params.beta = options.beta;
    }
    if (options.factors) {
        params.factors = options.factors;
    }

    return function experimentation(req, res, next) {
        if (isMiddlewareEnabled) {
            _pxp(req, params, true, next);
        } else {
            next();
        }
    };
};

module.exports.middleware = module.exports;

/**
 * For calling experimentation directly from controller
 */
module.exports.pxp = function (req, params, callback) {
    _init();
    _pxp(req, params, false, callback);
};

/**
 * OPTIN: To optin an user into a given treatment.
 * OPTOUT: To optout an user from given treatment.
 * User is identified with uid (encrypted account number)
 */
module.exports.optInOrOut = function (req, params, callback) {
    _init();

    if (!params || !(params.treatmentControlName || params.treatment_name) || !params.method) {
        var err = new Error('treatmentName and method are required params');
        return callback(err, null);
    }

    var body = {
            uid: req.user && req.user.encryptedAccountNumber,
            treatment_name: params.treatment_name || params.treatmentControlName
        },
        endpoint,
        headers   = {};

    if (params.site) {
        body.site = params.site;
    }

    endpoint = '/' + params.method;

    headers['Content-Type'] = 'application/json';

    expService.optInOrOut(endpoint, body, headers, function (error, response) {
        if (error || response && response.statusCode !== 200) {
            callback(error, response);
        } else {
            callback(null, response);
        }

    });
};
