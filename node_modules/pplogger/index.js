'use strict';


var cal = require('cal'),
    url = require('url'),
    HeartBeats = require('./lib/heartbeats'),
    Logger = require('./lib/logger'),
    Profiler = require('./lib/profiler'),
    measured = require('measured'),
    onFinished = require('on-finished');

var stats = measured.createCollection(),
    payloadHg = new measured.Histogram();

// Matches any number and any alphanumeric but no string
// Used to strip out any such element from logging
var AlphaNumericTokenRegEx = /(([0-9]+[a-z]+)|([a-z]+[0-9]+)|([0-9]+))+[0-9a-z]+/ig;

function buildReqInfo(req) {
    var reqInfo = {
            'pp_remote_addr': req.headers.pp_remote_addr,
            'corr_id_': req.correlationId,
            'user-agent': req.headers['user-agent'],
            'method': req.method
        };

    if (req.headers['x-client-ip']) {
        reqInfo['x-client-ip'] = req.headers['x-client-ip'];
    }
    if (req.headers['x-real-ip']) {
        reqInfo['x-real-ip'] = req.headers['x-real-ip'];
    }
    if (req.headers['x-pp-corrid']) {
        reqInfo['x-pp-corrid'] = req.headers['x-pp-corrid'];
    }
    if (req.headers['x-forwarded-for']) {
        reqInfo['x-forwarded-for'] = req.headers['x-forwarded-for'];
    }
    if (req.headers['x-pp-slingshot-targetapp']) {
        reqInfo['x-pp-slingshot-targetapp'] = req.headers['x-pp-slingshot-targetapp'];
    }
    if (req.headers['x-pp-silover']) {
        reqInfo['x-pp-silover'] = req.headers['x-pp-silover'];
    }
    if (req.headers['x-forwarded-host']) {
        reqInfo['x-forwarded-host'] = req.headers['x-forwarded-host'];
    }
    if (req.headers['content-length']) {
        reqInfo['content-length'] = req.headers['content-length'];
    }
    if (req.headers['content-type']) {
        reqInfo['content-type'] = req.headers['content-type'];
    }

    return reqInfo;
}

function logReqInfo(req, reqInfo) {
    if (!reqInfo) {
        reqInfo = buildReqInfo(req);
    }

    if (req.sessionID) {
        reqInfo.sessionID = req.sessionID;
    }

    var calEvt = cal.createEvent('URL', 'HEADER');
    calEvt.correlationId = req.correlationId;
    calEvt.addData(reqInfo);
    calEvt.complete();
}

function middleware(config) {
    var logger = new Logger(config),
        profiler = new Profiler(config);

    //This will emit heartbeats every 1min.
    var heartbeats = new HeartBeats(config, stats, payloadHg);

    return function pplogger(req, res, next) {
        var pathname = req.originalUrl ? url.parse(req.originalUrl).pathname : req.path,
            path = pathname && pathname.substring(1) || 'index',
            routeTimer,
            render = res.render,
            redirect = res.redirect,
            json = res.json,
            jsonp = res.jsonp,
            end = res.end,
            send = res.send,
            rootTxn,
            templateName,
            renderStartTime;

        req.headers = req.headers || {};

        var reqInfo = buildReqInfo(req);

        path = path.replace(AlphaNumericTokenRegEx, 'xxx');

        routeTimer = profiler.txnTimeStart(req, path, { clientIP: req.headers.pp_remote_addr }, 'URL');

        stats.meter('rps').mark();
        if (req.headers['content-length']) {
            payloadHg.update(parseInt(req.headers['content-length'], 10));
        }

        // Add request methods
        req.log = function (level, data) {
            var logFn;
            if (!data) {
                data = level;
                level = 'info';
            }
            level = level.toLowerCase();
            logFn = logger[level] || logger.info;
            var fn = logFn.bind(logger);
            fn && fn(data);
        };

        /**
         *  name - event name
         *  data - data payload
        **/
        req.time = function (name, data) {
            profiler.time(req, name, data);
        };

        /**
         *  name - event name
         *  data - data payload
         *  error - error (if any)
         *  status  - 1 (CAL::TRANS_FATAL) ON FATAL ERRORS
         *          - 2 on BUSINESS REJECTIONS (CAL::TRANS:ERROR)
         *          - 0 otherwise
        **/
        req.timeEnd = function (name, data, error, status) {
            profiler.timeEnd(req, name, data, error, status);
        };


        req.profile = function (obj, methods) {
            if (!methods) {
                methods = Object.keys(obj);
            }

            if (!Array.isArray(methods)) {
                methods = [ methods ];
            }

            methods.forEach(function (method) {
                profiler.profile(req, obj, method);
            });
        };

        onFinished(res, function (err, res) {
            var calStatus = 0,
                calData = {
                    statusCode: res.statusCode,
                };

            logReqInfo(req, reqInfo);

            /* Hacker attacks are fended off with a 403, 404; the response status needs to be 2 (indicating malformed request)
             This is needed to prevent Sherlock and other monitoring tools aggregating the event data and
             reporting them as system error events which they clearly aren't.
             */
            if ([401, 403, 404].indexOf(res.statusCode) !== -1) {
                calStatus = 2;
            }
            else if (res.statusCode >= 400) {
                calStatus = 1;
            }

            if (!rootTxn) {
                rootTxn = req.model && req.model.rootTxn;
            }

            if (rootTxn) {
                rootTxn.data = rootTxn.data || {};
                rootTxn.data.url = rootTxn.data.url || req.originalUrl;

                if (rootTxn.data.url && rootTxn.data.url.indexOf('?') !== -1) {
                    rootTxn.data.url = rootTxn.data.url.replace(/=[\w@\-.]+/g, '=..');
                }
            }
            rootTxn = rootTxn || {};

            routeTimer.updateName(rootTxn.name);
            routeTimer.end(rootTxn.data, calData, rootTxn.status || calStatus);
        });

        res.end = function () {
            var _arguments = arguments;

            if (req.session && !req.isSessionAlreadySaved) {
                //if session, then save first and then end the request
                req.session.save(function (err) {
                    end.apply(res, _arguments);
                });
            } else {
                end.apply(res, _arguments);
            }
        };

        res.send = function () {
            var calEvt,
                calData;

            if (renderStartTime) {
                calData = {
                    statusCode: res.statusCode
                };

                calEvt = cal.createTransaction('RENDER', templateName);
                calEvt.duration = Date.now() - renderStartTime;
                calEvt.correlationId = req.correlationId;
                calEvt.addData(calData);
                calEvt.complete();
            }

            send.apply(res, arguments);
        };

        // Override response methods
        res.render = function (template, data, callback) {
            renderStartTime = Date.now();
            templateName = template;
            rootTxn = data && data.rootTxn;

            // Perform data model or session dumping if requested and if debugInfo flag is enabled
            if (req.showDebugInfo) {
                var mode = req.query._mode;
                if (mode === 'json' || mode === 'session') {
                    if (mode === 'session') {
                        data = req.session;
                    }
                    res.json(data);
                    return null;
                }
            }
            render.apply(res, arguments);
        };

        res.json = function (data) {
            rootTxn = data && data.rootTxn;
            json.apply(res, arguments);
        };

        res.jsonp = function (data) {
            rootTxn = data && data.rootTxn;
            jsonp.apply(res, arguments);
        };

        next();
    };
}

module.exports = middleware;
