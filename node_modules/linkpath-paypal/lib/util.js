'use strict';


var slice = Array.prototype.slice;


/**
 * Uses or creates nested objects/properties to match the provided namespace.
 * @returns {*}
 */
exports.namespace = function namespace(/*obj, props...*/) {
    var args, dest, prop;

    args = clone(arguments);
    dest = args.shift();

    while (args.length) {
        prop = args.shift();
        dest = dest[prop] || (dest[prop] = {});
    }

    return dest;
};


/**
 * Concatenates URL path segments
 * @returns {string}
 */
exports.join = function join(/* segments */) {
    var idx, dest, concat;

    idx = arguments.length;
    dest = '';

    concat = exports.maybe(function concat(segment) {
        dest = dest ? (segment + '/' + dest) : segment;
    });

    while (idx) {
        idx -= 1;
        concat(arguments[idx]);
    }

    return dest;
};


/**
 * Simple array cloning
 * @param arr
 * @returns {Array}
 */
function clone(arr) {
    return slice.call(arr);
}


/**
 * Executes the provided fn in all arguments are defined.
 * XXX: This implementation won't work for functions with
 * variable arguments.
 * @param fn
 * @returns {Function}
 */
exports.maybe = function maybe(fn) {
    return function () {
        var i;

        if (!(i = arguments.length) || fn.length !== arguments.length) {
            return void 0;
        }

        while (i) {
            i -= 1;
            if (arguments[i] === null || arguments[i] === undefined) {
                return void 0;
            }
        }

        return fn.apply(undefined, arguments);
    };
};
