'use strict';

var fs = require('fs'),
    path = require('path'),
    biblio = require('./bibliography'),
    yamlUtil = require('js-yaml'),
    extend = require('extend'),
    aggregate = require('./layout-aggregator'),
    objutil = require('./util/objutil');

exports = module.exports = function configure(appname) {

    var yamlObj = {},
        deps,
        serviceConn,
        layouts = {},
        connections = [],
        connection,
        serviceName;

    //Initialize the yaml data
    yamlObj.application = appname;
    yamlObj.configtemplate = biblio.file.layouttemplaterel; //Use relative path
    yamlObj.output = biblio.file.layoutrel; //Use relative paths
    yamlObj.connections = {};

    //create a temp <AppRoot>/cdbs folder
    if (!fs.existsSync(biblio.dir.cdbs)) {
        fs.mkdirSync(biblio.dir.cdbs);
    }

    layouts = aggregate();

    var collapsedKeys = objutil.collapse(layouts);
    Object.keys(collapsedKeys).forEach(function (collapsedKey) {
        if (collapsedKey.indexOf('.') !== -1) {
            var conn = collapsedKey.split('.').slice(0, -1).join(':');
            if (connections.indexOf(conn) === -1) {
                connections.push(conn);
            }
        } else {
            connections.push(collapsedKey);
        }
    });

    connections.forEach(function (connName) {

        deps = { dependency : 'optional' };
        connection = getConn(layouts, connName);

        serviceConn = new ServiceConn(connection);
        //Retrieve the service name
        serviceName = serviceConn.getServiceName();

        //Set the Coverted format back to layout.json
        setConn(layouts, connName, serviceConn.getServiceConnection(), serviceName);

        if (serviceName) {
            //Set all the connections for nodejs as required.
            deps.dependency = "required";
            yamlObj.connections[serviceName] = deps;
        }
    });

    //Write to the cdbs/layout.json file.
    fs.writeFileSync(biblio.file.layouttemplate, JSON.stringify(layouts, null, 4), 'utf8');
    console.log("Aggregated layout.json template file - " + biblio.file.layouttemplate + " - created successfully");
    //Write to the service-manifest.yaml file.
    var yaml = yamlUtil.safeDump(yamlObj);
    fs.writeFileSync(biblio.file.manifest, yaml);
    console.log(biblio.file.manifest, ' created successfully');
};

function getVal(obj, key) {
    return obj[key];
}

function getConn(connection, connName) {

    var obj = connection,
        key = connName;
    if (key.indexOf(':') !== -1) {
        key.split(':').forEach(function (k) {
            obj = getVal(obj, k);
        });
    } else {
        obj = getVal(obj, key);
    }
    return obj;
}

function setConn(connection, connName, val, serviceName) {

    var jsonEl = connection,
        key = connName;

    if (key.indexOf(':') !== -1) {
        var keys = key.split(':'),
            jsonElKey;
        key = keys.pop();
        if (keys && keys.length > 1) {
            jsonElKey = keys.join(":");
        } else {
            jsonElKey = keys[0];
        }
        jsonEl = getConn(jsonEl, jsonElKey);
    }
    jsonEl[key] = val;
    // If the Key is a Template string, use the resolved service name instead.
    if (/%\{.*\}$/gi.test(connName)) {
        delete jsonEl[key];
        jsonEl[serviceName] = val;
    }
}

function ServiceConn(serviceConn) {
    this.connection = serviceConn;
    //Use the servicename property first
    this.serviceName = serviceConn.servicename;
    this._convert();
}

ServiceConn.prototype = {

    connStart : "{{",
    connEnd : "}}",

    getServiceName : function () {
        return this.serviceName;
    },
    getServiceConnection : function () {
        return this.connection;
    },
    _convert : function () {
        //Convert the Port
        this._mapper("port", ".port");

        //Convert the Hostname
        this._mapper("hostname", ".host");
        this._mapper("host", ".host");

        //convert the url
        this._mapper("url", ".host");

        //Convert the ipport
        this._mapper("ipport", "|netstring");
    },
    _match : function (value) {
        return ! /^\{\{.*\}\}$/gi.test(value) && /^%\{.*\}$/gi.test(value);
    },
    _trim : function (value) {
        var val = value;

        if (/^\{\{.*\}\}$/gi.test(val)) {
            val = val.replace(/^\{\{/gi, "").replace(/\}\}$/gi, "");

        } else if (/^%\{.*\}$/gi.test(val)) {
            val = val.replace(/^%\{/gi, "").replace(/\}$/gi, "");
        }
        return val;
    },
    _constructServiceName : function (value) {
        var servicename = this._trim(value);
        var arr = servicename.split('_');
        if (arr && arr.length > 1) {
            //Remove the last element
            arr.pop();
            //Combine it
            servicename = arr.join('_');
        }

        return servicename;
    },
    _mapper : function (key, subst) {

        if (this.connection[key] && this._match(this.connection[key])) {
            if (!this.serviceName) {
                this.serviceName = this._constructServiceName(this.connection[key]);
            }
            this.connection[key] = this.connStart + this.serviceName.replace('-', '_') + subst + this.connEnd;
        }
    }
};
