/*global describe: false, it: false, before: false, after: false*/
'use strict';


var objutil = require('../lib/util/objutil'),
    assert = require('chai').assert;


describe('objutil', function () {

    var obj = {
        'foo': {
            'bar': 'bar',
            'baz': 'baz'
        },
        'bam': 'bam',
        'hello': ['is', 'it', 'me', 'you\'re', 'looking', 'for?'],
        'you': null
    };


    describe('walk', function () {

        it('should visit all properties', function (next) {
            var props, obj, key;

            props = [];
            obj = {
                'foo': 'foo',
                'bar': 'bar',
                'baz': 'baz'
            };

            function onprop(obj, key, prop, value) {
                props.push(prop);
            }

            objutil.walk(obj, key, onprop);
            assert.strictEqual(props.length, 3);
            assert.ok(~props.indexOf('foo'));
            assert.ok(~props.indexOf('bar'));
            assert.ok(~props.indexOf('baz'));
            next();
        });


        it('should traverse child objects', function (next) {
            var props, obj, key;

            props = [];
            obj = {
                'foo': {
                    'bar': 'bar',
                    'baz': {
                        'call': 'me',
                        'maybe': false
                    }
                },
                'bam': 'bam'
            };

            function onprop(obj, key, prop, value) {
                props.push(prop);
            }

            objutil.walk(obj, key, onprop);
            assert.strictEqual(props.length, 4);
            assert.ok(~props.indexOf('bar'));
            assert.ok(~props.indexOf('call'));
            assert.ok(~props.indexOf('maybe'));
            assert.ok(~props.indexOf('bam'));
            next();
        });


        it('should ignore non-object types', function (next) {
            var props, obj, key;

            props = [];
            obj = {
                'foo': {
                    'bar': 'bar',
                    'baz': 'baz'
                },
                'bam': 'bam',
                'hello': ['is', 'it', 'me', 'you\'re', 'looking', 'for?'],
                'you': null,
                'me': undefined
            };

            function onprop(obj, key, prop, value) {
                props.push(prop);
            }

            objutil.walk(obj, key, onprop);
            assert.strictEqual(props.length, 3);
            assert.ok(~props.indexOf('bar'));
            assert.ok(~props.indexOf('baz'));
            assert.ok(~props.indexOf('bam'));
            next();
        });

    });


    describe('collapse', function () {

        var data = {
            foo: 'foo',
            bar: {
                baz: 'baz',
                bam: 'bam',
                call: {
                    me: 'maybe'
                }
            },
            is: null,
            it: undefined,
            me: ['you\'re', 'looking', 'for?'],
            amount: 0,
            qty: false
        };

        it('should flatten an object hierarchy to namespaced key-value pairs', function (next) {
            var dest, flattened;

            dest = {};
            flattened = objutil.collapse(data, dest);

            assert.isObject(flattened);
            assert.strictEqual(flattened, dest);
            assert.strictEqual(dest.foo, data.foo);
            assert.strictEqual(dest['bar.baz'], data.bar.baz);
            assert.strictEqual(dest['bar.bam'], data.bar.bam);

            assert.isUndefined(dest['bar.call']);
            assert.strictEqual(dest['bar.call.me'], data.bar.call.me);

            // null, undefined, and arrays are ignored
            assert.isUndefined(dest.is);
            assert.isUndefined(dest.it);
            assert.isUndefined(dest.me);
            next();
        });

    });


    describe('unpack', function () {

        var data = {
            'foo': 'foo',
            'bar.baz': 'baz',
            'bar.bam': 'bam',
            'bar.call.me': 'maybe',
            'amount': 0,
            'qty': false
        };

        it('should unpack a flattened obj hierarchy', function (next) {
            var unpacked = objutil.unpack(data);

            assert.isObject(unpacked);
            assert.strictEqual(unpacked.foo, data.foo);

            assert.isObject(unpacked.bar);
            assert.strictEqual(unpacked.bar.baz, 'baz');
            assert.strictEqual(unpacked.bar.bam, 'bam');

            assert.isObject(unpacked.bar.call);
            assert.strictEqual(unpacked.bar.call.me, 'maybe');

            assert.strictEqual(unpacked.amount, data.amount);
            assert.strictEqual(unpacked.qty, data.qty);
            next();
        });

    });
});