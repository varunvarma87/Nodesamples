'use strict';

var util = require('util'),
    cal = require('cal'),
    path = require('path'),
    async = require('async'),
    Mayfly = require('mayfly'),
    tryRequire = require('try-require'),
    expressSession = require('express-session');

var CAL_TRANSACTION_TYPE = 'CALL_A';

function getAppName() {
    var root = process.cwd(),
        pkgJson = tryRequire(path.join(root, 'package'));
    var appName = pkgJson && pkgJson.name || 'nodeapp';
    return appName;
}

function createEmptySession(options) {
    var session = {};
    var cookie = options.cookie || {};
    session.cookie = new expressSession.Cookie(cookie);
    return session;
}

function getSharedKey(id) {
    return id;
}

function mayflyRead(self, key, isShared, callback) {
    var data = null;

    var calTrans;

    calTrans = cal.createTransaction(CAL_TRANSACTION_TYPE, 'MayflyGet');
    calTrans.status = cal.Status.SUCCESS;

    self._mayfly.read(key, function (error, response) {
        calTrans.addData('key', key);

        if (response.version !== 0 && response.data) {
            try {
                data = JSON.parse(response.data);
                if (!isShared) {
                    data._isNewSession = response.version === 1;
                    data._sessionLen = response.data.length;
                    calTrans.addData('revisionNo', response.version || 0);
                    calTrans.addData('messageSizeRecieved', data._sessionLen);
                }
            } catch (e) {
                error = e;
                data = null;
            }
        }

        if (error || (response.status && response.status !== 0)) {
            if (error) {
                //set CAL error status only if service error
                calTrans.status = cal.Status.ERROR;
            } else if (response.status && response.status === 3) {
                //No Key in mayfly sesion
                error = 'no session key';
                if (isShared) {
                    data = {};
                } else {
                    data = createEmptySession(self._options);
                }
            } else {
                error = 'mayfly error code: ' + response.status;
                data = null;
            }
            calTrans.addData('error', error);
        }
        calTrans.complete();
        //swallowing error after logging it to cal.
        callback(null, data);
    });
}

function mayflySet(self, key, sessionObject, callback) {
    var payload = JSON.stringify(sessionObject),
        sessionSize = payload.length,
        calTrans;

    if (sessionSize <= 2) {
        // Don't save empty session
        return callback(null, false);
    }

    calTrans = cal.createTransaction(CAL_TRANSACTION_TYPE, 'MayflySet');
    calTrans.status = cal.Status.SUCCESS;

    self._mayfly.set(key, payload, function (error, response) {
        calTrans.addData('key', key);
        calTrans.addData('revisionNo', response.version);
        calTrans.addData('messageSizeSent', sessionSize);

        if (error) {
            calTrans.addData('error', error);
            calTrans.status = cal.Status.ERROR;
        }
        calTrans.complete();
        //swallowing error after logging it to cal.
        callback(null, !!response.version);
    });
}

function mayflyDestroy(self, key, callback) {

    var calTrans;

    calTrans = cal.createTransaction(CAL_TRANSACTION_TYPE, 'MayflyDestroy');
    calTrans.status = cal.Status.SUCCESS;

    self._mayfly.destroy(key, function (error, response) {

        calTrans.addData('key', key);

        if (error) {
            calTrans.addData('error', error);
            calTrans.status = cal.Status.ERROR;
        }
        calTrans.complete();
        //swallowing error after logging it to cal.
        callback(null, {});
    });
}

module.exports = function ConnectMayfly(app) {

    /**
     * Express's session store
     */
    var Store = app.Store || app.session.Store;

    function MayflyStore(options) {
        options = options || {};
        this._options = options;

        MayflyStore.super_.call(this, options);

        this._sharedSession = options.sharedSession || false;
        this._prefix = getAppName() + ':';
        this._mayfly = new Mayfly(options);
    }

    util.inherits(MayflyStore, Store);

    /**
     * Gets session data
     * @param id
     * @param callback
     */
    MayflyStore.prototype.get = function get(id, callback) {

        var self = this,
            sharedKey = getSharedKey(id),
            key = self._getKey(id),
            _sharedSession = this._sharedSession,
            data = null;

        async.parallel({
            shared: function sharedGet(next) {
                if (_sharedSession) {
                    mayflyRead(self, sharedKey, true, next);
                } else {
                    next();
                }
            },
            app: function appGet(next) {
                mayflyRead(self, key, false, next);
            }
        }, function (err, results) {
            data = results.app || createEmptySession(self._options);
            data._shared = results.shared || {};
            if (data._shared._csrfSecret) { // shared _csrfSecret token
                data._csrfSecret = data._shared._csrfSecret;
            }
            data._isSavedAlready = false;
            callback(null, data);
        });

    };


    /**
     * Sets or updates a session
     * @param id
     * @param session
     * @param callback
     */
    MayflyStore.prototype.set = function set(id, session, callback) {
        var self = this,
            sharedKey = getSharedKey(id),
            key = self._getKey(id),
            _sharedSession = this._sharedSession,
            sharedSession = session._shared || {};

        if (session._isSavedAlready) {
            return callback(null, true);
        }
        session._isSavedAlready = true;

        // moving _csrfSecret to shared session
        sharedSession._csrfSecret = session._csrfSecret;

        async.parallel({
            shared: function sharedSet(next) {
                if (_sharedSession) {
                    mayflySet(self, sharedKey, sharedSession, next);
                } else {
                    next();
                }
            },
            app: function appSet(next) {
                mayflySet(self, key, session, next);
            }
        }, function (err, results) {
            callback(null, results.app);
        });
    };


    /**
     * Invalidates a session
     * @param id
     * @param callback
     */
    MayflyStore.prototype.destroy = function destroy(id, callback) {
        var self = this,
            sharedKey = getSharedKey(id),
            key = self._getKey(id),
            _sharedSession = this._sharedSession;

        async.parallel({
            shared: function sharedDestroy(next) {
                if (_sharedSession) {
                    mayflyDestroy(self, sharedKey, next);
                } else {
                    next();
                }
            },
            app: function appDestroy(next) {
                mayflyDestroy(self, key, next);
            }
        }, function (err, results) {
            callback(null, results.app);
        });
    };


    /**
     * Gets the storage key for the provided session id.
     * @param id
     * @return {*}
     * @private
     */
    MayflyStore.prototype._getKey = function _getKey(id) {
        return this._prefix + id;
    };

    return MayflyStore;
};
