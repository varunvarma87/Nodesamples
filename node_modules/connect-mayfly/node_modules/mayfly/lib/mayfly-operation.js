'use strict';

var net = require('net'),
    utils = require('./utils'),
    CONS = require('./constants'),
    hoek = require('hoek'),
    tryRequire = require('try-require'),
    mayflyMsg = require('./mayfly-message');

var requestLocal = tryRequire('request-local');

var CONSTANTS = CONS.CONSTANTS;

function getConnection(config, sIndex, address, counters, cb) {
    var socket, server,
        ipport, port, host,
        connectTimeout, calTxn;

    sIndex = sIndex || 0;
    counters = counters || {};

    if (config.servers) {
        server = config.servers[sIndex];
        ipport = server.split(':');
        port = ipport[1];
        host = ipport[0];
    } else {
        port = config.serverPORT;
        host = config.serverIP;
    }
    address = address || {};
    address.host = host;
    address.port = port;
    socket = net.createConnection(port, host, cb);

    if (requestLocal) {
        requestLocal.bindEmitterAll(socket);
    }

    calTxn = utils.calConnectTxn(host + ':' + port);

    function clearOnTimeout() {
        clearTimeout(connectTimeout);
        calTxn.complete();
    }

    function onConnectTimeout() {
        var error = new Error('connect ETIMEDOUT');
        error.code = 'ETIMEDOUT';
        calTxn.addData({retryCount: counters.retry});
        calTxn.status = 2;
        calTxn.complete();
        socket.emit('timeout', error);
    }

    if (hoek.isInteger(config.connectTimeout) && config.connectTimeout > 0) {
        connectTimeout = setTimeout(onConnectTimeout, config.connectTimeout);
        socket.once('connect', clearOnTimeout);
    }

    socket.setTimeout(config.timeout);
    socket.setNoDelay(true);
    return socket;
}

/**
 * core CRUD operation function, retries in case of error upto noRetries
 *  @param - operationType [required]
 *  @param - key [required]
 *  @param - payload [required]
 *  @param - tryCount default will be 0, in case on error, it will retry upto noRetries
 *  @param - affinityHash for continuous availability
 *  @param - callback function to be called on success
 */
function doOperationInner(config, operationType, key, payload, counters, affinityHash, callback) {
    var message,
        rawResponse = [],
        connection,
        address = {},
        primary = 0,
        startTime = Date.now(),
        requestId = {},
        calData,
        tTime;

    if (affinityHash) {
        primary = (affinityHash + counters.nHost) % config.servers.length;
    }

    counters.retry = counters.retry + 1;
    if (counters.retry > config.noRetries) {
        calData = {
            retryCount: config.noRetries,
            totalTime: (Date.now() - counters.ts)
        };
        utils.calErrorEvent('CONNECT_ERROR', calData);
        callback(new Error('connection error'), {});
        return;
    }

    connection = getConnection(config, primary, address, counters, function () {
        try {
            message = mayflyMsg.buildMessage(config, operationType, key, payload, 0, connection, requestId);
        } catch (err) {
            tTime = Date.now() - startTime;
            calData = {
                time: tTime,
                reqId: requestId.requestId,
                addr: address.host + ':' + address.port,
                error: err && err.message || err
            };
            utils.calErrorEvent('RESPONSE', calData);
            connection.end();
            connection.destroy();
            callback(err, {});
            return;
        }

        connection.write(message);
    });

    connection.on('data', function (chunk) {
        rawResponse.push(chunk);
    });

    connection.on('end', function () {
        var rawBuffer = Buffer.concat(rawResponse),
            response;

        if (rawBuffer && rawBuffer.length > CONSTANTS.headerSize) {
            response = mayflyMsg.parseResponse(rawBuffer);
            if (response.retry) {
                tTime = Date.now() - startTime;
                connection.destroy();
                //Retry to next available host
                counters.nHost = counters.nHost + 1;
                calData = {
                    time: tTime,
                    addr: address.host + ':' + address.port
                };
                utils.calStatusEvent('4', 'RETRY', calData);
                doOperationInner(config, operationType, key, payload, counters, affinityHash, callback);
            } else {
                callback(null, response);
            }
        } else {
            tTime = Date.now() - startTime;
            connection.destroy();
            calData = {
                time: tTime,
                retryCount: counters.retry
            };
            utils.calStatusEvent('4', 'EMPTY_RESPONSE', calData);
            //retry in case of connection error to the same host
            doOperationInner(config, operationType, key, payload, counters, affinityHash, callback);
        }

    });

    connection.once('error', function (err) {
        tTime = Date.now() - startTime;
        connection.end();
        connection.destroy();
        //Retry to next available host
        counters.nHost = counters.nHost + 1;
        calData = {
            time: tTime,
            addr: address.host + ':' + address.port,
            error: err && err.message || err
        };
        utils.calStatusEvent('4', 'ERROR_RETRY', calData);
        doOperationInner(config, operationType, key, payload, counters, affinityHash, callback);
    });

    connection.once('timeout', function (err) {
        tTime = Date.now() - startTime;
        connection.end();
        connection.destroy();
        if (!(err && err.code === 'ETIMEDOUT')) {
            calData = {
                time: tTime,
                addr: address.host + ':' + address.port,
                retryCount: counters.retry
            };
            utils.calStatusEvent('4', 'TIMEOUT_RETRY', calData);
        }
        //retry in case of connection error to the same host
        doOperationInner(config, operationType, key, payload, counters, affinityHash, callback);
    });

}

/**
 * core CRUD operation function wrapper, calculate the affinityHash
 *  @param - operationType [required]
 *  @param - key [required]
 *  @param - payload [required]
 *  @param - tryCount default will be 0, in case on error, it will retry upto noRetries
 *  @param - callback function to be called on success
 */
function doOperation(config, operationType, key, payload, callback) {
    var affinityHash,
        counters = {
            retry: 0,
            nHost: 0,
            ts: Date.now()
        },
        errmsg;

    if (config.servers && config.data_affinity) {
        affinityHash = utils.affinityHash(key);
    }

    if (typeof callback !== 'function') {
        errmsg = 'callback should be function';
        utils.calErrorEvent('callback', errmsg);
        return;
    }

    //to make sure callback is called only once
    callback = hoek.once(callback);

    doOperationInner(config, operationType, key, payload, counters, affinityHash, callback);
}

module.exports = {
    getConnection: getConnection,
    doOperation: doOperation
};
