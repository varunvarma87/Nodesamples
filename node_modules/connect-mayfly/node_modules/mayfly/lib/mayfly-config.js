'use strict';

var async = require('async'),
    utils = require('./utils'),
    CONS = require('./constants'),
    tryRequire = require('try-require');

var nconf = tryRequire('nconf'),
    calUtils = tryRequire('cal/lib/apputil'),
    CONSTANTS = CONS.CONSTANTS;

module.exports = function buildConnfig(config) {
    var serversOut,
        servers,
        ip, port,
        ipport,
        nconfig,
        errmsg,
        appName = calUtils && calUtils.getAppName() || 'NodeMayflyClient',
        hasUnresolvedVault = false,
        env = process.env.DEPLOY_ENV;

    config = config || {};

    config.appName = config.appName || appName;
    config.namespace = config.namespace || 'NodeClient';
    config.lifetime = config.lifetime || CONSTANTS.defaultLifeTime;
    config.noRetries = config.noRetries || CONSTANTS.noRetries;
    config.timeout = config.timeout || CONSTANTS.defaultTimeout;
    config.connectTimeout = config.connectTimeout || CONSTANTS.defaultConnectTimeout;
    config.data_affinity = config.enableDataAffinity || false;
    config.encryptionAlgorithm = config.encryptionAlgorithm || 'desx';
    config.macAlgorithm = config.macAlgorithm || 'sha1';

    if (config.lifetime < 0 || config.lifetime > CONSTANTS.maxLifeTime) {
        errmsg = 'lifetime should be <= ' + CONSTANTS.maxLifeTime + 'sec';
        utils.calErrorEvent('lifetime', errmsg);
        throw new Error(errmsg);
    }

    config.useCrypto = typeof config.crypto === 'boolean' ? config.crypto : true;

    nconfig = nconf && nconf.get('mayfly') || config;

    config.cryptKey = config.cryptKey || nconfig.cryptKey;
    config.macKey = config.macKey || nconfig.macKey;

    if (config.cryptKey && config.cryptKey.indexOf) {
        hasUnresolvedVault = config.cryptKey.indexOf('vault:') !== -1;
    }
    if ((!config.cryptKey || !config.macKey || hasUnresolvedVault) && config.useCrypto) {
        if (env) {
            errmsg = 'Protected Pkg Issue. Crypt and/or mac key missing, refusing to start';
            utils.calErrorEvent('cryptKeys', errmsg);
            throw new Error(errmsg);
        } else {
            config.cryptKey = CONSTANTS.stageCryptKey;
            config.macKey = CONSTANTS.stageMacKey;
            utils.calErrorEvent('cryptKeys', 'Crypt and/or mac key missing, using stage defaults');
        }
    }


    config.serverPORT = config.port || nconfig.port || CONSTANTS.defaultPort;

    ipport = config.ipport || nconfig.ipport;

    if (config.host || nconfig.host) {
        config.serverIP = config.host || nconfig.host;
    }
    if (ipport && ipport.indexOf('%') === -1) {

        //format:: <priority>:<qualified host name or ip>:<port>{[^<priority>:<qualified host name or ip>:<port>]}'
        //server.ipport=1:10.57.210.103:17386^1:10.57.79.206:10368
        //priority is not used
        servers = ipport.split('^');
        serversOut = [];
        async.map(servers, function (server) {
            server = server.split(':');
            if (server.length < 2 || server.length > 3) {
                errmsg = 'Mayfly ipport option is not configed properly';
                utils.calErrorEvent('ipport', errmsg);
                throw new Error(errmsg);
            }
            ip = server[1];
            port = server[2] || CONSTANTS.defaultPort;

            serversOut.push(ip + ':' + port);
        });
        if (config.data_affinity) {
            serversOut.sort();
        }
        config.servers = serversOut;
    }
    return config;
};
