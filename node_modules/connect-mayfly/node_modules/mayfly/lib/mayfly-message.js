'use strict';

/*eslint new-cap:0 */

var ip = require('ip'),
    utils = require('./utils'),
    CONS = require('./constants'),
    structs = require('./structs');

var Struct = require('struct').Struct;

var headerStruct = structs.headerStruct,
    omHeaderStruct = structs.omHeaderStruct,
    requestIdStruct = structs.requestIdStruct,
    recordInfoHeaderStruct = structs.recordInfoHeaderStruct;

var MessageSenderType = CONS.MessageSenderType,
    CONSTANTS = CONS.CONSTANTS,
    Direction = CONS.Direction,
    DataTags = CONS.DataTags,
    OperationType = CONS.OperationType,
    OperationStatus = CONS.OperationStatus;

var serialNoCounter = 0;

/**
 *  Returns a unique sequential serial no
 */
function getNextSerialNo() {
    serialNoCounter++;
    serialNoCounter = serialNoCounter % CONSTANTS.maxSerialNumber;
    return serialNoCounter;
}

//header structure from https://confluence.paypal.com/cnfl/display/ICARUS/Icarus+Mayfly2+Client
/**
 * Build message header
 * 40 bytes header
 * Mayfly Header (40 bytes)
 *  4 bytes for Mayfly Magic code 'DEEFCAFE' (Bytes 0 to 3)
 *  4 bytes for Message size  (Bytes 4 to 7)
 *  4 bytes for Header size  (Bytes 8 to 11)
 *  4 bytes for Operation Message size  (Bytes 12 to 15)
 *  4 bytes for Application Name size  (Bytes 16 to 19)
 *  4 bytes for Sender IPv4 IP  (Bytes 20 to 23)
 *  4 bytes for Recipient IPv4 IP  (Bytes 24 to 27)
 *  2 bytes for Sender Port  (Bytes 28 to 29)
 *  2 bytes for Recipient Port  (Bytes 30 to 31)
 *  2 bytes for Sender Type  (Bytes 32 to 33)
 *  2 bytes for Direction  (Bytes 34 to 35)
 *  4 bytes for Site ID  (Bytes 36 to 39)
 */
function getMayflyHeader(msgSize, operationMsgSize, appNameSize, connection) {
    var recipientIP = ip.toBuffer(connection.remoteAddress),
        recipientPort = connection.remotePort,
        header,
        senderAddress = connection.address(),
        senderIP = ip.toBuffer(senderAddress.address),
        senderPort = senderAddress.port;

    headerStruct.allocate();
    header = headerStruct.buffer();
    header.fill(0);

    headerStruct.set('magic', CONSTANTS.magic);
    headerStruct.set('msgSize', msgSize);
    headerStruct.set('headerSize', CONSTANTS.headerSize);
    headerStruct.set('operationMsgSize', operationMsgSize);
    headerStruct.set('appNameSize', appNameSize);
    headerStruct.set('senderIP', senderIP.readUInt32BE(0));
    headerStruct.set('recipientIP', recipientIP.readUInt32BE(0));
    headerStruct.set('senderPort', senderPort);
    headerStruct.set('recipientPort', recipientPort);
    headerStruct.set('senderType', MessageSenderType.Client);
    headerStruct.set('direction', Direction.request);
    headerStruct.set('siteID', 0);

    return header;
}

//OperationMsg structure from https://confluence.paypal.com/cnfl/display/ICARUS/Icarus+Mayfly2+Client
/**
 * Build OperationMsg (N bytes)
 *
 *  Header (24 bytes)
 *      Record Info Size (4 bytes)
 *      Request ID Size (4 bytes)
 *      Optional Data Size (4 bytes)
 *      Payload Data Size (4 bytes)
 *      Operation Type (2 bytes)
 *      Operation Mode (1 byte)
 *      Replicate State (1 byte)
 *      Operation Status (2 bytes)
 *      Filler (2 bytes) - to align to 4 byte boundary  NOTE: on the response those bytes can be random values (!= 0x00)
 *  Record Info Data Tag (1 byte) = 0x01
 *  Record Info
 *      Record Info Header
 *          Create Time (4 bytes) - 'UNIX Time' = seconds since 1.1.1970
 *          Lifetime (4 bytes)
 *          Version (2 bytes)
 *          Namespace Size (2 bytes)
 *          Key Size (2 bytes)
 *          Filler (2 bytes) - to align to 4 byte boundary
 *      Namespace Data Tag (1 byte) = 0x01
 *      Namespace (0 - N bytes)
 *      Key Data Tag (1 byte) = 0x02
 *      Key (0 - M bytes)
 *      End of Record Info Data Tag (1 byte) = 0x00
 *  Request ID Data Tag (1 byte) = 0x02
 *  Request ID
 *      Size (2 bytes)
 *      Host IP (4 bytes)
 *      PID (4 bytes)
 *      Requesting Time (4 bytes)
 *      Serial Number (2 bytes)
 *      Filler (2 bytes) - 0x0000 - NOTE: this filler is only present on the outbound (to the server) message and not on the response (from the server)
 *  Optional Data Tag (1 byte) = 0x04 - only if Optional Data Size > 0
 *  Optional Data (0 - N bytes) - only if Optional Data Size > 0
 *  Payload Data Tag (1 byte) = 0x03 - only if Paypload Data Size > 0
 *  Payload Data (0 - M bytes) - only if Payload Data Size > 0
 *  End of Operations Message Tag (1 byte) = 0x00
 *
 * @param key - Buffer Key
 * @param payloadData - Buffer
 * @param optionalData - Buffer
 * @param version - int
 * @param senderIP - Buffer
 */
function getOperationMsg(config, operationType, keyData, payloadData, version, senderIP, requestIdValue) {

    function resolveLifetime() {
        return (operationType === OperationType.Set || operationType === OperationType.Create) ?
            config.lifetime : CONSTANTS.noLifeTimeUpdate;
    }

    var operationMsgStruct,
        operationMsg,
        omHeader,
        omHeaderSize,
        recordInfo,
        recordInfoHeader,
        recordInfoStruct,
        requestId,
        requestIdSize,
        nameSpace = config.namespace,
        nameSpaceSize = 0,
        keyDataSize = 0,
        payloadDataSize = 0,
        recordInfoSize = 0,
        optionalData = '';

    version = version || 0;
    requestIdValue = requestIdValue || {};

    omHeaderStruct.allocate();
    omHeader = omHeaderStruct.buffer();
    omHeader.fill(0);
    omHeaderSize = omHeader.length;

    omHeaderStruct.set('operationType', operationType);


    nameSpaceSize = Buffer.byteLength(nameSpace);
    keyDataSize = Buffer.byteLength(keyData);
    if (payloadData) {
        payloadDataSize = Buffer.byteLength(payloadData);
    }

    recordInfoStruct = Struct()
            .struct('header', recordInfoHeaderStruct)
            .word8('namespaceTag')                  //0x01 - Start of NameSpace
            .chars('namespace', nameSpaceSize, 'utf8')      //nameSpace
            .word8('keyDataTag')                    //0x02 - Start of Key
            .chars('keyData', keyDataSize, 'utf8')          //keyData
            .word8('endTag');                   //end Tag

    recordInfoStruct.allocate();
    recordInfo = recordInfoStruct.buffer();
    recordInfo.fill(0);
    recordInfoSize = recordInfo.length;

    //recordInfoHeader
    recordInfoHeaderStruct.allocate();
    recordInfoHeader = recordInfoHeaderStruct.buffer();
    recordInfoHeader.fill(0);

    recordInfoHeaderStruct.set('lifetime', resolveLifetime());

    recordInfoHeaderStruct.set('version', version);
    recordInfoHeaderStruct.set('namespaceSize', nameSpaceSize);
    recordInfoHeaderStruct.set('keySize', keyDataSize);
    recordInfoHeader.copy(recordInfo, 0);
    recordInfoHeader = null;

    //recordInfo
    recordInfoStruct.set('namespaceTag', DataTags.namespaceTag);
    recordInfoStruct.set('namespace', nameSpace);
    recordInfoStruct.set('keyDataTag', DataTags.keyDataTag);
    recordInfoStruct.set('keyData', keyData);
    recordInfoStruct.set('endTag', DataTags.endTag);
    //console.log(recordInfo);

    //requestId
    requestIdStruct.allocate();
    requestId = requestIdStruct.buffer();
    requestId.fill(0);
    requestIdSize = requestId.length;

    requestIdStruct.set('rsize', requestIdSize);
    requestIdStruct.set('hostip', senderIP.readUInt32BE(0));
    //requestIdStruct.set('pid', process.pid);
    requestIdStruct.set('requestingTime', Date.now() % CONSTANTS.maxTimeStamp);
    requestIdStruct.set('serialNum', getNextSerialNo());



    //Post Fill
    omHeaderStruct.set('recordInfoSize', recordInfoSize);
    omHeaderStruct.set('requestIdSize', requestIdSize);
    omHeaderStruct.set('payloadDataSize', payloadDataSize);

    if (payloadData) {
        operationMsgStruct = Struct()
                .chars('header', omHeaderSize, 'utf8')
                .word8('recordInfoTag')
                .chars('recordInfo', recordInfoSize, 'utf8')
                .word8('requestIdTag')
                .chars('requestId', requestIdSize, 'utf8')
                .word8('payloadDataTag')
                .chars('payloadData', payloadDataSize, 'utf8')
                .word8('endTag');
    } else {
        operationMsgStruct = Struct()
                .chars('header', omHeaderSize, 'utf8')
                .word8('recordInfoTag')
                .chars('recordInfo', recordInfoSize, 'utf8')
                .word8('requestIdTag')
                .chars('requestId', requestIdSize, 'utf8')
                .word8('endTag');
    }

    operationMsgStruct.allocate();
    operationMsg = operationMsgStruct.buffer();

    omHeader.copy(operationMsg, 0);
    omHeader = null;
    operationMsgStruct.set('recordInfoTag', DataTags.recordInfoTag);
    recordInfo.copy(operationMsg, omHeaderSize + 1);
    recordInfo = null;
    operationMsgStruct.set('requestIdTag', DataTags.requestIdTag);
    requestId.copy(operationMsg, omHeaderSize + recordInfoSize + 2);

    requestIdValue.requestId = requestIdStruct.get('rsize') + '-' +
                                ip.toString(senderIP) + '-' +
                                requestIdStruct.get('pid') + '-' +
                                requestIdStruct.get('requestingTime') + '-' +
                                requestIdStruct.get('serialNum');

    requestId = null;
    if (optionalData) {
        operationMsgStruct.set('optionalDataTag', optionalData ? DataTags.optionalDataTag : DataTags.endTag);
        operationMsgStruct.set('optionalData', optionalData);
    }
    if (payloadData) {
        operationMsgStruct.set('payloadDataTag', payloadData ? DataTags.payloadDataTag : DataTags.endTag);
        operationMsgStruct.set('payloadData', payloadData);
    }
    operationMsgStruct.set('endTag', DataTags.endTag);

    return operationMsg;
}

/**
 * Whole Message
 *  40 bytes Mayfly header
 *  1 byte Application Name Data Tag = 0xAB - only if Application Name Size > 0
 *  N bytes for Application Name - only if Application Name Size > 0
 *  1 byte Operations Message Data Tag = 0xDD - only if Operations Message Size > 0
 *  M bytes for Operations Message - only if Operations Message Size > 0
 *  1 byte for Message End Tag = 0x00
 */
function buildMessage(config, operationType, key, payload, version, connection, requestIdValue) {
    var mayflyHeader,
        mayflyHeaderSize,
        applicationName,
        applicationNameSize,
        operationMessage,
        operationMessageSize,
        mayflyMsgBuffer,
        msgSize = 0,
        mayflyMsgStruct,
        errmsg,
        senderAddress = connection.address(),
        senderIP = ip.toBuffer(senderAddress.address);

    if (typeof key !== 'string') {
        errmsg = 'Invalid Mayfly Message Request. key is missing';
        utils.calErrorEvent('key', errmsg);
        throw new Error(errmsg);
    }
    if (key.length > CONSTANTS.maxKeyLen) {
        errmsg = 'Mayfly key should be <= ' + CONSTANTS.maxKeyLen + 'Bytes';
        utils.calErrorEvent('keyLength', errmsg);
        throw new Error(errmsg);
    }

    if ([OperationType.Create, OperationType.Get, OperationType.Update, OperationType.Set, OperationType.Destroy].indexOf(operationType) === -1) {
        errmsg = 'Invalid Mayfly Message Request. Wrong operation type';
        utils.calErrorEvent('operationType', errmsg);
        throw new Error(errmsg);
    }

    applicationName = config.appName;
    operationMessage = getOperationMsg(config, operationType, key, payload, version, senderIP, requestIdValue);
    operationMessageSize = operationMessage.length;

    applicationNameSize = Buffer.byteLength(applicationName);

    msgSize = 1 + (applicationNameSize ? 1 : 0) + (operationMessageSize ? 1 : 0) + CONSTANTS.headerSize + applicationNameSize + operationMessageSize;
    mayflyHeader = getMayflyHeader(msgSize, operationMessageSize, applicationNameSize, connection);
    mayflyHeaderSize = mayflyHeader.length;

    if (msgSize > CONSTANTS.maxPayloadSize) {
        errmsg = 'Mayfly payload should be <= ' + CONSTANTS.maxPayloadSize + 'Bytes';
        utils.calErrorEvent('maxPayloadSize', errmsg);
        throw new Error(errmsg);
    }

    mayflyMsgStruct = Struct()
            .chars('header', mayflyHeaderSize, 'utf8')
            .word8('applicationNameTag')
            .chars('applicationName', applicationNameSize, 'utf8')
            .word8('operationMessageTag')
            .chars('operationMessage', operationMessageSize, 'utf8')
            .word8('endTag');

    mayflyMsgStruct.allocate();
    mayflyMsgBuffer = mayflyMsgStruct.buffer();

    mayflyHeader.copy(mayflyMsgBuffer, 0);
    mayflyHeader = null;
    if (applicationName) {
        mayflyMsgStruct.set('applicationNameTag', DataTags.applicationNameTag);
        mayflyMsgStruct.set('applicationName', applicationName);
    }
    if (operationMessage) {
        mayflyMsgStruct.set('operationMessageTag', DataTags.operationMessageTag);
        operationMessage.copy(mayflyMsgBuffer, mayflyHeaderSize + applicationNameSize + 2);
        operationMessage = null;
    }
    mayflyMsgStruct.set('endTag', DataTags.endTag);

    return mayflyMsgBuffer;

}

/**
 *  Parses the response from Mayfly server
 *  @param - responseBuffer of Buffer data type
 *  @return -  mayfly Response {
                        namespace : '',
                        key : '',
                        version : '',
                        data : ''
                    }
 */
function parseResponse(responseBuffer) {
    var index = 0,
        operationMsgIndex = 0,
        recordInfoIndex = 0,
        header,
        omHeader,
        mayflyResponse = {},
        applicationName,
        operationMessage,
        recordInfoSize,
        requestIdSize,
        optionalDataSize,
        payloadDataSize,
        payloadData,
        operationStatus,
        recordInfoHeader,
        recordInfo,
        namespace,
        key,
        errmsg;

    headerStruct.allocate();
    header = headerStruct.buffer();
    responseBuffer.copy(header, 0, 0, CONSTANTS.headerSize);
    index += CONSTANTS.headerSize;

    if (headerStruct.get('magic') !== CONSTANTS.magic) {
        errmsg = 'wrong magic code';
        utils.calErrorEvent('response', errmsg);
        mayflyResponse.retry = true;
        header = null;
        responseBuffer = null;
        return mayflyResponse;
    }
    if (headerStruct.get('headerSize') !== CONSTANTS.headerSize) {
        errmsg = 'wrong header size';
        utils.calErrorEvent('response', errmsg);
        mayflyResponse.retry = true;
        header = null;
        responseBuffer = null;
        return mayflyResponse;
    }
    if (headerStruct.get('senderType') !== 2) {
        errmsg = 'senderType should be 2 to indicate it\'s coming from server';
        utils.calErrorEvent('response', errmsg);
        mayflyResponse.retry = true;
        header = null;
        responseBuffer = null;
        return mayflyResponse;
    }
    if (headerStruct.get('direction') !== Direction.response) {
        errmsg = 'direction doesn\'t say it\'s server response';
        utils.calErrorEvent('response', errmsg);
        mayflyResponse.retry = true;
        header = null;
        responseBuffer = null;
        return mayflyResponse;
    }

    var msgSize = headerStruct.get('msgSize');
    var operationMsgSize = headerStruct.get('operationMsgSize');
    var appNameSize = headerStruct.get('appNameSize');

    if (responseBuffer.length !== msgSize) {
        errmsg = 'msg size wrong';
        utils.calErrorEvent('response', errmsg);
        mayflyResponse.retry = true;
        header = null;
        responseBuffer = null;
        return mayflyResponse;
    }

    if (appNameSize) {
        if (responseBuffer[index++] !== DataTags.applicationNameTag) {
            utils.calErrorEvent('response', 'applicationNameTag missing');
            mayflyResponse.retry = true;
            header = null;
            responseBuffer = null;
            return mayflyResponse;
        }
        responseBuffer.copy(applicationName, 0, index, appNameSize);
        index += appNameSize;
    }

    if (operationMsgSize) {
        if (responseBuffer[index++] !== DataTags.operationMessageTag) {
            errmsg = 'operationMessageTag missing';
            utils.calErrorEvent('response', errmsg);
            mayflyResponse.retry = true;
            header = null;
            responseBuffer = null;
            return mayflyResponse;
        }
        operationMessage = new Buffer(operationMsgSize);
        responseBuffer.copy(operationMessage, 0, index);
        index += operationMsgSize;

        omHeaderStruct.allocate();
        omHeader = omHeaderStruct.buffer();
        operationMessage.copy(omHeader, 0);
        operationMsgIndex += omHeader.length;

        recordInfoSize = omHeaderStruct.get('recordInfoSize');
        requestIdSize = omHeaderStruct.get('requestIdSize');
        optionalDataSize = omHeaderStruct.get('optionalDataSize');
        payloadDataSize = omHeaderStruct.get('payloadDataSize');
        operationStatus = omHeaderStruct.get('operationStatus');

        //console.log(recordInfoSize, requestIdSize, optionalDataSize, payloadDataSize);

        if (operationMessage[operationMsgIndex++] !== DataTags.recordInfoTag) {
            errmsg = 'record Info data tag error';
            utils.calErrorEvent('response', errmsg);
            mayflyResponse.retry = true;
            header = null;
            responseBuffer = null;
            return mayflyResponse;
        }

        recordInfo = new Buffer(recordInfoSize);
        operationMessage.copy(recordInfo, 0, operationMsgIndex);
        operationMsgIndex += recordInfoSize;

        recordInfoHeaderStruct.allocate();
        recordInfoHeader = recordInfoHeaderStruct.buffer();
        recordInfo.copy(recordInfoHeader, 0);
        recordInfoIndex += recordInfoHeader.length;

        mayflyResponse.version = recordInfoHeaderStruct.get('version');


        var nameSpaceSize = recordInfoHeaderStruct.get('namespaceSize');
        var keySize = recordInfoHeaderStruct.get('keySize');

        namespace = new Buffer(nameSpaceSize);

        if (recordInfo[recordInfoIndex++] !== DataTags.namespaceTag) {
            errmsg = 'Namespace data tag error';
            utils.calErrorEvent('response', errmsg);
            mayflyResponse.retry = true;
            header = null;
            responseBuffer = null;
            return mayflyResponse;
        }
        recordInfo.copy(namespace, 0, recordInfoIndex);
        recordInfoIndex += nameSpaceSize;

        key = new Buffer(keySize);
        if (recordInfo[recordInfoIndex++] !== DataTags.keyDataTag) {
            errmsg = 'key Data Tag error';
            utils.calErrorEvent('response', errmsg);
            mayflyResponse.retry = true;
            header = null;
            responseBuffer = null;
            return mayflyResponse;
        }
        recordInfo.copy(key, 0, recordInfoIndex);
        recordInfoIndex += keySize;
        recordInfo = null;

        mayflyResponse.namespace = namespace.toString('utf8');
        mayflyResponse.key = key.toString('utf8');

        switch (operationStatus) {
        case OperationStatus.NO_ERROR:
            break;
        case OperationStatus.DUP_KEY:
            mayflyResponse.status = OperationStatus.DUP_KEY;
            utils.calErrorEvent('DUP_KEY', 'mayflyException: duplicate key');
            break;
        case OperationStatus.NO_KEY:
            mayflyResponse.status = OperationStatus.NO_KEY;
            utils.calStatusEvent(0, 'NO_KEY', 'mayflyException: NO_KEY');
            break;
        case OperationStatus.DATA_EXPIRED:
            mayflyResponse.status = OperationStatus.DATA_EXPIRED;
            utils.calErrorEvent('DATA_EXPIRED', 'mayflyException: DATA_EXPIRED');
            break;
        case OperationStatus.SERVICE_DENIED:
            mayflyResponse.status = OperationStatus.SERVICE_DENIED;
            utils.calErrorEvent('SERVICE_DENIED', 'mayflyException: SERVICE_DENIED');
            break;
        case OperationStatus.INSERTING:
            mayflyResponse.status = OperationStatus.INSERTING;
            utils.calErrorEvent('INSERTING', 'mayflyException: INSERTING');
            break;
        case OperationStatus.BAD_MSG:
            mayflyResponse.status = OperationStatus.BAD_MSG;
            utils.calErrorEvent('BAD_MSG', 'mayflyException: BAD_MSG');
            mayflyResponse.retry = true;
            break;
        case OperationStatus.OUT_OF_MEM:
            mayflyResponse.status = OperationStatus.OUT_OF_MEM;
            utils.calErrorEvent('OUT_OF_MEM', 'mayflyException: OUT_OF_MEM');
            mayflyResponse.retry = true;
            break;
        case OperationStatus.NO_STORAGE_SERVER:
            mayflyResponse.status = OperationStatus.NO_STORAGE_SERVER;
            utils.calErrorEvent('NO_STORAGE_SERVER', 'mayflyException: NO_STORAGE_SERVER');
            mayflyResponse.retry = true;
            break;
        }

        if (operationStatus !== OperationStatus.NO_ERROR) {
            header = null;
            responseBuffer = null;
            operationMessage = null;
            return mayflyResponse;
        }


        if (operationMessage[operationMsgIndex++] !== DataTags.requestIdTag) {
            errmsg = 'request id Data Tag error';
            utils.calErrorEvent('response', errmsg);
            mayflyResponse.retry = true;
            header = null;
            responseBuffer = null;
            operationMessage = null;
            return mayflyResponse;
        }
        requestIdStruct.allocate();
        var requestId = requestIdStruct.buffer();
        operationMessage.copy(requestId, 0, operationMsgIndex);
        operationMsgIndex += requestIdSize;

        //console.log(requestIdStruct.get('rsize'),requestIdStruct.get('pid'), requestIdStruct.get('requestingTime'), requestIdStruct.get('serialNum'));

        if (operationMessage[operationMsgIndex] === DataTags.optionalDataTag) {
            operationMsgIndex++;
            if (optionalDataSize) {
                //This is optional data; not sure if it's ever used
                //Grab the optional data,
                operationMsgIndex += optionalDataSize;
            }
        }
        if (operationMessage[operationMsgIndex] === DataTags.payloadDataTag) {
            operationMsgIndex++;
            if (payloadDataSize === 0) {
                errmsg = 'Found payload data tag, but no data';
                utils.calErrorEvent('response', errmsg);
                mayflyResponse.retry = true;
                header = null;
                responseBuffer = null;
                operationMessage = null;
                return mayflyResponse;
            }
            payloadData = new Buffer(payloadDataSize);
            operationMessage.copy(payloadData, 0, operationMsgIndex);
            operationMsgIndex += payloadDataSize;
            mayflyResponse.rawData = payloadData;
            mayflyResponse.data = payloadData.toString('utf8');
        }
        operationMessage = null;
    }
    if (responseBuffer[index] !== DataTags.endTag) {
        errmsg = 'wrong end of message';
        utils.calErrorEvent('response', errmsg);
        mayflyResponse.retry = true;
        header = null;
        responseBuffer = null;
        return mayflyResponse;
    }

    header = null;
    responseBuffer = null;

    return mayflyResponse;

}


module.exports = {
    getMayflyHeader: getMayflyHeader,
    getOperationMsg: getOperationMsg,
    buildMessage: buildMessage,
    parseResponse: parseResponse
};
