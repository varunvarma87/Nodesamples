'use strict';

var zlib = require('zlib'),
    utils = require('./utils'),
    ppcryptutils = require('cryptutils-paypal');

function getPPCrypto(config) {
    var ppcrypto = ppcryptutils({
            encryptionAlgorithm: config.encryptionAlgorithm,
            macAlgorithm: config.macAlgorithm,
            encryptionKey: new Buffer(config.cryptKey, 'base64'),
            macKey: new Buffer(config.macKey, 'base64')
        });
    return ppcrypto;
}

/**
 * Decrypt the data using node crypto module
 */
function decryptRaw(config, encryptedData, callback) {
    var data,
        error = null;

    try {
        data = getPPCrypto(config).decodeAndUnseal(new Buffer(encryptedData));
    } catch (e) {
        utils.calErrorEvent('decrypt', e || 'decodeAndUnseal Error');
        error = e;
    }
    callback(error, data);
}

/**
 * Decrypt the data using node crypto module
 */
function decrypt(config, encryptedData, callback) {
    try {
        decryptRaw(config, encryptedData, function (error, data) {
            if (error) {
                return callback(error);
            }
            zlib.unzip(data, function (err, buffer) {
                if (err) {
                    utils.calErrorEvent('decryptZlib', err);
                    return callback(null, null); // force new session to be created
                }
                if (buffer) {
                    callback(null, buffer.toString());
                } else {
                    callback(null, null); // force new session to be created
                }
            });
        });
    } catch (e) {
        utils.calErrorEvent('decrypt', e);
        callback(e);
    }
}

/**
 * Encrypt the data using node crypto module
 * The data is compressed first because the cost of compression is much less
 * than the cost of encryption so shrinking the data is a win.
 */
function encrypt(config, plainData, callback) {
    zlib.deflate(plainData, function (err, buffer) {
        if (err) {
            utils.calErrorEvent('encryptZlib', err);
            return callback(err);
        }
        var data = getPPCrypto(config).sealAndEncode(new Buffer(buffer, 'binary'));
        callback(null, data);
    });
}

module.exports = {
    encrypt: encrypt,
    decrypt: decrypt,
    decryptRaw: decryptRaw
};
