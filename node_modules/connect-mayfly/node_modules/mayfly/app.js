'use strict';

var Mayfly = require('./index'),
    cal = require('cal'),
    nconf = require('nconf'),
    argv = require('optimist')
        .usage('Usage: $0 --perf=[false|true] --load=[100] --timeout=[1000]')
        .argv;

cal.defaults.writeStream = process.stdout;

var IPPORT = '1:stage2dev007.qa.paypal.com:10368^1:stage2dev002.qa.paypal.com:10368^1:10.57.79.206:10068^1:10.57.82.87',
    config = {
        lifetime: 50
    };

nconf.use('memory');

nconf.set("mayfly", {
        "ipport" : IPPORT
    });
//creating a new instance of mayfly client, optional config
var mayfly = new Mayfly(config),
    isPerf = argv.perf || false,
    loadFactor = argv.load || 100,
    timeout = argv.timeout || 1000,
    key = "test" + Date.now(),
    small_str = (new Array(200).join("-")),
    //large_str = (new Array(20480).join("-")),
    payloadData = key + small_str;

console.log("\r\nTesting Mayfly operations \n Usage: --perf=[false|true] --load=[100] --timeout=[1000] \n (timeout is set to %d msec)", timeout);


if (isPerf) {
    mayfly.create(key, payloadData, function (error, response) {
        console.log("\r\ncreate operation :: ");
        console.log(response);
        if (!error) {
            for (var ii = 0; ii < loadFactor; ii++) {
                setTimeout(doRead, timeout, response.key, "nothing");
            }
        } else {
            console.log("error", error);
        }
    });
} else {
    mayfly.create(key, payloadData, function (error, response) {
        console.log("\r\ncreate operation :: ");
        console.log(response);
        if (!error) {
            setTimeout(doRead, timeout, response.key, "readUpdate");
        } else {
            console.log("error", error);
        }
    });
}

function doRead(key, operation) {
    mayfly.read(key, function (error, response) {
            console.log("\r\nread operation :: ");
            console.log(response);
            if (!error) {
                if (operation === "readUpdate") {
                    setTimeout(doUpdate, timeout, key, response.data + ", current timestamp : " + Date.now());
                } else if (operation === "readDelete") {
                    setTimeout(doDelete, timeout, response.key, response.data + ", current timestamp : " + Date.now());
                } else {
                    //setTimeout(doRead, timeout, response.key);
                }
            } else {
                console.log("error", error);
            }
        });
}

function doUpdate(key, payload) {
    mayfly.update(key, payload, function (error, response) {
        console.log("\r\nupdate operation :: ");
        console.log(response);
        if (!error) {
            setTimeout(doRead, timeout, response.key, "readDelete");
        } else {
            console.log("error", error);
        }
    });
}

function doDelete(key) {

    mayfly.destroy(key, function (error, response) {
        console.log("\r\ndelete operation :: ");
        console.log(response);
        if (!error) {
            setTimeout(doRead, timeout, response.key);
        } else {
            console.log("error", error);
        }
    });
}

