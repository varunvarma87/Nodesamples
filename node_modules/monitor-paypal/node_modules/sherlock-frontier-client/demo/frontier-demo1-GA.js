'use strict';

/**
 * A demo of Sherlock Frontier client which demonstrates registering a set of metrics and publishing their time series.
 * The demo is invoked with a number of optional command line arguments to control its key settings.
 * The demo demonstrates 3 different POST reliability levels: FrontierClient.PostConcern.ENSURE_TRANSMISSION,
 * FrontierClient.PostReliability.ENSURE_ACK, and FrontierClient.PostReliability.ENSURE_PROCESSED
 * The difference between them is that in the first case the client does not expect/wait for the server response,
 * in the second case it expects a simple ack that the server has received and opened the request, and in the third -
 * the replies only after the request has actually been processed.
 *
 * Regardless of the chosen reliability level, the demo completes only when every post is acknowledged with a local callback.
 * @author Yuri Finkelstein, December 2014
 * @module
 */

var async = require('async');
var argv = require('optimist').argv;
var assert = require('assert');
var Promise = require('node-promise').Promise;

var FrontierClient = require('../index');

var frontierEndpoint = argv.ep || '10.109.173.117:8080';

var clientGroup = argv.cg || {tenant: 'pp', env: 'qa', app_svc: 'nodejs'};

var postReliability = FrontierClient.PostReliability.ENSURE_TRANSMISSION; //default
if (argv.prt) {
    postReliability = FrontierClient.PostReliability.ENSURE_TRANSMISSION;
}
if (argv.pra) {
    postReliability = FrontierClient.PostReliability.ENSURE_ACK;
}
if (argv.prp) {
    postReliability = FrontierClient.PostReliability.ENSURE_PROCESSED;
}

var numPosts = parseInt(argv.np, 10) || 100;

var queue_capacity = parseInt(argv.qc, 10) || 100;


// demonstration of register/loop/post
function demo1(demo_callback) {
    var fc = new FrontierClient(frontierEndpoint, clientGroup, {
        connect_retry_interval_sec: 5,
        queue_capacity: queue_capacity
    });
    fc.on(FrontierClient.ERROR, function (error) {
        console.error("FrontierClient error: %j", error);
    });
    var metric_set = {
        resolution_seconds: 10,
        profile: 'pp_here_app',
        dimension: [{
            name: 'pool',
            value: 'p123'
        }, {
            name: 'host',
            value: 'host456'
        }],
        metric: [{
            name: 'business.metric1',
            metric_type: 'GAUGE',
            value_type: "FLOAT",
            units: "payments/sec"
        }, {
            name: 'business.metric2',
            metric_type: 'COUNTER',
            value_type: "INT",
            units: "payments"
        }]
    };

    async.waterfall(
        [
            fc.once.bind(fc, FrontierClient.CONNECT),
            function (frontier_master, cb) {
                console.log("Successfully connected to master frontier node %s", frontier_master);
                fc.register(metric_set, cb);
            },
            function (response, reg_latency, cb) {
                assert(response.metric_id instanceof Array, "metric_ids is not an array");
                assert.equal(response.metric_id.length, metric_set.metric.length);

                console.log("Received registration ids: %j (latency=%d msec)", response.metric_id, reg_latency);
                var post_count = 0, ack_count = 0, error_count = 0;
                var ackAllPromise = new Promise();
                async.whilst(
                    function () {
                        return post_count < numPosts;
                    },
                    function (callback) {
                        var this_post = ++post_count;
                        setTimeout(function () {
                            console.log("sending post # %d", this_post);
                            fc.post(
                                Date.now() / 1000, //timestamp, in seconds
                                response.metric_id, // array of binary metric IDs returned by 'register' call
                                [{
                                    float_value: 10 + this_post
                                }, {
                                    int32_value: 20 + this_post
                                }], //samples
                                postReliability, // post reliability level
                                function (err, result, latency) { // callback
                                    if (err) {
                                        console.trace("received error for post #%d", this_post, err);
                                        error_count ++;
                                    } else {
                                        console.log("received ack for post # %d (latency=%d msec)", this_post, latency);
                                        ack_count ++;
                                    }
                                    if (error_count + ack_count === numPosts) {
                                        (error_count === 0) ?
                                            ackAllPromise.resolve(numPosts) :
                                            ackAllPromise.reject(error_count, true/*don't throw - complete normally*/);
                                    }
                                });
                            callback(null);
                        }, 3 * 1000 /* every 3 seconds */);
                    },
                    function (err) { // this is invoked when all posts are done but not all acks are necessary received
                        if (err) {
                            cb(err); // we fail fast if at least one setTimeout failed
                        } else {
                            ackAllPromise.then(
                                async.apply(cb, null),
                                async.apply(cb)
                            );
                        }
                    }
                );
            },
            function (num_acks, cb) {
                console.log("Received %d acks", num_acks);
                console.log("Frontier demo1 success!");
                cb(null);
            }
        ],
        function (err) {
            fc.close(true);
            demo_callback(err);
        }
    );
}

async.waterfall([demo1],
    function (err, results) {
        if (!err) {
            console.log("All demos completed successfully");
        } else {
            console.error("Some demos had errors", err);
        }
    }
);
