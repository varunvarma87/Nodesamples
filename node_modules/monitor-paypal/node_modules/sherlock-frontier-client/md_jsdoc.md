## Classes
<dl>
<dt><a href="#SignedInt32">SignedInt32</a></dt>
<dd><p>Emulates signed int32 behavior</p>
</dd>
<dt><a href="#SignedInt32RingBuffer">SignedInt32RingBuffer</a></dt>
<dd><p>A ring buffer of <a href="#SignedInt32">SignedInt32</a> keys which also serves as a map of these keys to some value.
In additional to the basic <code>add</code>, <code>put</code>, and <code>remove</code> is allows to retrieve
a sorted list of keys in temporal order reflecting the order of their insertion.</p>
<p><strong>Note</strong>: in case you&#39;re wondering about what&#39;s special about this class:
 the key can wrap around INT_MAX and become negative, but the temporal order of the keys will still be correct..</p>
<p>All single key operations are delegated to a native JS map for optimal performance.
Method <a href="#SignedInt32RingBuffer#sortedKeyArray">sortedKeyArray</a> is relatively slow as it has to sort the keys on the fly.
This code makes a few assumptions that help optimize implementation:</p>
<ul>
<li>the number of keys held in this map at any point in time is &lt; <code>Math.pow(2,31)</code> or 1/2 of the entire 2^32 range</li>
<li>keys are inserted into this structure in temporal order. This is enforced by
  not having the key as a parameter to <code>add</code> method. The next key is automatically selected using  <a href="#SignedInt32#inc">inc</a>.</li>
</ul>
<p><em>Removal of the keys may be performed in arbitrary order</em>.</p>
</dd>
</dl>
<a name="SignedInt32"></a>
## SignedInt32
Emulates signed int32 behavior

**Kind**: global class  

* [SignedInt32](#SignedInt32)
  * [new SignedInt32(initValue)](#new_SignedInt32_new)
  * _instance_
    * [.inc()](#SignedInt32#inc) ⇒ <code>number</code>
    * [.dec()](#SignedInt32#dec) ⇒ <code>number</code>
  * _static_
    * [.INT_MAX](#SignedInt32.INT_MAX) : <code>number</code>
    * [.INT_MIN](#SignedInt32.INT_MIN) : <code>number</code>

<a name="new_SignedInt32_new"></a>
### new SignedInt32(initValue)
Creates instance of SignedInt32.


| Param | Type | Description |
| --- | --- | --- |
| initValue | <code>Number</code> | initial value; will be converted to int32 |

<a name="SignedInt32#inc"></a>
### signedInt32.inc() ⇒ <code>number</code>
increment the current value and return the result.

**Kind**: instance method of <code>[SignedInt32](#SignedInt32)</code>  
**Returns**: <code>number</code> - - incremented value  
<a name="SignedInt32#dec"></a>
### signedInt32.dec() ⇒ <code>number</code>
Decrement the current value and return the result.

**Kind**: instance method of <code>[SignedInt32](#SignedInt32)</code>  
**Returns**: <code>number</code> - - decremented value  
<a name="SignedInt32.INT_MAX"></a>
### SignedInt32.INT_MAX : <code>number</code>
Max possible value held by this object

**Kind**: static property of <code>[SignedInt32](#SignedInt32)</code>  
<a name="SignedInt32.INT_MIN"></a>
### SignedInt32.INT_MIN : <code>number</code>
Min possible value held by this object

**Kind**: static property of <code>[SignedInt32](#SignedInt32)</code>  
<a name="SignedInt32RingBuffer"></a>
## SignedInt32RingBuffer
A ring buffer of [SignedInt32](#SignedInt32) keys which also serves as a map of these keys to some value.
In additional to the basic ````add````, ````put````, and ``remove`` is allows to retrieve
a sorted list of keys in temporal order reflecting the order of their insertion.

**Note**: in case you're wondering about what's special about this class:
 the key can wrap around INT_MAX and become negative, but the temporal order of the keys will still be correct..

All single key operations are delegated to a native JS map for optimal performance.
Method [sortedKeyArray](#SignedInt32RingBuffer#sortedKeyArray) is relatively slow as it has to sort the keys on the fly.
This code makes a few assumptions that help optimize implementation:

 * the number of keys held in this map at any point in time is < ````Math.pow(2,31)```` or 1/2 of the entire 2^32 range
 * keys are inserted into this structure in temporal order. This is enforced by
     not having the key as a parameter to ````add```` method. The next key is automatically selected using  [inc](#SignedInt32#inc).

*Removal of the keys may be performed in arbitrary order*.

**Kind**: global class  

* [SignedInt32RingBuffer](#SignedInt32RingBuffer)
  * [new SignedInt32RingBuffer(maxEntries, eviction_cb, [startKey])](#new_SignedInt32RingBuffer_new)
  * [.maxEntries](#SignedInt32RingBuffer#maxEntries) : <code>Number</code>
  * [.eviction_cb](#SignedInt32RingBuffer#eviction_cb) : <code>function</code>
  * [.map](#SignedInt32RingBuffer#map) : <code>Object</code>
  * [.key_generator](#SignedInt32RingBuffer#key_generator) : <code>[SignedInt32](#SignedInt32)</code>
  * [.size()](#SignedInt32RingBuffer#size) ⇒ <code>number</code>
  * [.nextKey()](#SignedInt32RingBuffer#nextKey) ⇒ <code>Number</code>
  * [.add(valueBuilder)](#SignedInt32RingBuffer#add) ⇒ <code>Number</code>
  * [.get(key)](#SignedInt32RingBuffer#get) ⇒ <code>\*</code>
  * [.remove(key)](#SignedInt32RingBuffer#remove) ⇒ <code>\*</code>
  * [.sortedKeyArray()](#SignedInt32RingBuffer#sortedKeyArray) ⇒ <code>Array</code>
  * [.reset()](#SignedInt32RingBuffer#reset)

<a name="new_SignedInt32RingBuffer_new"></a>
### new SignedInt32RingBuffer(maxEntries, eviction_cb, [startKey])
Creates an instance of SignedInt32RingBuffer


| Param | Type | Default | Description |
| --- | --- | --- | --- |
| maxEntries | <code>Number</code> |  | the max number of entries to keep at any point in time. |
| eviction_cb | <code>function</code> |  | Eviction callback. Invoked when the ring buffer has reached its max capacity and a new entry is being inserted.      The tail entry will be evicted and this callback is invoked. |
| [startKey] | <code>Number</code> | <code>-1</code> | the starting value of the key generator |

<a name="SignedInt32RingBuffer#maxEntries"></a>
### signedInt32RingBuffer.maxEntries : <code>Number</code>
Max number of entries to keep in the ring buffer.

**Kind**: instance property of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
<a name="SignedInt32RingBuffer#eviction_cb"></a>
### signedInt32RingBuffer.eviction_cb : <code>function</code>
Eviction callback

**Kind**: instance property of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
<a name="SignedInt32RingBuffer#map"></a>
### signedInt32RingBuffer.map : <code>Object</code>
The ring buffer storage.

**Kind**: instance property of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
**Dict**:   
<a name="SignedInt32RingBuffer#key_generator"></a>
### signedInt32RingBuffer.key_generator : <code>[SignedInt32](#SignedInt32)</code>
Key generator for keys in this map.

**Kind**: instance property of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
<a name="SignedInt32RingBuffer#size"></a>
### signedInt32RingBuffer.size() ⇒ <code>number</code>
Retrieve the number of keys currently in the queue

**Kind**: instance method of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
**Returns**: <code>number</code> - - number of entries in the ring buffer  
<a name="SignedInt32RingBuffer#nextKey"></a>
### signedInt32RingBuffer.nextKey() ⇒ <code>Number</code>
Generate the next key in temporal order

**Kind**: instance method of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
**Returns**: <code>Number</code> - - next key  
<a name="SignedInt32RingBuffer#add"></a>
### signedInt32RingBuffer.add(valueBuilder) ⇒ <code>Number</code>
Allocate a new key and insert a value with that key into the map. The value is built by provided function
````valueBuilder````

**Kind**: instance method of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
**Returns**: <code>Number</code> - - the key that was allocated for the new value  

| Param | Type | Description |
| --- | --- | --- |
| valueBuilder | <code>function</code> | a function that receives a newly chosen key; it should return the value  to be inserted into the ring buffer |

<a name="SignedInt32RingBuffer#get"></a>
### signedInt32RingBuffer.get(key) ⇒ <code>\*</code>
Look up an entry with a given key

**Kind**: instance method of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
**Returns**: <code>\*</code> - - the value that is associated with the key or undefined  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>Number</code> | the key to look up |

<a name="SignedInt32RingBuffer#remove"></a>
### signedInt32RingBuffer.remove(key) ⇒ <code>\*</code>
Remove an entry with a given key.

**Kind**: instance method of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
**Returns**: <code>\*</code> - - the value that was associated with the key before removal or undefined  

| Param | Type | Description |
| --- | --- | --- |
| key | <code>Number</code> | the key to remove |

<a name="SignedInt32RingBuffer#sortedKeyArray"></a>
### signedInt32RingBuffer.sortedKeyArray() ⇒ <code>Array</code>
Retrieve the list of keys sorted in the order of their insertion into the ring buffer (temporal order)

**Kind**: instance method of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
**Returns**: <code>Array</code> - - the list of keys sorted in temporal order  
<a name="SignedInt32RingBuffer#reset"></a>
### signedInt32RingBuffer.reset()
Reset the ring buffer; leave the state of the key generator intact.

**Kind**: instance method of <code>[SignedInt32RingBuffer](#SignedInt32RingBuffer)</code>  
