'use strict';
/**
 * Created by yfinkelstein on 12/9/13.
 */


var assert = require("assert");
var SignedInt32RingBuffer = require("../lib/signedint/SignedInt32RingBuffer");
var SignedInt32 = require("../lib/signedint/SignedInt32");

describe('SignedInt32RingBuffer', function () {
    function on_entry_drop(key, value) {
        console.log("key %d with value %j is being dropped", key, value);
    }

    describe('SignedInt32RingBuffer bounded to 5 entries, key starts with default', function () {
        it('#1: basic operations', function () {
            var buff = new SignedInt32RingBuffer(5, on_entry_drop);
            for (var i = 0; i < 10; i++) {
                buff.add(function (key) {
                    return "a" + key;
                });
            }
            assert.equal(buff.size(), 5, "size must be 5, but it is " + buff.size());
            assert.equal(buff.head, 9, "head should be 9 but it is" + buff.head);
            assert.equal(buff.tail, 5, "tail should be 5 but it is" + buff.tail);
            assert.deepEqual(buff.sortedKeyArray(), [5, 6, 7, 8, 9], "actual result is " + buff.sortedKeyArray());

            assert.equal(buff.remove(7), "a7", "expected a7");
            assert.equal(buff.remove(5), "a5", "expected a5");
            assert.equal(buff.remove(5), undefined, "expected undefined");

            assert.equal(buff.head, 9, "head should be 9 but it is" + buff.head);
            assert.equal(buff.tail, 6, "tail should be 6 but it is" + buff.tail);

            assert.equal(buff.size(), 3, "size must be 3, but it is " + buff.size());
        });
    });

    describe('SignedInt32RingBuffer bounded to 5 entries, key starts with a positive value close to INT_MAX', function () {
        it('#2: wrapping of key range', function () {
            var buff = new SignedInt32RingBuffer(5, on_entry_drop, SignedInt32.INT_MAX - 3);
            for (var i = 0; i < 5; i++) {
                buff.add(function (key) {
                    return "a" + key;
                });
            }
            assert.equal(buff.size(), 5, "size must be 5, but it is " + buff.size());
            assert.equal(buff.head, SignedInt32.INT_MIN + 1, "head should be " + (SignedInt32.INT_MIN + 1) + " but it is " + buff.head);
            assert.equal(buff.tail, SignedInt32.INT_MAX - 2, "tail should be " + (SignedInt32.INT_MAX - 2) + " but it is " + buff.tail);

            assert.deepEqual(buff.sortedKeyArray(), [SignedInt32.INT_MAX - 2, SignedInt32.INT_MAX - 1, SignedInt32.INT_MAX,
                SignedInt32.INT_MIN, SignedInt32.INT_MIN + 1
            ], "actual result is " + buff.sortedKeyArray());

            assert.equal(buff.remove(SignedInt32.INT_MAX), "a" + (SignedInt32.INT_MAX), "expected a" + SignedInt32.INT_MAX);
            assert.equal(buff.remove(SignedInt32.INT_MIN + 1), "a" + (SignedInt32.INT_MIN + 1), "expected a" + (SignedInt32.INT_MIN + 1));
            assert.equal(buff.remove(SignedInt32.INT_MIN + 1), undefined, "expected undefined");

            assert.equal(buff.head, SignedInt32.INT_MIN, "head should be " + SignedInt32.INT_MIN + " but it is" + buff.head);
            assert.equal(buff.tail, SignedInt32.INT_MAX - 2, "tail should be " + SignedInt32.INT_MAX - 2 + " but it is " + buff.tail);

            assert.equal(buff.size(), 3, "size must be 3, but it is " + buff.size());
        });
    });


    describe('SignedInt32RingBuffer bounded to 5 entries, key starts with a a negative value close to 0', function () {
        it('#2: wrapping of key range', function () {
            var buff = new SignedInt32RingBuffer(5, on_entry_drop, -8);
            for (var i = 0; i < 10; i++) {
                buff.add(function (key) {
                    return "a" + key;
                });
            }
            assert.equal(buff.size(), 5, "size must be 5, but it is " + buff.size());
            assert.equal(buff.head, 2, "head should be " + 2 + " but it is " + buff.head);
            assert.equal(buff.tail, -2, "tail should be " + (-2) + " but it is " + buff.tail);

            assert.deepEqual(buff.sortedKeyArray(), [-2, -1, 0, 1, 2], "actual result is " + buff.sortedKeyArray());

            assert.equal(buff.remove(0), "a0", "expected a0");
            assert.equal(buff.remove(-1), "a-1", "expected a-1");
            assert.equal(buff.remove(2), "a2", "expected a2");
            assert.equal(buff.remove(2), undefined, "expected undefined");

            assert.equal(buff.head, 1, "head should be 1 but it is" + buff.head);
            assert.equal(buff.tail, -2, "tail should be -2 but it is " + buff.tail);

            assert.equal(buff.size(), 2, "size must be 2, but it is " + buff.size());
        });
    });

});