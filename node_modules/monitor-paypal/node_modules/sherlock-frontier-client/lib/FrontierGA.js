'use strict';

var events = require('events');
var util = require('util');

var WebSocket = require('ws');
var FrontierProto = require('./protocols').FrontierProtoV1;
var SignedInt32RingBuffer = require('./signedint/SignedInt32RingBuffer');
var debug = require('debuglog')('sherlock-frontier-client');
var errorCodeUtil = require('./errorCodeUtil');
var PostReliability = require('./PostReliability');
var VError = require('verror');
var utils = require('./utils');
var tryRequire = require('try-require');
var cal = tryRequire('cal');

var CAL_TRANSCATION_TYPE = 'FRONTIER';

function writeCalEvent(type, key, msg, status) {
    var calEvent;
    status = status || 'ERROR';
    if (cal) {
        calEvent = cal.createEvent(CAL_TRANSCATION_TYPE, type);
        calEvent.status = cal.Status[status];
        if (msg) {
            calEvent.addData(key, msg);
        } else {
            calEvent.addData(key);
        }
        calEvent.complete();
    } else {
        console.error(CAL_TRANSCATION_TYPE, type, key, msg || '');
    }
}

/**
 * Connection-level options;
 * connect_retry:  Should try to re-establish a connection in case of connection loss.
 * connect_retry_interval_sec: Attempt delay to reopen websocket connection after detecting its loss
 * queue_capacity: Request queue size. When max is reached older requests are dropped
 * first_message_id: The initial value of the correlation id; (override for  debugging/testing only)
 * @type {{connect_retry: boolean, connect_retry_interval_sec: number, queue_capacity: number, first_message_id: number}}
 */
function normalizeConfig(options) {

    var nOptions = {
        connect_retry: typeof options.connect_retry !== 'undefined' ? options.connect_retry : true,
        connect_retry_interval_sec: options.connect_retry_interval_sec || 10,
        queue_capacity: options.queue_capacity || 1000,
        first_message_id: options.first_message_id || -1
    };

    return nOptions;
}

var CONSTANTS = {
    CONNECT: 'connect',
    ERROR: 'error',
    WS_CLOSE_CODE_BY_USER: 1001,
    /**
     * This special code means the close is coming from FrontierClientGA and hence there is no need to retry
     * This situation is opposed to another one when the close event is generated from internals of WS Client without
     * signalling and error.
     */
    WS_CLOSE_CODE_ON_ERROR: 3000
};

/**
 * Creates an instance of Frontier client.
 * @param {string} hostAndPort - the endpoint of frontier in the form host:port
 * @param {string} clientGroup - spec for Frontier client group; the format is a=b;c=d;e=f
 * @param {Object} [options] - additional options that control various aspects of the client behavior.

 * @class This class represents a session with Frontier cluster. It manages a persistent connection with one of Frontier servers and exposes a set of APIs
 *  to register metrics and publish time series.
 *
 * @author Yuri Finkelstein
 */
var FrontierClientGA = function (hostAndPort, clientGroup, options) {
    events.EventEmitter.call(this);

    options = options || {};
    this.options = normalizeConfig(options);

    /**
     * A ring buffer of outstanding requests; maps message_id => request callback
     * @type {SignedInt32RingBuffer}
     */
    this.outstandingRequests = new SignedInt32RingBuffer(this.options.queue_capacity,
        evictionCallback.bind(this), this.options.first_message_id);

    this.clientGroup = clientGroup;
    this._numConnections = 0; //internal counter of how many times we open a new ws connection
    this._connect(hostAndPort);
};

util.inherits(FrontierClientGA, events.EventEmitter);
module.exports = FrontierClientGA;


FrontierClientGA.prototype._createWebSocket = function (endpoint) {

    endpoint = endpoint || this.frontierEndpoint;

    var wsUrl = 'ws://' + endpoint + '/api/v1';
    debug('using Frontier URL=%j', wsUrl);

    // this is just a sanity check; it should not happen if everything works as intended
    if (this.ws) {
        return;
    }

    this.session_id = new Buffer('no-session');

    var ws = new WebSocket(wsUrl, { mask: false });
    ws.once('open',    this._onOpen.bind(this));
    ws.on('message',   this._onMessage.bind(this));
    ws.once('error',   this._onError.bind(this));
    ws.once('timeout', this._onError.bind(this));
    ws.once('close',   this._onClose.bind(this));


    this.ws = ws;
    this.frontierEndpoint = endpoint;
    ++this._numConnections;

    return ws;
};

FrontierClientGA.prototype._onOpen = function () {
    if (this.ws) {
        writeCalEvent('open_ws', 'msg', util.format('[%d]connection established, url=%j', this._numConnections, this.ws.url || this.frontierEndpoint), 'SUCCESS');
        this.userInitiatedClose = undefined;
        this._getSession(this._onSessionResponse.bind(this));
    }
};

FrontierClientGA.prototype._onMessage = function (data, flags) {
    var self = this;

    if (!flags.binary) {
        handleError('unexpected message format response from frontier server: ' + flags, self);
        return;
    }
    try {
        var serverMsgEnvelope = FrontierProto.ServerMessageProto.decode(data);
        debug("[%d]received message from server: %j", self._numConnections, serverMsgEnvelope);
        if (serverMsgEnvelope.type === FrontierProto.ServerMessageProto.Type.RESPONSE) {
            self._processResponse(serverMsgEnvelope.server_response.id, serverMsgEnvelope.server_response);
        } else if (serverMsgEnvelope.type === FrontierProto.ServerMessageProto.Type.NOTIFICATION) {
            switch (serverMsgEnvelope.server_notification.type) {
            case FrontierProto.ServerNotificationProto.Type.SESSION:
                var notif = serverMsgEnvelope.server_notification.session_notification;
                switch (notif.type) {
                case FrontierProto.SessionNotificationProto.Type.REDIRECT:
                    var redirectTo = notif.redirect_session.socket_address;
                    writeCalEvent('redirect', 'msg', util.format('[%d]redirecting to another frontier endpoint: %j', self._numConnections, redirectTo), 'SUCCESS');
                    self.close(true);
                    self._createWebSocket(redirectTo.address + ":" + redirectTo.port);
                    break;
                case FrontierProto.SessionNotificationProto.Type.EXPIRED:
                    writeCalEvent('session_expired', notif.expire_cause);
                    handleError("session has expired", self);
                    break;
                }
                break;
            default:
                writeCalEvent('type_error', util.format('Unexpected FrontierProto.ServerNotificationProto.Type: %s', serverMsgEnvelope.server_notification));
                break;
            }
        } else {
            handleError(new Error("Unexpected type of FrontierProto.ServerMessageProto: " + serverMsgEnvelope), self);
        }
    } catch (e) {
        writeCalEvent('onmessage_error', util.format('ws.onmessage exception: %s, flags=j', e, flags));
        self.close(false);
    }
};

FrontierClientGA.prototype._onError = function (error) {
    var self = this;
    debug("[%d]websocket connection error: %j", self._numConnections, error);
    handleError(new VError(error, "websocket client error in connection %d", self._numConnections), self);
};

FrontierClientGA.prototype._onClose = function (code, detail) {
    debug("[%d]websocket connection is closed with code: %j and message: %s, userInitiatedClose=%s",
            this._numConnections, code, detail, this.userInitiatedClose);

    this.close(false);

    //since we already invoke scheduleReconnectIfRequired within CONSTANTS.ERROR handler where we also
    //close this ws connection, consider scheduling reconnect only in case this 'close' event was received
    //for a different reason (ex: Frontier server crash)
    if (code !== CONSTANTS.WS_CLOSE_CODE_ON_ERROR) {
        this.scheduleReconnectIfRequired(this._numConnections);
    }
};

FrontierClientGA.prototype.scheduleReconnectIfRequired = function () {
    if (!this.userInitiatedClose && this.options.connect_retry) {
        if (!this._retryTimer) {
            this._retryTimer = setTimeout(function () {
                this._retryTimer = null;
                this.close(true);
                this._createWebSocket();
            }.bind(this), this.options.connect_retry_interval_sec * 1000);
            this._retryTimer.unref();
        }
    } else {
        debug('[%d]scheduleReconnectIfRequired() won\'t reconnect', this._numConnections);
    }
};

/**
 * Establish physical connection channel with Frontier server
 * @param hostAndPort
 * @private
 */
FrontierClientGA.prototype._connect = function (hostAndPort) {

    var self = this;

    /**
    * For internal use. Sends a binary buffer to the the underlying websocket and handles its callback.
    * **Note**: the callback is invoked immediately after the message was accepted by websocket transport. The actual Frontier server
    * response is handled by on ("message" ...) handler above.
    * @param request - request object
    * @private
    */
    this._send0 = function (request) {

        //set the session_id on the request
        var requestNeedsSession = utils.getRequestEnvelope(request);

        if (requestNeedsSession) {
            requestNeedsSession.session_id = self.session_id;
        }

        self.ws.send(request.envelope.toBuffer(), {
            binary: true,
            mask: true
        }, function (err) {
            if (err) {
                // this happens when there is something wrong with the websocket connection
                if (request.reliability !== PostReliability.BEST_EFFORT) {
                    safe_client_cb(request.cb, err);
                }
                handleError(err, self);
            } else if (request.reliability !== PostReliability.ENSURE_ACK &&
                request.reliability !== PostReliability.ENSURE_PROCESSED) {
                // expedite client callback since the client does not want to wait for the actual server response.
                self._processResponse(request.message_id, null /*no server msg envelope*/ , request);
            }
        });
    };

    // connect retry loop
    this._createWebSocket(hostAndPort);
};

function handleError(error, self) {
    if (self) {
        writeCalEvent('error', util.format("[%d]closing Frontier connection on error: %j", self._numConnections, error));
        self.close(false);
        self.scheduleReconnectIfRequired();
    }
}


/**
 * Close Frontier connection
 * @param userInitiatedClose - boolean flag, (optional); if not present or is false - the client will attempt
 * to re-open the connection if global option **Options.connect_retry** is set to true
 */
FrontierClientGA.prototype.close = function (userInitiatedClose) {
    var ws;

    if (!this.ws) {
        return;
    }
    ws = this.ws;

    /**
     * Indicates that this connection was closed by the user and no connection retries are required.
     * @type {boolean}
     */
    this.userInitiatedClose = this.userInitiatedClose || ((userInitiatedClose === undefined ? true : userInitiatedClose));
    debug('trying to close websocket...');

    try {
        // Keep error listener. There could be a hanging connection that
        // will timeout later and we don't want to crash things
        ws.removeAllListeners();
        ws.on('error', function onerror() {}); // catch all errors after this

        if (this.userInitiatedClose) {
            ws.close(CONSTANTS.WS_CLOSE_CODE_BY_USER, 'Bye');
        } else {
            ws.terminate();
        }

        ws = null;
    } catch (e) {
        //No ops
        handleError(new VError(e, "websocket close failed"), this);
    }
    this.ws = null;

};

FrontierClientGA.prototype._onSessionResponse = function (err, response) {
    if (err) {
        //TODO what should we do on getSession error?
        handleError(new VError(err, "getSession failed on connection %d", this._numConnections), this);
        return;
    }
    if (response.status === FrontierProto.GetSessionRespProto.Status.REDIRECT) {
        var redirectTo = response.redirect_session.socket_address;
        debug("[%d]we are being redirected to another frontier endpoint: %j", this._numConnections, redirectTo);
        this.close(true);
        this._createWebSocket(redirectTo.address + ":" + redirectTo.port);
    } else if (response.status === FrontierProto.GetSessionRespProto.Status.SUCCESS) {
        this.session_id = response.session_info.id;
        debug("[%d]Successfully connected to master frontier node: %s (session=%s)", this._numConnections, this.frontierEndpoint, this.session_id);
        try {
            this.emit(CONSTANTS.CONNECT, null, this.frontierEndpoint);
        } catch (client_error) {
            writeCalEvent('client_error', client_error);
        }

        // resubmit previously enqueued requests
        this.outstandingRequests.sortedKeyArray().forEach(function (message_id) {
            var invocation = this.outstandingRequests.get(message_id);
            if (invocation.envelope.type !== FrontierProto.ReqRespTypeProto.GET_SESSION) {
                debug("[%d]resubmitting request of type %d with message id %d", this._numConnections, invocation.envelope.type, message_id);
                this._send0(invocation);
            } else {
                //drop old GET_SESSION requests since they are obsolete now
                this.outstandingRequests.remove(message_id);
            }
        }.bind(this));

    } else {
        handleError(new Error("unknown server response status: %j", response), this);
    }
};

/**
 * Request a session over already existing physical connection.
 * Frontier server supports multiple sessions over single connection, hence each session receives a unique ID
 * which has to be provided with every subsequent request.
 * @param {Function} [cb] - completion callback;
 *      receives request error or the session_id
 * @private
 */
FrontierClientGA.prototype._getSession = function (cb) {
    var self = this;
    var clientMsgEnvelope = new FrontierProto.ClientRequestProto({
        type: FrontierProto.ReqRespTypeProto.GET_SESSION,
        get_session_request: {
            user_pair: utils.adaptClientGroup(self.clientGroup)
        }
    });
    this._send(clientMsgEnvelope, PostReliability.ENSURE_ACK, cb);
};

/**
 * Register a set of metrics and obtain their Frontier ids.
 * @param metric_set - metric set structure understood by Frontier
 * @param {Function} [cb] - completion callback;
 *      receives request error or the list of registered metric ids
 */
FrontierClientGA.prototype.register = function (metric_set, cb) {
    var clientMsgEnvelope = utils.getRegisterClientMsgEnvelope(metric_set);
    this._send(clientMsgEnvelope, PostReliability.ENSURE_ACK, cb);
};

/**
 * Post metric samples for previously registered metrics
 * @param timestampSec - time, in seconds
 * @param metric_ids - array of binary ids returned by {@link FrontierClientGA#register} call
 * @param samples - array of sample values
 * @param reliability {PostReliability} - reliability level for this request
 * @param {Function} [cb] - completion callback;
 *  receives error or response data
 */
FrontierClientGA.prototype.post = function (timestampSec, metric_ids, samples, reliability, cb) {
    var clientMsgEnvelope = utils.getPostRegisterClientMsgEnvelope(timestampSec, metric_ids, samples, reliability);
    this._send(clientMsgEnvelope, reliability, cb);
};

/**
 * Post metric samples without having the metric ids (registration is still performed by the server)
 * @param timestampSec - time, in seconds
 * @param metric_set - a set of metric descriptors (metadata)
 * @param samples - array of sample values
 * @param reliability {PostReliability} - reliability level for this request
 * @param {Function} [cb] - completion callback;
 *  receives error or the response from server
 */
FrontierClientGA.prototype.postUnregistered = function (timestampSec, metric_set, samples, reliability, cb) {
    var clientMsgEnvelope = utils.getPostUnregisterClientMsgEnvelope(timestampSec, metric_set, samples, reliability);
    this._send(clientMsgEnvelope, reliability, cb);
};


/**
 * For internal use. Performs serialization of the clientMsgEnvelope, enqueueing of the request, and dispatching it
 *  to {@link FrontierClientGA#_send0} if the underlying websocket connection is up.
 * @param clientMsgEnvelope
 * @param reliability {PostReliability} - reliability level for this request
 * @param cb {Function} - user-provided completion callback.
 * @private
 */
FrontierClientGA.prototype._send = function (clientMsgEnvelope, reliability, cb) {
    function buildRequest(message_id) {
        clientMsgEnvelope.id = message_id;
        debug('sending message envelope: %j', clientMsgEnvelope);
        try {
            return {
                message_id: clientMsgEnvelope.id,
                envelope: clientMsgEnvelope,
                reliability: reliability,
                cb: cb,
                sent_at: Date.now()
            };
        } catch (err) {
            handleError(new VError(err, "message sending error %d", this._numConnections), this);
            safe_client_cb(cb, err);
            return null;
        }
    }
    var needEnqueueing = (reliability !== PostReliability.BEST_EFFORT);
    var request = needEnqueueing ?
        this.outstandingRequests.get(this.outstandingRequests.add(buildRequest)) :
        buildRequest(this.outstandingRequests.nextKey());

    if (request) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this._send0(request);
        } else {
            if (needEnqueueing) {
                debug('No connection. Deferring invocation with message_id=%d', clientMsgEnvelope.id);
            } else {
                debug('No connection. Dropping invocation with message_id=%d', clientMsgEnvelope.id);
            }
        }
    }
};

/**
 * Invoked by the {@link FrontierClientGA#outstandingRequests} when an entry os being purged due to buffer overflow
 * @param message_id
 * @param request
 * @private
 */
function evictionCallback(message_id, request) {
    debug("Request of type %d with message id %d is being dropped since the queue is full", request.envelope.type, message_id);
    safe_client_cb(request.cb, new Error("request " + message_id + " is being dropped since request buffer is full"));
}

/**
 * For internal use. Removes the corresponding client invocation from the request queue and invokes client callback
 * @param message_id - request correlation id
 * @param response - the actual server message envelope; may be undefined when this method is called by _send0
 *  if client wants PostReliability.ENSURE_TRANSMISSION
 * @param client_request - original client request
 * @private
 */
FrontierClientGA.prototype._processResponse = function (message_id, response, client_request) {
    var request = this.outstandingRequests.remove(message_id);

    if (!request && response) {
        debug("received server response with unknown message_id: %d", message_id);
        writeCalEvent('unknown_id', 'received server response with unknown message_id: %d', message_id);
    } else {
        if (!request) {
            request = client_request;
        }

        var latency = Date.now() - request.sent_at;

        try {
            if (response) {
                response = utils.serverResponseWrap(response);
                if (response.status === FrontierProto.ServerResponseProto.Status.SUCCESS) {
                    safe_client_cb(request.cb, null, response.body, latency);
                } else {
                    // handle error
                    var errorStatusCode = errorCodeUtil.errorStatusFromCode(response.err_code);
                    writeCalEvent('response_error', 'processResponse error: %s %s', errorStatusCode, response.err_msg);
                    safe_client_cb(request.cb, {
                        status: errorStatusCode,
                        details: response.err_msg,
                        response: response.body
                    }, null, latency);
                }
            } else {
                safe_client_cb(request.cb, null, null, latency);
            }
        } catch (e) {
            writeCalEvent('response_error','processResponse caught error: %j', e);
            request.cb(e);
        }
    }
};

FrontierClientGA.CONNECT = CONSTANTS.CONNECT;
FrontierClientGA.ERROR = CONSTANTS.ERROR;
FrontierClientGA.ErrorCode = errorCodeUtil.ErrorCodes;
FrontierClientGA.PostReliability = PostReliability;

function safe_client_cb(cb /* ... */) {
    try {
        cb && cb.apply(null, Array.prototype.slice.call(arguments, 1));
    } catch (client_error) {
        writeCalEvent('callback_error', 'msg', util.format('safe_client error: %j', client_error));
    }
}
