'use strict';

var FrontierProto = require('./protocols').FrontierProtoV1;

/**
 * Enumerated values that control reliability of {@link FrontierClientGA#post} and {@link FrontierClientGA#postUnregistered} requests.
 * @namespace
 * @readonly
 * @enum
 * @type {object}
 */
module.exports = {
    /**
     * The lowest level of concern. The client will make only one attempt to dispatch this post request.
     * If the underlying websocket connection is not available at the time of this call the request will be discarded.
     * @instance
     */
    BEST_EFFORT: {
        value: 0,
        name: 'best_effort',
        concern: FrontierProto.PostConcernProto.UNACKNOWLEDGED
    },

    /**
     * Medium level of reliability. The client will ensure that the request was handed over to the underlying websocket
     * connection at the time this connection was up. If the connection was down at the time of the request or if websocket connection
     * caused an exception at the time of sending the request - the request will be enqueued in {@link FrontierClientGA#outstandingRequests}
     * and re-sent once the websocket connection is re-established. If the user provided a completion callback as the
     * last argument to {@link FrontierClientGA#post} that callback will be invoked upon successful invocation of ``_socket.write`` or with error if it occurred.
     *
     * **Note**: This is a good method to ensure that the client socket buffer is not congested and that the connection
     *  with Frontier server is basically healthy.
     *
     * @instance
     */
    ENSURE_TRANSMISSION: {
        value: 1,
        name: 'ensure_transmission',
        concern: FrontierProto.PostConcernProto.UNACKNOWLEDGED
    },

    /**
     * High level of reliability. The behavior is similar to that of {@link ENSURE_TRANSMISSION}
     * except the client is requesting an ack response from the server confirming successful receipt and decoding of this POST request.
     * Until this happens the client will keep the request in {@link FrontierClientGA#outstandingRequests} queue and will resend it
     * in the case of connection loss followed by reconnect.
     * Note that server ack is issued before the actual processing of the message. As such, if the server fails to process the message
     * for whatever reason the client won't know about it.
     * @instance
     */
    ENSURE_ACK: {
        value: 2,
        name: 'ensure_ack',
        concern: FrontierProto.PostConcernProto.ACKNOWLEDGED
    },

    /**
     * The highest level of reliability. The behavior is similar to that of {@link ENSURE_ACK}
     * except the server replies after the actual processing of the message.
     * @instance
     */
    ENSURE_PROCESSED: {
        value: 3,
        name: 'ensure_processed',
        concern: FrontierProto.PostConcernProto.PROCESSED
    }
};