'use strict';

var SignedInt32 = require('./SignedInt32');

/**
 * Creates an instance of SignedInt32RingBuffer
 * @param {Number} maxEntries - the max number of entries to keep at any point in time.
 * @param {function (number, *)} eviction_cb  - Eviction callback. Invoked when the ring buffer has reached its max capacity and a new entry is being inserted.
 *      The tail entry will be evicted and this callback is invoked.
 * @param {Number} [startKey=-1] - the starting value of the key generator
 *
 * @class A ring buffer of {@link SignedInt32} keys which also serves as a map of these keys to some value.
 * In additional to the basic ````add````, ````put````, and ``remove`` is allows to retrieve
 * a sorted list of keys in temporal order reflecting the order of their insertion.
 *
 * **Note**: in case you're wondering about what's special about this class:
 *  the key can wrap around INT_MAX and become negative, but the temporal order of the keys will still be correct..
 *
 * All single key operations are delegated to a native JS map for optimal performance.
 * Method {@link SignedInt32RingBuffer#sortedKeyArray} is relatively slow as it has to sort the keys on the fly.

 * This code makes a few assumptions that help optimize implementation:
 *
 *  * the number of keys held in this map at any point in time is < ````Math.pow(2,31)```` or 1/2 of the entire 2^32 range
 *  * keys are inserted into this structure in temporal order. This is enforced by
 *      not having the key as a parameter to ````add```` method. The next key is automatically selected using  {@link SignedInt32#inc}.
 *
 * *Removal of the keys may be performed in arbitrary order*.
 */
function SignedInt32RingBuffer(maxEntries, eviction_cb, startKey) {
    /**
     * Max number of entries to keep in the ring buffer.
     * @type {Number}
     */
    this.maxEntries = maxEntries;

    /**
     * Eviction callback
     * @type {function(number, *)}
     */
    this.eviction_cb = eviction_cb;

    /**
     * The ring buffer storage.
     * @type {Object}
     * @dict
     */
    this.map = {};

    /**
     * Key generator for keys in this map.
     * @type {SignedInt32}
     */
    this.key_generator = new SignedInt32(startKey !== undefined ? startKey : -1);

    this._init();
}

SignedInt32RingBuffer.prototype = {
    _init: function () {
        /**
         * The oldest element in the ring buffer
         * @type {number|null}
         */
        this.tail = null;

        /**
         * The youngest element in the ring buffer
         * @type {number|null}
         */
        this.head = null;
    },

    /**
     * Retrieve the number of keys currently in the queue
     * @return {number} - number of entries in the ring buffer
     */
    size: function () {
        return Object.keys(this.map).length;
    },

    /**
     * Generate the next key in temporal order
     * @return {Number} - next key
     */
    nextKey: function () {
        return this.key_generator.inc();
    },

    /**
     * Allocate a new key and insert a value with that key into the map. The value is built by provided function
     * ````valueBuilder````
     * @param {function(number) : *} valueBuilder - a function that receives a newly chosen key; it should return the value
     *  to be inserted into the ring buffer
     * @returns {Number} - the key that was allocated for the new value
     */
    add: function (valueBuilder) {
        var nextKey = this.key_generator.inc();
        var value = valueBuilder(nextKey);
        if (!value) {
            return null;
        }

        this.map[nextKey] = value;

        if (this.size() === 1) {
            this.tail = this.head = nextKey;
        } else {
            this.head = nextKey;
        }

        if (this.size() > this.maxEntries) {
            console.log("SignedInt32RingBuffer: removing oldest entry with key %d since the map size exceeds max size of %d",
                this.tail, this.maxEntries);
            var old_tail = this.tail;
            var old_value = this.remove(this.tail);
            if (this.eviction_cb) {
                this.eviction_cb(old_tail, old_value);
            }
        }
        return nextKey;
    },

    /**
     * Look up an entry with a given key
     * @param {Number} key - the key to look up
     * @returns {*} - the value that is associated with the key or undefined
     */
    get: function (key) {
        return this.map[key];
    },

    /**
     * Remove an entry with a given key.
     * @param {Number} key - the key to remove
     * @returns {*} - the value that was associated with the key before removal or undefined
     */
    remove: function (key) {
        var val = this.map[key];

        delete this.map[key];
        if (val !== 'undefined') {
            if (this.size() === 0) {
                this._init();
            } else {
                if (key === this.tail) {
                    var next = new SignedInt32(key);
                    while (next.inc() !== this.head && !this.map[next.val]) {}
                    this.tail = next.val;
                }
                if (key === this.head) {
                    var prev = new SignedInt32(key);
                    while (prev.dec() !== this.tail && !this.map[prev.val]) {}
                    this.head = prev.val;
                }
            }
        }
        return val;
    },

    /**
     * Retrieve the list of keys sorted in the order of their insertion into the ring buffer (temporal order)
     * @returns {Array} - the list of keys sorted in temporal order
     */
    sortedKeyArray: function () {
        return Object.keys(this.map).map(function (k) {
            return parseInt(k, 10);
        }).sort(this.head > 0 ? compareUpper : compareLower);
    },

    /**
     * Reset the ring buffer; leave the state of the key generator intact.
     */
    reset: function () {
        this.map = {};
        this._init();
    }
};

function compareLower(a, b) {
    return (a < 0 ? a + SignedInt32.P32 : a) - (b < 0 ? b + SignedInt32.P32 : b);
}

function compareUpper(a, b) {
    return a - b;
}

module.exports = exports = SignedInt32RingBuffer;