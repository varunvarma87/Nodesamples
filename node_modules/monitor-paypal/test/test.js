/*global describe:false, it:false, before:false, after:false, afterEach:false*/

'use strict';

var async = require('async'),
    assert = require('assert'),
    express = require('express'),
    tryRequire = require('try-require'),
    testUtils = require('./fixtures/testutils');

var cal = tryRequire('cal');

var app = express();

var config = require('../config/staging');
var Monitor;

process.env.DEPLOY_ENV = 'test';

if (cal) {
    cal.setDefaultWriteStream('console');
}

//monitor shutdown feature missing - right now can't run both +ive and error cases together
//need some work here
describe.skip('monitoring test', function () {
    var wcServer;

    before(function (next) {
        this.timeout(10000);
        Monitor = require('../index');
        // Make Monitor emit stats faster. Supply an endpoint so stats are
        // created and emitted.
        app.use(Monitor.init({interval: 10, name: 'testing', clientEndPoint: config.monitoring.frontierEndpoint }));

        app.get('/http200', function (req, res) {
            res.send(200, 'all done');
        });
        app.get('/http503', function (req, res) {
            res.send(503, "I'm busy right now, sorry.");
        });

        wcServer = app.listen(8011, function () {
            setTimeout(next, 3000);
        });
    });

    after(function (next) {
        wcServer.close(next);
    });


    it('should get back sensible statistics values', function (next) {
        this.timeout(100000);

        // Catch the stats even Monitor fires every 60 seconds
        Monitor.on('monitorStats', function (stats) {
            if (stats.http2XX < 10) {
                return;
            }
            console.log('STATS', stats);
            assert.equal(1, stats.noWorkers);
            assert.equal(0, stats.renderTime);
            assert.equal(0, stats.sessionSize);
            var evtLoopTime = stats.eventLoop >= 0 && stats.eventLoop < 500;
            assert.ok(evtLoopTime, "eventLoop Time out of range" + stats.eventLoop);
            assert.equal(12, stats.maxCookieSize);
            assert.ok(stats.maxConcurrentRequests >= 0 && stats.maxConcurrentRequests <= 1);
            assert.equal(10, stats.http2XX);
            assert.equal(0, stats.http3XX);
            assert.equal(1, stats.http5XX);
            assert.equal(0, stats.http4XX);
            // Verfiy no undefined values
            for (var prop in stats) {
                if (typeof stats[prop] === 'undefined') {
                    assert.fail(stats[prop], 0, "undefined value in stats" + prop);
                }
            }
        });

        function hitPages() {
            testUtils.inject('/http503', function (err, resBody, statusCode) {
                setTimeout(function () {
                    assert.ok(!err);
                    assert.equal(503, statusCode);
                }, 100);
            });

            async.timesSeries(10, function (i, cb) {
                testUtils.inject('/http200?i=' + i, function (err, resBody, statusCode) {
                    setTimeout(function () {
                        assert.ok(!err);
                        assert.equal(200, statusCode);
                        cb();
                    }, 100);
                });
            });
        }

        hitPages();

        setTimeout(hitPages, 40000);

        setTimeout(next, 70000);

    });

});
