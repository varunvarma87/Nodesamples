/*global describe:false, it:false, before:false, after:false, afterEach:false*/

'use strict';

var path = require('path'),
    assert = require('assert'),
    express = require('express'),
    tryRequire = require('try-require'),
    testUtils = require('./fixtures/testutils'),
    reportFunctions = require('../lib/reportFunctions'),
    clusterCheck = require('../lib/clusterCheck');

var cal = tryRequire('cal');

var statsChecked = false,
    app = express();

var Monitor;

process.env.DEPLOY_ENV = 'test';

if (cal) {
    cal.setDefaultWriteStream('console');
}

describe('error tests', function () {
    var wcServer;

    before(function (next) {
        Monitor = require('../index');
        // Make Monitor emit stats faster. Supply an endpoint so stats are
        // created and emitted.
        app.use(Monitor.init({interval: 1, name: 'testing', clientEndPoint: 'example.com'}));

        app.get('/', function (req, res) {
            res.send(200, 'all done');
        });
        app.get('/http503', function (req, res) {
            res.send(503, "I'm busy right now, sorry.");
        });
        app.get('/admin/v3console', function (req, res) {
            res.send(200, 'VI done');
        });
        app.get('/cmd', function (req, res) {
            res.send(200, 'cmd done');
        });

        wcServer = app.listen(8011, next);
    });

    after(function (next) {
        wcServer.close(next);
    });


    it('should get back sensible statistics values', function (next) {
        this.timeout(4000);

        // Catch the stats even Monitor fires every 60 seconds
        Monitor.on('monitorStats', function (stats) {
            // Only check these once as later tests may alter them further
            if (statsChecked) {
                return;
            }
            statsChecked = true;
            console.log('STATS', stats);
            assert.equal(1, stats.noWorkers);
            assert.equal(0, stats.renderTime);
            assert.equal(0, stats.sessionSize);
            var evtLoopTime = stats.eventLoop >= 0 && stats.eventLoop < 500;
            assert.ok(evtLoopTime, "eventLoop Time out of range" + stats.eventLoop);
            assert.equal(12, stats.maxCookieSize);
            assert.equal(1, stats.maxConcurrentRequests);
            assert.equal(1, stats.http2XX);
            assert.equal(0, stats.http3XX);
            assert.equal(1, stats.http5XX);
            assert.equal(0, stats.http4XX);
            // Verfiy no undefined values
            for (var prop in stats) {
                if (typeof stats[prop] === 'undefined') {
                    assert.fail(stats[prop], 0, "undefined value in stats" + prop);
                }
            }

            next();
        });

        // Force an http5XX count
        testUtils.inject('/http503', function (err, resBody, statusCode) {
            setTimeout(function () {
                assert.ok(!err);
                assert.equal(503, statusCode);
            }, 100);
        });

        // Make sure admin commands are handled OK
        testUtils.inject('/admin/v3console', function (err, resBody, statusCode) {
            setTimeout(function () {
                assert.ok(!err);
                assert.equal(200, statusCode);
            }, 100);
        });

    });

    it('should just call cmd', function (next) {
        this.timeout(4000);

        // Send a command when already in tooBusy state
        testUtils.inject('/cmd', function (err, resBody) {
            setTimeout(function () {
                assert.ok(!err);
                assert.equal('cmd done', resBody);
                next();
            }, 1200);
        });

    });

    it('should get too busy handler called', function (next) {
        this.timeout(4000);
        // Use special method to cause a tooBusy condition
        Monitor.testTooBusyHandler(1, 8, path.join(__dirname, '/fixtures/tooBusyHandler'));

        // Send a command when already in tooBusy state
        testUtils.inject('/cmd', function (err, resBody) {
            setTimeout(function () {
                assert.ok(!err);
                assert.equal('TOO BUSY RIGHT NOW', resBody);
                next();
            }, 1200);
        });

    });


    it('should call checkHeapFull', function (next) {
        this.timeout(4000);

        reportFunctions.checkHeapFull();
        setTimeout(next, 2000);
    });

    it('should log crash to CAL and return err lines after last crash marker', function (next) {
        var crashLines;

        this.timeout(4000);
        //change the working dir to Fixtures
        process.chdir(path.join(__dirname, 'fixtures', 'crash1'));

        clusterCheck.getRestarts({restarts: 1}, function (err, lines) {
            if (err) {
                assert.fail(1, 1, 'Unexpected error', '-');
                return;
            }
            crashLines = lines.logLines;
        });
        setTimeout(function () {
            assert.equal('Crash at sub4.1\nCalled from main.1\n', crashLines);
            next();
        }, 2000);
    });

    it('should return error lines when no crash marker', function (next) {
        var crashLines;

        this.timeout(4000);
        //change the working dir to Fixtures
        process.chdir(path.join(__dirname, 'fixtures', 'crash2'));

        clusterCheck.getRestarts({restarts: 1}, function (err, lines) {
            if (err) {
                assert.fail(1, 1, 'Unexpected error', '-');
                return;
            }
            crashLines = lines.logLines;
        });
        setTimeout(function () {
            assert.equal('Crash at sub.2\nCalled from main.1\n', crashLines);
            next();
        }, 2000);
    });


    it('should signal SIGTERM', function (next) {
        this.timeout(4000);

        process.emit('SIGTERM');
        setTimeout(next, 2000);
    });

});
