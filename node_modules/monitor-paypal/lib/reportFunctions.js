'use strict';

// Helper functions to gather metrics data
//========================================

var usage = require('usage'),
    fs = require('fs-extra'),
    os = require('os'),
    deployEnv = require('environment-paypal'),
    path = require('path'),
    utils = require('./utils');

var pm2id = 1,
    ooms = 0,
    MAX_HEAP = 1.2e9, // 1.2GB
    maxFileDescriptors;

// Collect memory statistics
module.exports.updateMemory = function updateMemory(stats) {
    var mem = process.memoryUsage();
    stats.rss = Math.round(mem.rss / 1e3); //Kbytes
    stats.heap_used = Math.round(mem.heapUsed / 1e3); //Kbytes
    stats.heap_max = Math.round(mem.heapTotal / 1e3); //Kbytes
};


// Get cpu usage, finalize GC overhead based on total CPU vs % GC used
module.exports.finalUpdateStats = function finalUpdateStats(stats, durationSeconds, callback) {
    usage.lookup(process.pid, {
        keepHistory: true
    }, function (err, result) {
        var cpusec = 0,
            cpuMsec = 0,
            gcOverhead = 0;

        if (err) {
            utils.writeCalEvent('lookup_error', err);
            return callback(err);
        } else {
            // In durationSeconds clock time, we have used result.cpu % in active CPU work.
            // Compute how many seconds that percentage amounts to.
            if (result.cpu && result.cpu !== 0) {
                cpusec = durationSeconds * (result.cpu / 100);
                cpuMsec = cpusec * 1000;
            }

            // stat.gcInterval holds total msec spent in GC work. Compute GC % of CPU used
            if (stats.gcInterval !== 0 && cpuMsec !== 0) {
                gcOverhead = stats.gcInterval / cpuMsec;
            }
            stats.gcInterval = gcOverhead;
            stats.cpu = result.cpu;
            return callback(null, stats);
        }
    });

};

module.exports.updateFileDescriptorCount = function updateFileDescriptorCount(stats) {
    var procPath = '/proc/' + process.pid + '/fd',
        openFdCount;

    try {
        openFdCount = fs.readdirSync(procPath).length;
    } catch (e) {
        openFdCount = 0; // Cannot determine it. Maybe no procfs as on OSX
    }
    stats.availableFileDescriptors = maxFileDescriptors - openFdCount;
};


// Run once at start to get max file descriptors for the process.
module.exports.determineMaxFileDescriptors = function determineMaxFileDescriptors(callback) {
    if (os.platform() === 'win32') {
        callback(null, 0);
        return;
    }
    var exec = require('child_process').exec;

    exec('ulimit -n',
        function (error, stdout) {
            var fdMax = parseInt(stdout, 10);
            if (error !== null) {
                utils.writeCalEvent('ulimit_error', error);
                callback(error, 0);
                return;
            } else {
                maxFileDescriptors = fdMax;
                callback(null, fdMax);
                return;
            }
        });
};

// Check if too little memory left to keep handling requests. If so,
// close server to gracefully finish outstanding ones.
// Note that this is also checked on the non-request path so req may not be available.
module.exports.checkHeapFull = function checkHeapFull(req, data) {
    var mem = process.memoryUsage();

    if (mem.heapUsed > MAX_HEAP) {
        utils.writeCalEvent('heap_error', 'msg', 'Exiting node process as memory usage > 1.2GB ' + mem.heapUsed);
        if (data.intervalId) {
            clearInterval(data.intervalId);
        }
        // For security reasons, only dump if a special option is on for the
        // run. Arbitrary data in app memory could expose all sorts of
        // PII data otherwise.
        if (!deployEnv.isDev()) {
            if (process.env.NODE_HEAPDUMP_OPTIONS === 'dump') {
                var heapdump = require('heapdump');
                var heapdumpPath = './logs/' + Date.now() + '.heapsnapshot';
                heapdump.writeSnapshot(heapdumpPath);
            }
            reportOutOfMemoryError();
        }
        console.error(utils.timestamp(), 'monitor-paypal:OutOfMemory:shutdown');
        /*eslint no-process-exit:0 */
        process.exit(1);
    }
};


function getOOMFile() {
    var oomCountsFile;
    if (process.env.pm_id) {
        pm2id = parseInt(process.env.pm_id, 10) + 1;
    }
    oomCountsFile = path.resolve('./logs/oom_' + pm2id);
    return oomCountsFile;
}
// At startup, used to get last known Out of Memory (OOM) error count.
// Returns current count of such errors.
function initOutOfMemoryError() {
    var oomCountsFile = getOOMFile();

    if (fs.existsSync(oomCountsFile)) {
        ooms = fs.readFileSync(oomCountsFile, 'utf8');
        ooms = Number(ooms);
    }
    return ooms;
}

// Used to report an Out Of Memory (OOM) error
function reportOutOfMemoryError() {
    var oomCountsFile = getOOMFile();

    ooms += 1;
    try {
        fs.writeFileSync(oomCountsFile, ooms + '');
    } catch (e) {
        //No op
    }
    return ooms;
}

module.exports.initOutOfMemoryError = initOutOfMemoryError;
