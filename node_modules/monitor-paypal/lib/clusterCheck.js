'use strict';

/* getClusterId returns a small integer number to use with
 * metrics reporting.
 *
 * getRestarts(options, callback) increments the restart count on disk
 * and returns the cumulative count.
 *
 */
var path = require('path'),
    fs = require('fs-extra'),
    os = require('os'),
    cal = require('cal'),
    utils = require('./utils'),
    shell = require('shelljs'),
    deployEnv = require('environment-paypal');

var sendCrashMail = require('./sendCrashMail').sendCrashMail,
    getId = require('instance-detect-paypal').getInstanceId;

var theId,
    fromPP = 'website@paypal.com',
    RESTARTED_AT = '--- restarted at:',
    toPP = 'DL-PP-NodeJS-LiveMonitoring@paypal.com';


module.exports.getClusterId = function getClusterId() {

    theId = getId();
    return theId;
};

// Called when starting up and so also gets called on a restart
// which is when we collect the number of restarts to report and
// bump the number of restarts done.
module.exports.getRestarts = function getRestarts(options, callback) {
    var restartCountsFile,
        logLines,
        restarts = 0,
        restartCount;

    // Testing sets options.restarts. Not set otherwise.
    if (options.restarts) {
        logLines = sendCrashEmail(options, options.restarts, 1);
        return callback(null, {logLines: logLines});
    }

    if (!deployEnv.isDev()) {
        restartCountsFile = path.resolve('./logs/restarts_' + theId);
        if (fs.existsSync(restartCountsFile)) {
            restartCount = fs.readFileSync(restartCountsFile, 'utf8');
            restarts = Number(restartCount) + 1;
            sendCrashEmail(options, restarts, theId);
        }
        try {
            fs.writeFileSync(restartCountsFile, restarts + '');
        } catch (e) {
            //No op
        }
    }

    // OK to report 1 worker. With clustering we are each a separate process
    // and Sherlock will count up how many are reporting 1 worker
    var health = {
        noWorkers: 1,
        restarts: restarts
    };
    return callback(null, health);
};

function sendCrashEmail(options, restartCount, instanceId) {
    var from,
        to,
        logLines,
        userToAddr,
        stageToAddr;

    // Get error log lines of interest and log the crash event to CAL
    logLines = logCalCrashEvent(instanceId, restartCount);

    // Stop reporting after 25 restarts. Don't be a spammer.
    if (restartCount > 25) {
        return null;
    }
    from = fromPP;
    to = toPP;
    var subject = options.pool + " just restarted on " + os.hostname() + ":" + instanceId + " for time " + restartCount;
    if (restartCount === 25) {
        subject = options.pool + " just restarted on " + os.hostname() + ":" + instanceId + " Exceeded report limit of 25. No more report emails will be sent";
    }

    // Get any user-supplied "to" addresses
    var tos = options.monitor;
    if (tos) {
        userToAddr = tos.toAddr;
        stageToAddr = tos.stageToAddr;
    }
    if (userToAddr) {
        to = to + ',' + userToAddr;
    }
    if (deployEnv.isStage()) {
        if (!stageToAddr) {
            return null; // No mail if stage and no user-given addr
        }
        to = stageToAddr; // This removes LIVE MONITORING DL recipient
    }

    // Setup mailing options
    var opts = {
        smtphost: options.coloMx,
        subject: subject,
        from: from,
        to: to,
        logLines: logLines
    };
    sendCrashMail(opts);
    return logLines;
}

function logCalCrashEvent(instanceId, crashCount) {
    var calEvent,
        logLines;

    logLines = getRecentErrorLogLines(instanceId);

    if (cal) {
        calEvent = cal.createHeartbeat('CRASH', 'error');
        calEvent.status = cal.Status.ERROR;
        calEvent.addData('crashCounter', crashCount);
        calEvent.addData('error', logLines);
        calEvent.complete();
    }

    // Put new restart time marker at end of error log
    console.error(RESTARTED_AT, utils.timestamp(), '---');
    return logLines; // for email use

}

// Returns error log lines following the last prior restart since
// these are the only ones of interest to this report.
function getRecentErrorLogLines(instanceId) {
    var idx,
        errLogPath,
        latestCrashLines;

    errLogPath = getErrlogPath(instanceId);
    if (!errLogPath) {
        return '';
    }

    // Find the last error lines following previous server restart marker.
    // It wll return everything from start of log if no prior restart.
    latestCrashLines = shell.exec('/usr/bin/tail -100 ' + errLogPath, '{silent: true}').output;
    // latestCrashLines = logInfo;
    idx = latestCrashLines.lastIndexOf(RESTARTED_AT);
    if (idx !== -1) {
        latestCrashLines = latestCrashLines.substr(idx);
        idx = latestCrashLines.indexOf('\n');
        if (idx !== -1) {
            latestCrashLines = latestCrashLines.substr(idx + 1);
        }
    }
    return latestCrashLines;
}

// Determines path to error log file
function getErrlogPath(instanceId) {
    var logfile = path.resolve(process.cwd(), 'logs', 'err.log');
    if (!fs.existsSync(logfile)) {
        // pm2 path for err log files
        logfile = path.resolve(process.cwd(), 'logs', 'err-' + (instanceId - 1) + '.log');
        if (!fs.existsSync(logfile)) {
            logfile = undefined;
        }
    }
    return logfile;
}
