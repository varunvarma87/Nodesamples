'use strict';

var tooBusy = require('toobusy-js'),
    utils = require('./utils'),
    deepcopy = require('deepcopy'),
    tryRequire = require('try-require'),
    reportMetrics = require('./reportMetrics'),
    reportFunctions = require('./reportFunctions'),
    metric = require('./metrics');

var updateMemory = reportFunctions.updateMemory,
    finalUpdateStats = reportFunctions.finalUpdateStats,
    checkHeapFull = reportFunctions.checkHeapFull,
    updateFileDescriptorCount = reportFunctions.updateFileDescriptorCount;

var gcstats,
    theOptions,
    theEmitter,
    intervalProcessingStarted,
    stats = {},
    data = {
        intervalId: null,
        duration: Date.now() // time from last stats flush to now
    };


// Starts monitoring processes (node-gcstats, interval to report metrics)
function start(options, emitter) {

    theEmitter = emitter;
    theOptions = options;

    // couchbase crashes if gc-stats is being used. Question/issue raised
    // with couchbase.org. Hopefully they will fix it and we won't
    // need to turn off GC stats collection for couchbase-using apps
    // couchbase crashes if gc-stats is being used. Question/issue raised
    // with couchbase.org. Hopefully they will fix it and we won't
    // need to turn off GC stats collection for couchbase-using apps
    // It appears to only affect OSX so limit disabling to Macs.
    var dukes;
    var couchbase;
    var mongodb;

    if (process.platform === 'darwin') {
        dukes = tryRequire('dukes-client-inc');
        couchbase = tryRequire('couchbase');
        mongodb = tryRequire('mongodb');
    }
    // If none are in use or not Mac, activate gc-stats
    if (process.platform !== 'darwin' || !couchbase && !dukes && !mongodb) {
        gcstats = new (require('gc-stats'))();

        gcstats.on('stats', function (info) {
            if (info.gctype === 1) {
                stats.gc_count_incremental++;
            } else {
                stats.gc_count++;
            }
            var afterHeapSize = info.after.usedHeapSize || 0;
            stats.heapSizePostGC = Math.round(afterHeapSize / 1e3);
            // Accumulate msec spent doing GC work
            stats.gcInterval += info.pauseMS;
        });
    }

    stats.gc_count = 0;
    stats.gc_count_incremental = 0;
    stats.gcInterval = 0;

    stats.heapSizePostGC = 0; // make sure the property exists

    // Establish setInterval to collect stats every n seconds
    if (!data.intervalId) {
        data.intervalId = setInterval(function () {
            if (!intervalProcessingStarted) {
                intervalProcessingStarted = true;
                checkHeapFull(null, data);
                // Reset stats to collect for the next interval. Preserve the
                // stats accumulated in the prior interval and send.
                preserveStats(deepcopy(stats));
                resetStats();
            }
        }, options.interval);
        data.intervalId.unref(); // Make sure our interval does not keep node from exiting
    }

    return data.intervalId;
}

// Preserve all the statistics when the interval fires so new counts can start.
function preserveStats(pStats) {
    var nowTime = Date.now();
    var durationSeconds = (nowTime - data.duration) / 1000; // time since last metrics dump
    pStats.eventLoop = tooBusy.lag();
    updateMemory(pStats);
    updateFileDescriptorCount(pStats);
    pStats.maxConcurrentRequests = metric.maxConcurrentRequests;
    pStats.urlTime = sanitize(metric.urltime.toJSON().median);
    pStats.eps = sanitize(metric.eps / durationSeconds);
    pStats.http2XX = sanitize(metric.http2XX);
    pStats.http3XX = sanitize(metric.http3XX);
    pStats.http4XX = sanitize(metric.http4XX);
    pStats.http5XX = sanitize(metric.http5XX);
    pStats.renderTime = sanitize(metric.renderTime.toJSON().median);
    pStats.maxCookieSize = sanitize(metric.cookielen.toJSON().max);
    pStats.requestBodySize = sanitize(metric.requestBody.toJSON().median);
    pStats.sessionSize = sanitize(metric.sessionSize);
    pStats.tps = sanitize(metric.requestsReceived / durationSeconds);
    pStats.oomError = pStats.oomError || 0;
    data.duration = nowTime; // reset duration clock
    pStats.uptime = Math.round(process.uptime());
    // Get CPU Usage async and finish up with emitStatistics callback
    finalUpdateStats(pStats, durationSeconds, emitStatistics);
    return pStats;

    // Callback function to handle final emission of statistics
    function emitStatistics(error, eStats) {
        intervalProcessingStarted = false; // Release lock on another interval cycle
        if (error) {
            utils.writeCalEvent('statistics_error', error);
            return;
        }
        // Send stats to anyone interested in them but don't send metrics if no endpoint
        theEmitter.emit('monitorStats', eStats);
        if (theOptions.clientEndPoint) {
            reportMetrics.sendWorker(eStats, function (err) {
                if (err) {
                    utils.writeCalEvent('reporting_error', err);
                }
            });
        }
    }
}

// Reset the statistics that are per reporting interval
function resetStats() {
    stats.gc_count = 0;
    stats.gc_count_incremental = 0;
    stats.gcInterval = 0;
    metric.maxConcurrentRequests = 0;
    metric.urltime.reset();
    metric.eps = 0;
    metric.http2XX = 0;
    metric.http3XX = 0;
    metric.http4XX = 0;
    metric.http5XX = 0;
    metric.renderTime.reset();
    metric.cookielen.reset();
    metric.requestBody.reset();
    metric.sessionSize = 0;
    metric.requestsReceived = 0;
}

function sanitize(num) {
    return +num || 0;
}


module.exports = {
    stats: stats,
    metric: metric,
    data: data,
    start: start,
    tooBusy: tooBusy
};
