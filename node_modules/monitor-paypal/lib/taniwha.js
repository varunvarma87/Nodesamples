'use strict';

var async = require('async'),
    util = require('util'),
    utils = require('./utils'),
    Hoek = require('hoek'),
    onFinished = require('on-finished'),
    deployEnv = require('environment-paypal'),
    tryRequire = require('try-require'),
    EventEmitter = require('events').EventEmitter,

    // Supporting functions
    reportFunctions = require('./reportFunctions'),
    setupOptions = require('./setupOptions').setupOptions,
    clusterCheck = require('./clusterCheck'),
    debuggerUtils = require('./debuggerUtils'),

    reportMetrics = require('./reportMetrics'),
    statsUtil = require('./statsUtil');

var checkHeapFull = reportFunctions.checkHeapFull,
    initOutOfMemoryError = reportFunctions.initOutOfMemoryError;

var isRunning = false,
    requestsInProcess = 0,
    tooBusyHandler,
    maxOpenRequests = 0;

var MAX_REQUESTS_IN_PROCESS = 5;

// Define Monitor to provide event emitting.
// monitorStats is the primary event emitted and has the collected metrics
// for the current interval
var Monitor = function Monitor() {
    // Extend from EventEmitter
    EventEmitter.call(this);
    this.init = setup.bind(this);
    this.testTooBusyHandler = testTooBusyHandler.bind(this);
};

util.inherits(Monitor, EventEmitter);

// Only needed for tests to trigger tooBusy event and test loading handler
function testTooBusyHandler(maxOpen, rip, handler) {
    maxOpenRequests = maxOpen;
    requestsInProcess = rip;
    tooBusyHandler = handler;
}

function testDebugging(req) {
    //http://localhost:8000/meta_debug?operation=memwatch&timeout=120000
    var debugOperation = req.query.operation || 'memwatch';
    var logger = req.query.logger || '';
    var timeout = parseInt(req.query.timeout, 10);
    timeout = Hoek.isInteger(timeout) ? timeout : 0;

    if (logger) {
        //debuggerUtils.logDebugging(logger);
    } else {
        switch (debugOperation) {
        case 'memwatch':
            debuggerUtils.memwatchDebugging(timeout);
            break;
        case 'heapdump':
            debuggerUtils.heapdumpDebugging(timeout);
            break;
        case 'heapdiff':
            debuggerUtils.memDiffDebugging(timeout);
            break;
        case 'v8profiler':
            debuggerUtils.v8profilerDebugging(timeout);
            break;
        }
    }
}

// Configuration would normally be set by config but options is offered
// for testing
function setup(options) {
    // Don't do anything in dev mode
    if (deployEnv.isDev()) {
        return noop;
    }

    // Don't start monitoring interval timer twice.
    if (isRunning) {
        return noop;
    }

    isRunning = true;
    options = options || {};

    /*jshint validthis:true */
    var self = this;
    var setOptions = setupOptions.bind(self, options);
    tooBusyHandler = options.tooBusyHandler;
    maxOpenRequests = options.maxOpenRequests;
    statsUtil.stats.oomError = initOutOfMemoryError();
    options.metricsId = clusterCheck.getClusterId();
    var clChk = clusterCheck.getRestarts.bind(self, options);

    // Obtain a metricsId for reporting node instances if we are clustered
    async.series([
        setOptions,
        clChk
    ],
    // results callback
    function (err, results) {
        if (err) {
            utils.writeCalEvent('middleware_error', err);
            return; // Don't start monitoring if something bad happened.
        }
        if (results[0]) {
            options = results[0];
        }
        if (results[1]) {
            statsUtil.stats.noWorkers = results[1].noWorkers;
            if (results[1].restarts) {
                statsUtil.stats.restarts = results[1].restarts;
            }
        }

        // Setup reporting config and start repeat interval for sending metrics
        reportMetrics.setConfig(options);

        // Don't send metrics from dev unless user has explicitly specified
        // an endpoint indicating we should do so
        if ((!options.environment || options.environment === 'development') &&
            !options.clientEndPoint) {
            return; // dev mode and no endpoint. Don't collect metrics
        }

        // Start the repeating interval for sending collected metrics
        statsUtil.data.duration = Date.now();
        statsUtil.data.intervalId = statsUtil.start(options, self);
    });

    // Middleware so we can report metrics associated with a request.
    return function taniwha(req, res, next) {
        if (deployEnv.isDev()) {
            return next();
        }

        var _renderOrig;

        var metric = statsUtil.metric;

        if (req.showDebugInfo && req.path === '/meta_debug' && req.hostname === 'localhost') {
            testDebugging(req, res);
            return next();
        }

        // If event loop taking too long send an HTTP 503 response
        // to exert backpressure.
        // On startup, tooBusy reports a large event loop time causing a
        // false rejected request. This is annoying when in dev mode so
        // fudge things to avoid denying first reauest by making sure
        // we are actually taking traffic, e.g more than two requests
        // running at once. If we have less than this, it seems unlikely
        // a tooBusy condition would exist  so this saves the call to
        // check at low traffic loads.
        if (requestsInProcess > MAX_REQUESTS_IN_PROCESS && statsUtil.tooBusy()) {
            shedLoad(req, res, next);
            return null;
        }
        // If too many requests in flight, send an HTTP 503
        // response to exert backpressure.
        if (maxOpenRequests && requestsInProcess > maxOpenRequests) {
            shedLoad(req, res, next);
            return null;
        }

        // Check if heap is too full and we need to exit
        checkHeapFull(req, statsUtil.data);

        // Consider replacing this with making wherever we log CAL RENDER add
        // res.renderTime to the res object where we can pick it rather than
        // do the work twice.
        _renderOrig = res.render;
        res.render = function () {
            var start = Date.now();
            _renderOrig.apply(res, arguments);
            metric.renderTime.update(Date.now() - start);
        };

        // Establish request start time for URL timing. Increment # of requests in process.
        // Bump meter for requests/second.
        res.startingTime = Date.now();
        metric.requestsReceived += 1;
        requestsInProcess += 1;

        // Get size of cookie and body
        if (req.headers.cookie) {
            metric.cookielen.update(req.headers.cookie.length);
        }
        var bodysize = req.headers['content-length'];
        if (bodysize) {
            metric.requestBody.update(parseInt(bodysize, 10));
        }

        // When response is done, collect session size, decrement # of requests in process.
        // Stop URL timing and report time to run URL.
        // Determine urltime, count response type and decrement requests in process
        onFinished(res, function (err, resp) {
            metric.sessionSize = Math.max(metric.sessionSize, utils.getSessionSize(req.session));
            metric.urltime.update(Date.now() - resp.startingTime);
            if (resp.statusCode >= 200 && resp.statusCode <= 299) {
                metric.http2XX += 1;
            } else if (resp.statusCode >= 300 && resp.statusCode <= 399) {
                metric.http3XX += 1;
            } else if (resp.statusCode >= 400 && resp.statusCode <= 499) {
                metric.eps += 1;
                metric.http4XX += 1;
            } else if (resp.statusCode >= 500 && resp.statusCode <= 599 || err) {
                metric.eps += 1;
                metric.http5XX += 1;
            }
            requestsInProcess -= 1;
        });

        // Update max # of requests in process at one time
        metric.maxConcurrentRequests = Math.max(metric.maxConcurrentRequests, requestsInProcess);

        next();

    };

}


// If the user has a tooBusyHandler, call it. If not, just return and accept
// the tooBusy condition and live with it.
function shedLoad(req, res, next) {
    var handler;

    statsUtil.metric.eps += 1;

    if (tooBusyHandler) {
        if (typeof tooBusyHandler === 'function') {
            tooBusyHandler(req, res, next);
            return;
        } else if (typeof tooBusyHandler === 'string') {
            handler = tryRequire(tooBusyHandler);
            if (handler) {
                handler(req, res, next);
                return;
            }
        }
    }
    next();
}

// When we need to do nothing in middleware chain, dev environment
var noop = function noop(req, res, next) {
    if (req.showDebugInfo && req.path === '/meta_debug' && req.hostname === 'localhost') {
        testDebugging(req, res);
    }
    return next && next();
};

module.exports = new Monitor();
