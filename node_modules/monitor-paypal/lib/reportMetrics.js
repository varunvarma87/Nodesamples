'use strict';

var util = require('util'),
    utils = require('./utils'),
    FrontierClient = require('sherlock-frontier-client/lib/FrontierGA');

var async = require('async'),
    os = require('os'),
    metricSet = require('./metricSet');

var fc,
    metricIds,
    clientEndPoint,
    clientGroup,
    env = process.env.NODE_ENV,
    pool,
    reconnectDelay = 0,
    queueCapacity;


module.exports.setConfig = function setConfig(options) {

    var config = require('module-config-paypal')(module);

    queueCapacity = options.queueCapacity || config.get('queueCapacity') || 100;
    var colo = options.colo;

    if (!env) {
        env = 'development';
    }
    clientEndPoint = options.clientEndPoint || config.get('monitoring:frontierEndpoint');
    clientGroup = options.clientGroup || config.get('monitoring:clientGroup');
    // Final value safetying
    pool = options.pool || options.appName || config.get('monitoring:pool') || 'poolUnknown';
    options.metricsId = options.metricsId || 0;
    colo = colo || 'slc'; // default to something

    // Backfill final values into options
    options.clientGroup = clientGroup;
    options.clientEndPoint = clientEndPoint;
    options.colo = colo;
    options.pool = pool;
    options.maxOpenRequests = options.maxOpenRequests || config.get('monitoring:maxOpenRequests') || 0;
    options.environment = env;
    if (!options.clientEndPoint) {
        return; // Don't setup for client if no client defined
    }

    var dims = [{
        name: 'pool',
        value: pool
    }, {
        name: 'instanceId', // Small integer reflecting node instance when clustered
        value: options.metricsId
    }, {
        name: 'colo',
        value: colo
    }, {
        name: 'environment',
        value: env
    }, {
        name: 'host',
        value: os.hostname()
    }];
    metricSet.dimension = dims;
    utils.writeCalEvent('dimensions', 'sherlock', util.format('%j', dims), 'SUCCESS');
    utils.writeCalEvent('options', 'msg', util.format('%j', options), 'SUCCESS');
};

// Clear out fc and metricId so they get reprocessed as a new connection
function resetConnection() {
    if (fc) {
        fc.close(true);
    }
    fc = undefined; // setup to reconnect
    metricIds = undefined;
}

// Determine how long to delay for various possible errors
function dealWithError(err) {
    var minutes;

    switch (err.status) {
    case FrontierClient.ErrorCode.SERVER_ERROR:
        minutes = 15;
        utils.writeCalEvent('suspend_server_error', "Suspend metrics sending for " + minutes + " minutes " + JSON.stringify(err));
        break;

    case FrontierClient.ErrorCode.BAD_CREDENTIALS:
        minutes = 60 * 24; // suspend for 1 day
        utils.writeCalEvent('suspend_bad_credentials', "Suspend metrics sending for " + minutes + " minutes " + JSON.stringify(err));
        break;

    case FrontierClient.ErrorCode.BAD_REQUEST:
        minutes = 60 * 24; // suspend for 1 day
        utils.writeCalEvent('suspend_bad_request', "Suspend metrics sending for " + minutes + " minutes " + JSON.stringify(err));
        break;

    case FrontierClient.ErrorCode.EXCEEDED_RATE:
        minutes = 5;
        utils.writeCalEvent('suspend_exceed_rate', "Suspend metrics sending for " + minutes + " minutes " + JSON.stringify(err));
        break;

    case FrontierClient.ErrorCode.EXCEEDED_QUOTA:
        minutes = 30;
        utils.writeCalEvent('suspend_exceeded_quota', "Suspend metrics sending for " + minutes + " minutes " + JSON.stringify(err));
        break;

    case FrontierClient.ErrorCode.UPSTREAM_TIMEOUT:
        minutes = 5;
        utils.writeCalEvent('suspend_upstream_timeout', "Suspend metrics sending for " + minutes + " minutes " + JSON.stringify(err));
        break;

    case FrontierClient.ErrorCode.UPSTREAM_UNAVAILABLE:
        minutes = 10;
        utils.writeCalEvent('suspend_upstream_unavailable', "Suspend metrics sending for " + minutes + " minutes " + JSON.stringify(err));
        break;

    default:
        minutes = 10;    // Try again in 10 minutes
        utils.writeCalEvent('suspend_unknown_error', "Suspend metrics sending for " + minutes + " minutes " + JSON.stringify(err));
        break;
    }
    resetConnection(); // get a fresh connection and fresh metrics
    return minutes;
}

function postMetrics(stats, postMetricIds, callback) {
    var metricsData = [{
            int32_value: stats.eventLoop
        },
        {
            int32_value: stats.gc_count
        },
        {
            int32_value: stats.gc_count_incremental
        },
        {
            int32_value: stats.heapSizePostGC
        },
        {
            int32_value: stats.heap_max
        },
        {
            int32_value: stats.heap_used
        },
        {
            int32_value: stats.rss
        },
        {
            float_value: stats.gcInterval || 0
        },
        {
            int32_value: stats.oomError || 0
        },
        {
            int32_value: stats.uptime
        },
        {
            int32_value: stats.maxConcurrentRequests
        },
        {
            float_value: stats.urlTime
        },
        {
            int32_value: stats.availableFileDescriptors
        },
        {
            float_value: stats.renderTime
        },
        {
            float_value: stats.eps //errors per second HTTP4xx5xx
        },
        {
            int32_value: stats.http2XX
        },
        {
            int32_value: stats.http3XX
        },
        {
            int32_value: stats.http4XX
        },
        {
            int32_value: stats.http5XX
        },
        {
            float_value: stats.requestBodySize || 0
        },
        {
            int32_value: stats.maxCookieSize || 0
        },
        {
            int32_value: stats.sessionSize || 0
        },
        {
            float_value: stats.tps
        },
        {
            float_value: stats.cpu
        },
        {
            int32_value: stats.noWorkers
        },
        {
            int32_value: stats.restarts || 0
        }
        ];

    fc.post(
        Date.now() / 1000, //timestamp, in seconds
        postMetricIds, // array of binary metric IDs returned by 'register' call
        metricsData,
        FrontierClient.PostReliability.ENSURE_ACK, function (err) {
            if (err) {
                utils.writeCalEvent('post_metrics_failed', err);
                reconnectDelay = dealWithError(err);
            }
            return callback();
        }
    );
}

module.exports.sendWorker = function sendWorker(stats, callback) {

    // If Frontier client (fc) is not defined yet, create it on the first call.
    // We may be delaying from an earlier connect failure, so check first.
    if (reconnectDelay > 0) {
        reconnectDelay--;
        if (reconnectDelay < 0) {
            reconnectDelay = 0; // paranoid in case it gets negative
        }
        return callback(); // Wait for reconnect time to arrive
    }
    if (!fc) {
        utils.writeCalEvent('connect', 'fc', 'connecting to Sherlock endpoint: ' + clientEndPoint, 'SUCCESS');
        fc = new FrontierClient(clientEndPoint, clientGroup, {
            connect_retry: false,
            queue_capacity: queueCapacity
        });
        // Changed from fc.on to fc.once as seems it could leak a listener
        fc.once('error', function (err) {
            utils.writeCalEvent('error_fc', err);
            reconnectDelay = dealWithError(err);
            resetConnection();
            return callback(); // discard this set of metrics
        });
        // If metricIds not yet defined, connect and define them on the first call
        if (!metricIds) {
            async.waterfall(
            [
                fc.once.bind(fc, 'connect'),
                function (frontier_master, cb) {
                    if (fc) {
                        fc.register(metricSet, cb);
                    } else {
                        cb();
                    }
                },
                function (response, reg_latency, cb) {
                    metricIds = response.metric_id;
                    if (metricIds) {
                        postMetrics(stats, metricIds, callback); // post on the first call
                        return;
                    } else {
                        resetConnection();
                    }
                    cb();
                }
            ],
            function waterfallDone(err) {
                if (err) {
                    reconnectDelay = dealWithError(err);
                    resetConnection();
                }
                return callback();
            });
        }

    // metricIds already defined. Just post
    } else if (!metricIds) {
        utils.writeCalEvent('missing_metricIds', 'Frontier metricsIds not defined. Triggering reset and reconnect');
        reconnectDelay = 5; // wait and retry in 5 minutes
        resetConnection();
        return callback();
    } else {
        postMetrics(stats, metricIds, callback);
    }

};
