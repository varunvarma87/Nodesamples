'use strict';

var fs     = require('fs'),
    path   = require('path'),
    assert = require('assert'),
    ppcrypt    = require('../ppcrypt'),
    bufferutil = require('./bufferutil');


var hash  = ppcrypt.hash;
var maths = ppcrypt.maths;

var ALPHABET = 'abcdefghijklmnopqrstuvwxyz';
var ALPHABET_SIZE = ALPHABET.length;
var LOG_26 = Math.log(ALPHABET_SIZE);
var ZERO_MASK = new Buffer([ 0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80 ]);
var BITS_IN_ONE_BYTE = 8;


function toInt(val) {
    var sign = val / Math.abs(val);
    return Math.floor(Math.abs(val)) * sign;
}


function generatePrefix(degree, totalShares) {
    var length, prefix, idx;

    length = getPrefixLength(totalShares);
    prefix = '';
    idx = 0;

    do {
        prefix += ALPHABET.charAt(degree % ALPHABET_SIZE);
        degree /= ALPHABET_SIZE;
        idx += 1;
    } while (idx < length);

    return prefix;
}


function getPrefix(password, totalShares) {
    var length = getPrefixLength(totalShares);
    return password.slice(0, length).toString('ascii');
}


function getPrefixLength(totalShares) {
    return toInt((Math.log(totalShares) / LOG_26) + 1);
}


function getDegree(prefix) {
    var result = ALPHABET.indexOf(prefix.charAt(0));
    var i, mul, len = prefix.length;

    for (i = mul = 1; i < len; ++i) {
        result += (mul * ALPHABET.indexOf(prefix.charAt(i)));
        mul *= ALPHABET_SIZE;
    }

    return result;
}


function readShare(dir, name) {
    var share;

    assert(dir, 'no share directory provided');
    assert(name, 'no share name provided');

    share = path.join(dir, name + '.SHARE');
    return fs.readFileSync(share);
}


function removeSalt(pin, pinLength, saltBits) {
    var key, keyHash, dm, salt, testHash;

    key = pin.slice(0, pinLength);
    keyHash = pin.slice(pinLength);

    if (!saltBits) {
        return key;
    }

    dm = maths.divmod(saltBits, BITS_IN_ONE_BYTE);
    salt = new Buffer(dm[0] + (dm[1] ? 1 : 0));
    salt.fill(0);

    do {

        copyBits(salt, key, saltBits);

        testHash = hash.sha1(key);
        if (bufferutil.equal(keyHash, testHash)) {
            return key;
        }

        incrBits(salt, saltBits);

    } while (!isZero(salt, saltBits));

    return undefined;
}


function copyBits(src, dest, n) {
    var dm, d, m;
    dm = maths.divmod(n, BITS_IN_ONE_BYTE);
    d = dm[0];
    m = dm[1];

    src.copy(dest, 0, 0, d);
    if (m) {
        dest[d] |= ~ZERO_MASK[m];
        dest[d] &= (src[d] | ZERO_MASK[m]);
    }
}


function incrBits(bigint, bits) {
    var dm, d, m, i, b;

    dm = maths.divmod(bits, BITS_IN_ONE_BYTE);
    d = dm[0];
    m = dm[1];

    for (i = 0; i < d; i++) {
        bigint[i] += 1;
        if (bigint[i] !== 0) {
            // no overflow
            break;
        }
    }

    // last byte before the partial-byte and more to go
    if (i === d && m) {
        b = (bigint[d] + 1);
        bigint[d] |= ~ZERO_MASK[m];
        bigint[d] &= (b | ZERO_MASK[m]);
    }
}


function isZero(bigint, bits) {
    var dm, d, m, i;

    dm = maths.divmod(bits, BITS_IN_ONE_BYTE);
    d = dm[0];
    m = dm[1];

    for (i = 0; i < d; i++) {
        if (bigint[i]) {
            return false;
        }
    }

    // XXX: Bitwise operator is intentional
    return !(m && (bigint[d] & ~ZERO_MASK[m]));
}



exports = module.exports = {

    generatePrefix: generatePrefix,

    getPrefix: getPrefix,

    getPrefixLength: getPrefixLength,

    getDegree: getDegree,

    readShare: readShare,

    removeSalt: removeSalt

};
