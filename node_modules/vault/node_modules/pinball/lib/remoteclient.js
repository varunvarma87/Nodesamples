'use strict';

var os   = require('os'),
    tls  = require('tls'),
    events   = require('events'),
    objutil  = require('objutil'),
    ppcrypt  = require('./ppcrypt'),
    assert   = require('./util/apputil').assert,
    pinutil  = require('./util/pinutil'),
    PinClient  = require('./baseclient');


var hash = ppcrypt.hash;
var cipher = ppcrypt.cipher;


function RemoteClient(/*config*/) {
    RemoteClient.super_.apply(this, arguments);

    this._serviceName = undefined;
    this._operation = 'launch';
    this._authCode = undefined;
    this._servers = [];

    this._init();
}

RemoteClient.DEFAULT_PORT = 12351;

objutil.extend(RemoteClient, PinClient, {

    get serviceName() {
        return this._serviceName;
    },

    set serviceName(value) {
        this._serviceName = value;
    },


    get operation() {
        return this._operation;
    },

    set operation(value) {
        this._operation = value;
    },


    get authCode() {
        return this._authCode;
    },

    set authCode(value) {
        this._authCode = value;
    },


    _init: function () {
        var config, value, idx;

        config = this._config;

        this._servers.push({
            host: config.shareserver_name,
            port: parseInt(config.shareserver_port, 10) || RemoteClient.DEFAULT_PORT
        });

        idx = 2;
        while ((value = config['shareserver_name_' + idx])) {
            this._servers.push({ host: value, port: RemoteClient.DEFAULT_PORT });
            idx++;
        }

        idx = 2;
        while ((value = config['shareserver_port_' + idx])) {
            this._servers[idx - 1].port = parseInt(value, 10) || RemoteClient.DEFAULT_PORT;
            idx++;
        }
    },


    _doGetPin: function (callback) {
        var that, servers, shareData;

        that = this;
        servers = this._servers;
        shareData = this._getShareData();

        function connect(idx) {
            var endpoint;

            endpoint = servers[idx];
            if (!endpoint) {
                callback(new Error('Could not connect to shareserv.'));
                return;
            }

            that._request(endpoint.host, endpoint.port, shareData, function (err, pin) {
                if (err) {
                    //console.log('Could not connect (', err.message, ')');
                    connect(idx + 1);
                    return;
                }
                callback(err, pin);
            });
        }

        connect(0);
    },


    _getShareData: function () {
        var idx, len, share, shares;

        shares = [];
        for (idx = 0, len = this._totalShares; idx < len; idx++) {
            share = pinutil.readShare(this._sharePath, pinutil.generatePrefix(idx, len));
            shares.push(share);
        }

        return Buffer.concat(shares);
    },


    _request: function (host, port, shareData, callback) {
        var socket;
        socket = new ShareServSocket(this._serviceName, this._authCode, this._operation, shareData);
        socket.connect(host, port);
        socket.on('error', callback);
        socket.on('pin', function (pin) {
            callback(null, pin);
        });
    }

});






function ShareServSocket(service, authCode, operation, shareData) {
    ShareServSocket.super_.apply(this, arguments);
    this._serviceName = service;
    this._authCode = authCode;
    this._operation = operation;
    this._state = ShareServSocket.State.DISCONNECTED;
    this._conn = undefined;
    this._buffer = new Buffer(0);
    this._shareData = shareData;
    this._responseTimer = undefined;
}

ShareServSocket.CHALLENGE_LENGTH = 32;

ShareServSocket.State = {
    DISCONNECTED: 0,
    CONNECTED: 1,
    CHALLENGE: 2,
    AUTHORIZED: 4,
    OK: 8
};


objutil.extend(ShareServSocket, events.EventEmitter, {

    connect: function (host, port) {
        // TODO: rejectUnauthorized added for 0.10.x to support self-signed certs.
        // See if valid certs are available/necessary.
        this._conn = tls.connect({ host: host, port: port, rejectUnauthorized: false }, this._onConnection.bind(this));
        this._conn.on('data',  this._onData.bind(this));
        this._conn.on('end',   this._onEnd.bind(this));
        this._conn.on('close', this._onClose.bind(this));
        this._conn.on('error', this._onError.bind(this));
        return this;
    },

    _onConnection: function () {
        this._state = ShareServSocket.State.CONNECTED;
    },


    _onData: function (chunk) {
        var crlf, message;

        this._stopTimer();
        this._buffer = Buffer.concat([this._buffer, chunk]);

        if (this._state === ShareServSocket.State.CONNECTED) {

            // Challenge is not delimited by terminating sequences, so with just
            // gotta go with the special knowledge of a know length.
            if (this._buffer.length >= ShareServSocket.CHALLENGE_LENGTH) {
                message = this._buffer.slice(0, ShareServSocket.CHALLENGE_LENGTH);
                this._buffer = this._buffer.slice(ShareServSocket.CHALLENGE_LENGTH);
                message.length && this._onMessage(message);
            }

        } else {

            // Since the terminating sequence ('\r\n') could theoretically come in
            // any chunk, we aggregate chunks and dispatch messages as they get parsed.
            while (~(crlf = this._indexOfCrLf(this._buffer))) {
                message = this._buffer.slice(0, crlf);
                this._buffer = this._buffer.slice(crlf + 2);
                message.length && this._onMessage(message);
            }

            if (this._state === ShareServSocket.State.OK) {
                // No final terminator ('\r\n') is sent, so if we've made it
                // to the last possible state (OK), the remaining message is the pin.
                message = this._buffer;
                this._buffer = new Buffer(0);
                message.length && this._onMessage(message);
            }
        }
    },


    _onEnd: function () {
        var that = this;
        process.nextTick(function () {
            that.emit('end');
        });
    },


    _onClose: function (hadError) {
        if (hadError || this._state !== ShareServSocket.State.OK) {
            // Any non-OK close state is unexpected.
            this._onError(new Error('Connection closed by peer.'));
        }
        // Once everything is cleaned/wrapped up, set state to disconnect
        this._state = ShareServSocket.State.DISCONNECTED;
        this._conn.removeAllListeners();
    },


    _onError: function (error) {
        var that = this;

        // Close the connection if possible
        this._conn.writable && this._conn.destroy();

        // Set state to OK since error has been handled. This will prevent
        // _onClose from re-notifying the error event.
        this._state = ShareServSocket.State.OK;

        if (this.listeners('error')) {
            process.nextTick(function () {
                that.emit('error', error);
            });
            return;
        }

        throw error;
    },


    _onMessage: function (message) {
        switch (this._state) {
        case ShareServSocket.State.CONNECTED:
            this._authorize(message);
            break;

        case ShareServSocket.State.CHALLENGE:
            this._query(message);
            break;

        case ShareServSocket.State.AUTHORIZED:
            if (message.toString('ascii') !== 'NOERR') {
                this._onError(new Error('ShareServ responded with error.'));
            } else {
                this._state = ShareServSocket.State.OK;
            }
            break;

        case ShareServSocket.State.OK:
            this.emit('pin', message);
            this._conn.end();
            break;
        }

    },


    _authorize: function (challenge) {
        var authCode, authClone, i, len, authHash, maskHash, key, iv, ciphertext;

        authCode = this._authCode;
        authClone = new Buffer(authCode, 'ascii');
        for (i = 0, len = authClone.length; i < len; i++) {
            authClone[i] ^= 170;
        }

        authHash = hash.sha1(authCode).slice(0, 12);
        maskHash = hash.sha1(authClone).slice(8, 20);
        key = Buffer.concat([ authHash, maskHash ]);

        iv = new Buffer(8);
        iv.fill(0);

        ciphertext = cipher.tripledes(challenge, key, iv, false);
        this._write(hash.sha1(ciphertext), function () {
            this._state = ShareServSocket.State.CHALLENGE;
        }.bind(this));
    },


    _query: function (authCode) {
        assert.strictEquals(authCode.toString('ascii'), this._authCode, 'Invalid authCode returned. Not authorized.');
        assert(this._operation, 'operation not defined');
        assert(this._serviceName, 'serviceName not defined');

        var payload = [this._operation, this._serviceName, os.hostname(), ''].join('\r\n');
        payload = Buffer.concat([ new Buffer(payload, 'ascii'), this._shareData ]);

        this._write(payload, function () {
            this._state = ShareServSocket.State.AUTHORIZED;
        }.bind(this));
    },


    _write: function (message, callback) {
        var that = this;
        this._conn.write(message, function () {
            that._startTimer();
            callback();
        });
    },


    _startTimer: function () {
        var that = this;
        this._stopTimer();
        this._responseTimer = setTimeout(function () {
            that._onError(new Error('Connection timeout.'));
        }, 5000);
    },


    _stopTimer: function () {
        if (this._responseTimer) {
            clearTimeout(this._responseTimer);
            this._responseTimer = undefined;
        }
    },


    _indexOfCrLf: function (buffer) {
        var idx, len;

        if (!buffer.length) { return -1; }

        idx = 0;
        len = buffer.length - 1;

        // Looking for '\r\n'
        while (idx < len) {
            if (buffer[idx] === 0x0d && buffer[idx + 1] === 0x0a) {
                return idx;
            }
            idx += 1;
        }

        return (idx === len) ? -1 : idx;
    }

});


exports = module.exports = RemoteClient;
