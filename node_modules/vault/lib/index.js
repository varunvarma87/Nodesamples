'use strict';

var path  = require('path'),
    async = require('async'),
    assert  = require('assert'),
    pinball = require('pinball'),
    config  = require('./config'),
    pputil = require('./pputil'),
    util = require('util'),
    sepulcher = require('./sepulcher');


var packages = Object.create(null);


function createPackage(vault) {

    return {
        /**
         * If the key indicates base64 ('b64_' or 'encrypted_' prefix) this method returns bytes, remaining types (strings,
         * objects, buffers) are returned as-is.
         * @param key
         * @returns {*}
         */
        get: function (key) {
            var value = vault.get(key);
            if (Buffer.isBuffer(value)) {
                value = pputil.isBase64(key) ? value : value.toString('ascii');
            }
            return value;
        },

        /**
         * return all the keys with 'encrypted_' prefix
         * @returns {*}
         */
        getEncryptedAll: function () {
            var keyVals = {};
            for (var key in vault._raw) {
                if (key.indexOf('encrypted_') === 0) {
                    keyVals[key] = this.getString(key);
                }
            }
            return keyVals;
        },

        /**
         * If the key indicates base64 ('b64_' or 'encrypted_' prefix) this method returns the value in standard
         * base64 format, otherwise it will coerce all other types to strings.
         * @param key
         * @returns {*}
         */
        getString: function (key) {
            var value = this.get(key);
            if (Buffer.isBuffer(value)) {
                value = pputil.isBase64(key) ? value.toString('base64') : value.toString('ascii');
            }
            return value === undefined ? value : String(value);
        },


        /**
         * Will return a Buffer for base64 and string values, and remaining types will be returned unchanged.
         * @param key
         * @returns {*}
         */
        getBytes: function (key) {
            var value = this.get(key);
            if (typeof value === 'string') {
                // In the off-chance that a base64 key is in string format, this will convert it to a buffer
                value = pputil.isBase64(key) ? pputil.base64Decode(value) : new Buffer(value, 'ascii');
            }
            return value;
        },


        /**
         * Returns an object in the format as described on
         * http://nodejs.org/api/crypto.html#crypto_crypto_createcredentials_details
         *
         * Generally will only contain passphrase, key, and cert
         * @returns Object
         */
        getClientCredentials: function () {
            return this.get('client_credentials');
        },


        /**
         * Returns an object in the format as described in
         * http://nodejs.org/api/crypto.html#crypto_crypto_createcredentials_details
         *
         * Generally will only contain passphrase, key, and cert
         * @returns Object
         */
        getServerCredentials: function () {
            return this.get('server_credentials');
        },

        /**
         * Returns an object containing serialized sessions keyed by week.
         * @returns Object
         */
        getClientSessions: function () {
            return this.get('client_sessions');
        },

        /**
         * Returns an object containing serialized sessions keyed by week.
         * @returns Object
         */
        getServerSessions: function () {
            return this.get('server_sessions');
        },

        /**
         * Returns the session id context.
         * @returns string
         */
        getServerSessionIdContext: function () {
            return this.get('server_session_id_context');
        },

        /**
         * Returns true if the key exists in the package, or false if not.
         * @param key
         * @returns {boolean}
         */
        containsKey: function (key) {
            return (this.get(key) !== undefined);
        }

    };
}

var vault;

exports = module.exports = {

    DEFAULT_NAME: 'nodeweb',


    /**
     * Options object supports:
     * {
     *   name: '',
     *   dir:  '',
     *   passphrase: '',
     *   pin:  '',
     *   pinName:  ''
     * }
     * @param options
     * @param callback
     */
    create: function (options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }

        if (typeof options === 'string') {
            options = { name: options };
        }

        if (!options.env && !options.name) {//DEVELOPMENT
            options.env     = "DEVELOPMENT";
            options.dir     = options.dir || path.resolve(__dirname, '../node_modules/testkeystore');
            options.cfgName = options.cfgName || 'protected.cfg';
            options.keyName = options.keyName || 'key.pem';
            options.certName = options.certName || 'cert.pem';
            options.trustedClientsName = options.trustedClientsName || 'trusted_clients.pem';
            options.trustedServersName = options.trustedServersName || 'trusted_servers.pem';
        } else { //STAGE, LIVE & SANDBOX
            options.dir     = options.dir || options.deployPath || path.join(process.cwd(), 'protected');
            options.cfgName = options.cfgName || util.format('%s_protected.cfg', options.name);
            options.keyName = options.keyName || util.format('%s_key.pem', options.name);
            options.certName = options.certName || util.format('%s_cert.pem', options.name);
            options.trustedClientsName = options.trustedClientsName || util.format('%s_trusted_clients.pem', options.name);
            options.trustedServersName = options.trustedServersName || util.format('%s_trusted_servers.pem', options.name);
        }
        options.name    = options.name || exports.DEFAULT_NAME;
        options.pinName = options.pinName || exports.DEFAULT_NAME.toUpperCase() + '_PIN';
        console.log('Keystore read from: ' + options.dir);

        if (packages[options.name]) {
            // Noop multiple inits. Read from cache.
            callback(null, packages[options.name]);
            return;
        }

        async.waterfall([

            function (next) {
                if (process.env[options.pinName]) {
                    next(null, new Buffer(process.env[options.pinName], 'base64'));
                    return;
                }

                // Read the pin for decryption.
                pinball.read({ name: exports.DEFAULT_NAME, dir: options.dir, env: options.env }, next);
            },

            function (pin, next) {
                pin = pin.toString('base64');
                process.env[options.pinName] = pin;

                // Read and decrypt the config
                var configPath = path.join(options.dir, options.cfgName);
                config.load(pputil.base64Decode(pin), configPath, next);
            },

            function (config, next) {
                sepulcher.create(options, config, next);
            },

            function (impl, next) {
                next(null, packages[options.name] = createPackage(impl));
            }

        ], callback);
    },


    _delete: function (name) {
        if (name in packages) {
            packages[name] = undefined;
            return true;
        }
        return false;
    }

};
