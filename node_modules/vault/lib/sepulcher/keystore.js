'use strict';

// TODO: This was left because it was never committed, then deemed unnecessary, but might be helpful
// in case we need to support Java Key Stores sometime in the future

//var fs   = require('fs'),
//    util = require('util'),
//    path = require('path'),
//    crypto = require('crypto'),
//    ks = require('keystore'),
//    spawn = require('child_process').spawn,
//    Protected = require('./protected');
//
//
//function Keystore(options, config) {
//    Keystore.super_.apply(this, arguments);
//
//    this._passphrase = this._passphrase || config['encrypted_keystore_passphrase'];
//    this._jksFile = path.join(process.cwd(), options.dir, 'protected.jks');
//
//    // These is conditional based on existence of '/protected_client.jks'
//    this._serverPassphrase = config['encrypted_client_keystore_passphrase'];
//    this._serverJksFile = undefined;
//
//    this._sslClientCredentials = undefined;
//}
//
//util.inherits(Keystore, Protected);
//
//
//Keystore.prototype.__defineGetter__('clientCredentials', function () {
//    return this._sslClientCredentials;
//});
//
//
//Keystore.prototype.init = function (callback) {
//    ks.load(this._jksFile, this._passphrase, function (err, data) {
//
//        var entry = data.getKey('stage1_helixserv'),
//            privateKey = entry.privateKey,
//            pubCert = entry.chain[0].data,
//            ca = [];
//
//
//        console.log((new Buffer(privateKey)).toString('hex'));
//
//        data.aliases.forEach(function (alias) {
//            var entry = data.getCertificate(alias);
//            entry && ca.push(this._asCert(entry.cert.data));
//        }.bind(this));
//
//        this._sslClientCredentials = crypto.createCredentials({
//            passphrase: this._passphrase,
//            pfx: new Buffer(privateKey, 'base64'),
//            //cert: this._asCert(pubCert),
//            ca: ca
//        });
//
//        callback(err);
//    }.bind(this));
//
//};
//
//Keystore.prototype._privateKeyPEM = function (entry) {
//    var key = entry.privateKey,
//        certs = entry.chain,
//        result;
//
//    result = this._asKey(key);
//
//    certs.forEach(function (cert) {
//        result += this._asCert(cert.data);
//    }.bind(this));
//
//    return result;
//};
//
//
//Keystore.prototype._asKey = function (str) {
//    var result;
//    result = '-----BEGIN ENCRYPTED PRIVATE KEY-----\n';
//    result += this._addNewLines(str);
//    result += '-----END ENCRYPTED PRIVATE KEY-----\n';
//    return result;
//};
//
//
//Keystore.prototype._asCert = function (str) {
//    var result;
//    result = '-----BEGIN CERTIFICATE-----\n';
//    result += this._addNewLines(str);
//    result += '-----END CERTIFICATE-----\n';
//    return result;
//};
//
//
//Keystore.prototype._addNewLines = function (str) {
//    return str.replace(/(.{1,64})/g, '$1\n');
//};
//
//
//
//Keystore.prototype._readJks = function (callback) {
//    var child = spawn('java', ['KeyToolSucks', this._jksFile, this._passphrase]),
//        out = [], err = [];
//
//    child.stdout.on('data', function (data) {
//        out.push(data);
//    });
//
//    child.stderr.on('data', function (data) {
//        err.push(data);
//    });
//
//    child.on('exit', function (code) {
//        var error, data;
//
//        if (code !== 0) {
//            error = new Error('Unable to read keystore');
//            error.detail = err.join('');
//            error.code = code;
//            callback(error);
//            return;
//        }
//
//        data = JSON.parse(out.join(''));
//        callback(null, this._hex2bin(data));
//
//    }.bind(this));
//};
//
//
//Keystore.prototype._hex2bin = function (obj) {
//    var callee = this._hex2bin.bind(this);
//
//    if (Array.isArray(obj)) {
//        return obj.map(callee);
//
//    } else if (typeof obj === 'object') {
//        Object.keys(obj).forEach(function (key) {
//            obj[key] = callee(obj[key]);
//        });
//        return obj;
//    }
//
//    return new Buffer(String(obj), 'hex');
//};


exports = module.exports = {

//    supports: function (options, callback) {
//        var keystore = path.join(process.cwd(), options.path, 'protected.jks');
//        fs.exists(keystore, function (exists) {
//            callback(null, exists);
//        });
//    },

    supports: function (options, callback) {
        callback(null, false);
    },

    create: function (options, config) {
        throw new Error('Not implemented.');
    }

};