#!/usr/local/bin/perl -w

my $VERSION = "1.0";	# Generates a credit card number for the specified type

#
# Define credit card types by using a two-element definition array.
# The first element is a valid starting number, the second element
# is the number of digits in a valid credit card number of that type.
#
my %CREDIT_CARD_TYPES = (
	"visa" => [ 4, 16 ],
	"mastercard" => [ 51, 16 ],
	"amex" => [ 34, 15 ],
	"switch" => [67, 16]
);
  
#
# Generate a credit card number
#
sub generateCard {
	my ($cardType) = @_;

	# Get the definition array
	my @definitionArray = &getCardType($cardType);

	# Start the number with definition array element 0
	my $ccNumber = $definitionArray[0];

	# and continue generating random numbers until we hit the last number
	my $counter = length($ccNumber);
	while (length($ccNumber) < ($definitionArray[1] - 1)) {
		$ccNumber = $ccNumber.&randomNumber(9);
	}

	# find the last number so that the number will validate
	my $lastNumber = &luhnRequired($ccNumber);

	return $ccNumber.$lastNumber;
}

#
# Get the card definition if it's a valid type. If it's not a
# valid type, get the VISA definition.
#
sub getCardType {
	my ($typeName) = @_;

	# if we have an invalid typeName, default to VISA
	if (&validCardType($typeName) == 0) {
		$typeName = "VISA";
	}

	# force the typeName to lowercase to match the key
	$typeName =~ tr/[A-Z]/[a-z]/;

	my $definitionArray = ();
	$definitionArray[0] = $CREDIT_CARD_TYPES{$typeName}[0];
	$definitionArray[1] = $CREDIT_CARD_TYPES{$typeName}[1];

	return @definitionArray;
}

#
# LUHN is Double-Add-Double-Mod-10-With-Enfolding
#
sub luhn {
	my ($numberToValidate) = @_;

	my $runningTotal = 0;
	my $index = 0;
	my $nextDigit = 0;
	while ($index < (length $numberToValidate)) {
		$nextDigit = substr $numberToValidate, $index, 1;
		if (($index % 2) == 0) {
			$nextDigit *= 2;
		}
		if ($nextDigit > 9) {
			$nextDigit -= 9;
		}
		$runningTotal += $nextDigit;
		$index++;
	}
	return (($runningTotal % 10) == 0);
}

#
# Using a LUHN algorithm, find the last required number
# for a sequence of numbers.
#
sub luhnRequired {
	my ($numberToValidate) = @_;
	my $allButLast = &luhnTotal($numberToValidate);
	my $remainder = $allButLast % 10;
	return (10 - ($remainder == 0 ? 10 : $remainder));
}

#
# Calculate the total of a sequence of numbers, using the
# LUHN algorithm.
#
sub luhnTotal {
	my ($numberToValidate) = @_;

	my $runningTotal = 0;
	my $index = 0;
	my $nextDigit = 0;
	while ($index < (length $numberToValidate)) {
		$nextDigit = substr $numberToValidate, $index, 1;
		if (($index % 2) == 0) {
			$nextDigit *= 2;
		}
		if ($nextDigit > 9) {
			$nextDigit -= 9;
		}
		$runningTotal += $nextDigit;
		$index++;
	}
	return $runningTotal;
}

#
# Primary subroutine
#
sub main {
	my $cardType = "VISA";

	while (@ARGV) {
		if ($ARGV[0] =~ /^-?-t(ype)?$/) {
			&usage() if (! @ARGV);
			shift @ARGV;
			$cardType = $ARGV[0];
		} else {
			#Dump it
			shift @ARGV;
		}
	}
	die &usage if (&validCardType($cardType) == 0);

	print "$cardType: ".&generateCard($cardType)."\n";
}

#
# Generate a random number between 0 and the value passed (inclusive)
#
sub randomNumber {
	my ($maxValue) = @_;
	my $random = int(rand($maxValue + 1));
	return $random
}

#
#
#
sub usage {

	my @validTypes = ();
	foreach $k (keys (%CREDIT_CARD_TYPES))
	{
		push @validTypes, $k;
	}
	my $typeNames = join ", ", @validTypes;

	print qq{
USAGE:
\t creditCard.pl [OPTIONS]

OPTIONS:
\t -t[ype] CARD-TYPE A valid credit card type (i.e. $typeNames)

version $VERSION
};
	exit -1;
}

#
#
#
sub validCardType {
	my ($typeName) = @_;

	# compare, case-insensitive (all keys are in lowercase)
	# if the key doesn't exist, return the key for VISA

	$typeName =~ tr/[A-Z]/[a-z]/;
	
	if (exists $CREDIT_CARD_TYPES{$typeName}) {
		return 1;
	} else {
		return 0;
	}
}

&main;
