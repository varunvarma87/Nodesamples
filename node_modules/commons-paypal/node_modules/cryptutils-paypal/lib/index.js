'use strict';

var assert = require('assert'),
    crypto = require('crypto'),
    constants = require('./constants'),
    ciphers = require('./ciphers'),
    base64 = require('base64-paypal'),
    utils = require('./utils');

exports = module.exports = function createCryptUtil(options) {
    var encAlgorithm, encKey, macAlgorithm, macKey, padding;

    assert.strictEqual(typeof options, 'object', 'Expected an options object.');
    assert.ok(options.encryptionKey, 'Encryption key can not be null.');
    assert.ok(options.macKey, 'Mac key can not be null.');

    encAlgorithm = options.encryptionAlgorithm || 'desx';
    encKey = options.encryptionKey;
    macAlgorithm = options.macAlgorithm || 'sha1';
    macKey = encAlgorithm === 'desx' ? ciphers.desx._truncateKey(options.macKey) : options.macKey;
    padding = !!options.padding;

    return {

        sealAndEncodeNamed: function sealAndEncodeNamed(name, input) {
            return this.sealAndEncode(Buffer.concat([new Buffer(name), input]));
        },

        sealAndEncode: function sealAndEncode(input) {
            return base64.encode(this.seal(input), base64.CharacterSet.PPUUENCODING, false).toString();
        },

        sealAndEncodeBeacon: function sealAndEncodeBeacon(input) {
            return base64.encode(this.sealBeacon(input) || '',  base64.CharacterSet.URLSAFE, false).toString();
        },

        seal: function seal(input) {
            var ciphered, result, hmac, padCount, formatted, pseudo_iv_length;

            pseudo_iv_length = constants.PSEUDO_IV_LENGTH;

            switch (encAlgorithm) {
                case 'aes128':
                case 'aes-128-cbc' :
                case 'aes-256-cbc' :
                    pseudo_iv_length = constants.PSEUDO_AES_IV_LENGTH;
                    break;
                default:
                    pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
                    break;
            }

            hmac = createHmac(macAlgorithm, macKey, input);
            padCount = pseudo_iv_length - (input.length % pseudo_iv_length);

            formatted = [];
            formatted[0] = hmac.slice(0, pseudo_iv_length);
            formatted[1] = input;
            formatted[2] = hmac.slice(pseudo_iv_length, pseudo_iv_length + (padCount - 1));
            formatted[3] = new Buffer([padCount]);

            ciphered = createCipherSpec(encAlgorithm, encKey, padding).cipher(Buffer.concat(formatted));

            result = [];
            result[0] = ciphered;
            result[1] = createHmac(macAlgorithm, macKey, ciphered);

            return Buffer.concat(result);
        },

        sealBeacon: function sealBeacon(input) {
            var hmac, padCount, formatted, toSign, result, ciphered, pseudo_iv_length;

            pseudo_iv_length = constants.PSEUDO_IV_LENGTH;

            switch (encAlgorithm) {
                case 'aes128':
                case 'aes-128-cbc' :
                case 'aes-256-cbc' :
                    pseudo_iv_length = constants.PSEUDO_AES_IV_LENGTH;
                    break;
                default:
                    pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
                    break;
            }

            hmac = createHmac(macAlgorithm, macKey, input);
            padCount = pseudo_iv_length - (input.length % pseudo_iv_length);

            formatted = [];
            formatted[0] = input;
            formatted[1] = hmac.slice(pseudo_iv_length, pseudo_iv_length + (padCount - 1));
            formatted[2] = new Buffer([padCount]);

            ciphered = createCipherSpec(encAlgorithm, encKey, padding, hmac.slice(0, pseudo_iv_length)).cipher(Buffer.concat(formatted));

            toSign = [];
            toSign[0] = hmac.slice(0, pseudo_iv_length);
            toSign[1] = ciphered;

            result = [];
            result[0] = hmac.slice(0, pseudo_iv_length);
            result[1] = ciphered;
            result[2] = createHmac(macAlgorithm, macKey, Buffer.concat(toSign));

            return Buffer.concat(result);
        },

        decodeAndUnsealNamed: function decodeAndUnsealNamed(name, input) {
            var decodedInput = this.decodeAndUnseal(input);

            return decodedInput.slice(Buffer.byteLength(name), decodedInput.length);
        },

        decodeAndUnseal: function decodeAndUnseal(input) {
            var decodedInput = base64.decode(input, base64.CharacterSet.PPUUENCODING, false);

            return this.unseal(decodedInput);
        },

        decodeAndUnsealBeacon: function decodeAndUnsealBeacon(input) {
            var decodedInput;

            decodedInput = base64.decode(input, base64.CharacterSet.URLSAFE, false);

            return this.unsealBeacon(decodedInput);
        },

        unseal: function unseal(input) {
            var trimmed, hmac, padCount, deciphered, pseudo_iv_length, hash_digest_length;

            pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
            hash_digest_length = constants.SHA1_DIGEST_LENGTH;

            switch (encAlgorithm) {
                case 'aes128':
                case 'aes-128-cbc' :
                case 'aes-256-cbc' :
                    pseudo_iv_length = constants.PSEUDO_AES_IV_LENGTH;
                    break;
                default:
                    pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
                    break;
            }

            hash_digest_length = macAlgorithm === 'sha256' ? constants.SHA256_DIGEST_LENGTH : constants.SHA1_DIGEST_LENGTH;

            trimmed = input.slice(0, input.length - hash_digest_length);
            hmac = createHmac(macAlgorithm, macKey, trimmed);

            if (!utils.equals(hmac, input.slice(input.length - hash_digest_length, input.length))) {
                throw new Error('HMAC comparison failed');
            }

            deciphered = createCipherSpec(encAlgorithm, encKey).decipher(trimmed);

            padCount = deciphered[deciphered.length - 1];

            return deciphered.slice(pseudo_iv_length, deciphered.length - padCount);
        },

        unsealBeacon: function unsealBeacon(input) {
            var trimmed, hmac, padCount, deciphered, pseudo_iv_length, hash_digest_length;

            pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
            hash_digest_length = constants.SHA1_DIGEST_LENGTH;

            switch (encAlgorithm) {
                case 'aes128':
                case 'aes-128-cbc' :
                case 'aes-256-cbc' :
                    pseudo_iv_length = constants.PSEUDO_AES_IV_LENGTH;
                    break;
                default:
                    pseudo_iv_length = constants.PSEUDO_IV_LENGTH;
                    break;
            }

            hash_digest_length = macAlgorithm === 'sha256' ? constants.SHA256_DIGEST_LENGTH : constants.SHA1_DIGEST_LENGTH;

            trimmed = input.slice(0, input.length - hash_digest_length);
            hmac = createHmac(macAlgorithm, macKey, trimmed);

            if (!utils.equals(hmac, input.slice(input.length - hash_digest_length, input.length))) {
                throw new Error('HMAC comparison failed');
            }

            deciphered = createCipherSpec(encAlgorithm, encKey, padding, trimmed.slice(0, pseudo_iv_length)).decipher(trimmed.slice(pseudo_iv_length, trimmed.length));

            padCount = deciphered[deciphered.length - 1];

            return deciphered.slice(0, deciphered.length - padCount);
        },


        macKeyStringXorEncryptAndEncode: function macKeyStringXorEncryptAndEncode(input) {
            var encrypted, padSize, padding, rxordata, buffer, whitener;

            if (!Buffer.isBuffer(input)) {
                input = new Buffer(input);
            }

            padSize = (Math.ceil((macKey.length + input.length) / 8) * 8) - (macKey.length + input.length);

            padding = new Buffer(new Array(padSize || 8));

            rxordata = new Buffer(4);

            buffer = Buffer.concat([macKey, input, padding]);

            for (var i = 0; i < buffer.length; i++) {
                whitener = rxordata[i % rxordata.length];
                buffer[i] = buffer[i] ^ whitener;
            }

            encrypted = createCipherSpec(encAlgorithm, encKey).cipher(buffer);

            return base64.encode(encrypted, base64.CharacterSet.DEFAULT, false).toString();
        },

        macKeyStringXorDecryptAndDecode: function macKeyStringXorDecryptAndDecode(input) {
            var rxordata, i, whitener, data, decrypted, decoded;

            decoded = base64.decode(input, base64.CharacterSet.DEFAULT, false);

            decrypted = createCipherSpec(encAlgorithm, encKey).decipher(decoded);

            rxordata = new Buffer(4);

            for (i = 0; i < 4; i++) {
                rxordata[i] = decrypted[i] ^ macKey[i];
            }

            for (i = 0; i < decrypted.length; i++) {
                whitener = rxordata[i % 4];
                decrypted[i] = decrypted[i] ^ whitener;
            }

            // Ensure first 10 bytes match?
            if (!utils.equals(decrypted, macKey, Math.floor(macKey.length / 2))) {
                throw new Error('Mac key not recovered.');
            }

            data = decrypted.slice(macKey.length, decrypted.length);

            for (i = 0; i < data.length; i++) {
                if (data[i] === 0) {
                    return data.slice(0, i).toString();
                }
            }

            throw new Error('Could not recover data');
        }
    };
};

function createCipherSpec(encAlg, encKey, padding, iv) {
    return ciphers.createCipherSpec(encAlg, encKey, !!padding, iv);
}

function createHmac(macAlgorithm, macKey, input) {
    return crypto.createHmac(macAlgorithm, macKey).update(input).digest();
}

function hmacString(macAlgorithm, macKey, input) {
    macKey = ciphers.desx._truncateKey(macKey);
    return base64.encode(createHmac(macAlgorithm, macKey, input), base64.CharacterSet.PPUUENCODING, false).toString('utf8');
}

exports.createCipherSpec = createCipherSpec;

exports.createHmac = createHmac;

exports.hmacString = hmacString;
