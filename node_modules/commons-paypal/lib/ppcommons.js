/**
 *
 *  PayPal Commons for Node.js request
 *
 *  It decorate the express req object with
 *  - application name
 *  - encryptedHostName - encrypted HostName
 *  - isInternalRequest - tells if the request is comming from internal IP
 *  - rlogId - format urlencoded[base64[encrypted[pool::host]]]_hexencoded[timestamp]
 *  - correlationId - unique random id for CAL - 12 bit
 *  - uuid - unique id - 32 bit
 *  - pageStartTime - page load start time
 *  - ts - tracking service (analytics) cookie
 */
'use strict';

var os = require('os'),
    cal = require('cal'),
    path = require('path'),
    nconf = require('nconf'),
    domain = require('domain'),
    cookie = require('cookie'),
    moment = require('moment'),
    uuid = require('node-uuid'),
    utils = require('./utils'),
    tryRequire = require('try-require'),
    querystring = require('querystring'),
    pplinkpath = require('linkpath-paypal'),
    deployEnv = require('environment-paypal'),
    ppcryptutils = require('cryptutils-paypal'),
    GUIDGenerator = require('./guid-generator');

var rlogIdCryptKey = 'mjok7Ye1bVDHkCDMQZUvZ8VhkawCvhoM',
    rlogIdMacKey = '8rH6RMptN2O3kH4YwJQFyA+owRM=',
    ppcrypto = ppcryptutils({
        encryptionAlgorithm: 'des-ede3-cbc',
        macAlgorithm: 'sha1',
        encryptionKey: new Buffer(rlogIdCryptKey, 'base64'),
        macKey: new Buffer(rlogIdMacKey, 'base64')
    });

var DATE_FORMAT = 'MMM D, YYYY HH:mm:ss Z',
    appName,
    poolName,
    debugInfo,
    shutdownTimeout = 10 * 1000,
    domainErrorCounter = 0,
    MAX_DOMAIN_ERROR_ALLOWED = 50,
    encryptedHostName;

function calErrorEvent(type, error, threadId) {
    var calEvent;
    if (cal) {
        calEvent = cal.createEvent('PPCOMMONS', type);
        calEvent.status = cal.Status.ERROR;
        calEvent.addData('message', error);
        if (threadId) {
            calEvent.threadId = threadId;
        }
        calEvent.complete();
    }
}

function calDomainErrorEvent(error, threadId) {
    var calEvent;
    if (cal) {
        calEvent = cal.createEvent('DOMAIN', 'ERROR');
        calEvent.status = cal.Status.ERROR;
        calEvent.addData('errorCounter', domainErrorCounter);
        calEvent.addData('error', error);
        if (threadId) {
            calEvent.threadId = threadId;
        }
        calEvent.complete();
    }
}

/**
 * Check if DEPLOY_ENV to be live/sandbox or not.
 *  - If Live/Sandbox, check for internal IP range to check for internal request
 *  - If not, means is Internal request
 * @param req request
 * @returns {Boolean} return true if access is granted, false otherwise.
 */
function isInternalRequest(req) {
    if (deployEnv.isLive() || deployEnv.isSandbox()) {
        return utils.isInternalAddr(req);
    }
    return true;
}

function showDebugInfo(req) {
    if (deployEnv.isLive() || deployEnv.isSandbox()) {
        return utils.isDirectRequest(req);
    }
    return true;
}

/**
 * Using PPCrypto to generate rLogId
 * Spec urlencoded[base64[encrypted[pool::host]]]_hexencoded[timestamp]
 */
function rlogIdBuilder(hostName, poolName, date) {
    var timestampStr = date.toString(16),
        key = poolName + '::' + hostName,
        rlogId;
    try {
        var encryptedMachineId = ppcrypto.macKeyStringXorEncryptAndEncode(key);
        rlogId = encodeURIComponent(encryptedMachineId) + '_' + timestampStr;
    } catch (e) {
        calErrorEvent('rLogId', e);
    }
    return rlogId;
}


/**
 * Using PPCrypto to generate encryptedHostName
 * Spec encrypted[host]
 */
function encryptedHostNameBuilder(hostName) {
    var eHostName;
    try {
        eHostName = ppcrypto.macKeyStringXorEncryptAndEncode(hostName);
    } catch (e) {
        calErrorEvent('hostName', e);
    }
    return eHostName;

}

/*
 * Build Debug info
 * Read manifect.json for scm and version info
 * if this json file is missing (in local), using git commands build scm info
 */
function buildDebugInfo() {
    var root = process.cwd(),
        manifectJson = tryRequire(path.join(root, 'manifest.json'));

    if (manifectJson) {
        nconf.set('manifest', manifectJson);

        debugInfo = {
            scm : manifectJson.scm,
            version : manifectJson.version
        };
    } else {
        debugInfo = {
            scm : utils.localSCMInfo()
        };
    }
}

module.exports = function PPCommons(options) {
    var root = process.cwd(),
        pkgJson = tryRequire(path.join(root, 'package')),
        hostFQDN = process.env.HOST_FQDN,
        machineName;

    options = options || {};

    appName = pkgJson && pkgJson.name;
    poolName = options.poolName || appName;
    machineName = os.hostname();

    encryptedHostName = encryptedHostNameBuilder(machineName);

    buildDebugInfo();

    return function ppcommons(req, res, next) {
        var headers,
            cookies,
            hostName,
            rlogId,
            threadId = req.threadId,
            debug = null;

        //req._startTime - more accurate request start time in https://github.com/expressjs/morgan
        var date = req._startTime || req.pageStartTime || new Date(),
            now = date.getTime && date.getTime() || Date.now(),
            formattedDate = moment(date).format(DATE_FORMAT);

        var reqd = domain.create();
        reqd.add(req);
        reqd.add(res);

        req.headers = req.headers || {};
        //polyfilling pp_remote_addr with req.ip for dev/stage
        if (deployEnv.isNotLive() && deployEnv.isNotSandbox()) {
            req.headers.pp_remote_addr = req.headers.pp_remote_addr || utils.toIPv4(req.ip);
        }

        headers = req.headers;

        hostName = headers.host || '';

        if (hostFQDN) {
            if (hostName.indexOf('www.') === 0) {
                hostName = 'www.' + hostFQDN;
            } else {
                hostName = hostFQDN;
            }
        }

        res.locals = res.locals || {};
        res.locals.context = res.locals.context || {};

        var resourceBaseUrl = nconf.get('links:resourceBaseUrl') ||
            req.app && req.app.kraken && req.app.kraken.get('links:resourceBaseUrl');

        pplinkpath.setResourceBase(resourceBaseUrl);
        pplinkpath.linksBuilder(hostName, res);

        req.pageStartTime = now;
        req.appName = appName;
        req.isInternalRequest = isInternalRequest(req);
        req.showDebugInfo = showDebugInfo(req);

        if (headers.cookie) {
            cookies = cookie.parse(headers.cookie);
            req.ts = querystring.parse(cookies.ts);
        }

        res.header('X-Recruiting', 'If you are reading this, maybe you should be working at PayPal instead! Check out https://www.paypal.com/us/webapps/mpp/paypal-jobs');
        res.header('Paypal-Debug-Id', req.correlationId);

        if (req.showDebugInfo) {
            debug = debugInfo;
        } else if (req.isInternalRequest) {
            if (debugInfo && debugInfo.version && debugInfo.version.manifestId) {
                debug = {
                    version: {
                        manifestId: debugInfo.version.manifestId
                    }
                };
            }
        }

        rlogId = rlogIdBuilder(machineName, poolName, now);
        req.uuid = uuid.v4().replace(/-/g, '');
        req.rlogId = rlogId;
        req.guidGenerator = GUIDGenerator;

        res.locals.context.pageInfo = {
            date: formattedDate,
            hostName: encryptedHostName,
            rlogId: rlogId,
            script: 'node',
            debug: debug
        };

        reqd.run(function () {
            next();
        });

        reqd.on('error', function (e) {
            var rootTxn;

            ++domainErrorCounter;
            calDomainErrorEvent(e, threadId);

            req.model = req.model || {};
            req.model.rootTxn = req.model.rootTxn || {};

            rootTxn = req.model.rootTxn;

            //setting m_err attribute in root Txn
            rootTxn.data = rootTxn.data || {};
            rootTxn.data.m_err = e && (e.message || e.name);

            console.error('**', utils.timestamp(), 'DOMAIN error:', domainErrorCounter, e && (e.message || e.name));
            next(e);    //This will directly go to 500 handler

            if (domainErrorCounter > MAX_DOMAIN_ERROR_ALLOWED) {
                //signal process to restart  in case of > MAX_DOMAIN_ERROR_ALLOWED domain errors.
                console.error('***graceful shutdown after %d DOMAIN errors**', domainErrorCounter);
                domainErrorCounter = 0; //resetting to avoid multiple shutdown
                if (req && req.app && req.app.emit) {
                    var server = req.socket && req.socket.server;
                    if (server) {
                        req.app.emit('shutdown', server, shutdownTimeout);
                    } else {
                        process.exit(1);
                    }
                }
            }
        });
    };
};
