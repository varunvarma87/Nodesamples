'use strict';
var fs = require('fs'),
    os = require('os'),
    cal = require('cal'),
    path = require('path'),
    https = require('https'),
    httpunch = require('httpunch'),
    topos = require('topos'),
    nconf = require('nconf'),
    shell = require('shelljs'),
    assert = require('assert'),
    express = require('express'),
    kraken = require('kraken-js'),
    ppcommons = require('commons-paypal');

nconf.use('memory');
cal.setDefaultWriteStream('console');

function setupMiddleware(req, res, next) {
    req.app.set('mountpath', '/');
    next();
}

nconf.set('links:resourceBaseUrl', 'https://www.paypalobjects.com/');

var meta = require('../index'),
    trackDir = process.cwd(),
    app = {
        configure: function (config, callback) {
            topos.init(null, config);
            callback(null, config);
        },
        requestBeforeRoute: function (server) {
            server.use(setupMiddleware);
            server.use(ppcommons());
            server.use(meta(server));
        }
    },
    appWithCheckNext = {
        configure: function (config, callback) {
            topos.init(null, config);
            callback(null, config);
        },
        requestBeforeRoute: function (server) {
            server.use(setupMiddleware);
            server.use(ppcommons());
            server.use(meta(server));
            server.use(nextCheck());
        }
    },
    appProdWithCheckNext = {
        configure: function (config, callback) {
            //topos.init(null, config);
            callback(null, config);
        },
        requestBeforeRoute: function (server) {
            server.use(setupMiddleware);
            server.use(ppcommons());
            server.use(meta(server));
        }
    };

describe('check meta - NON LIVE', function () {

    var wcServer;

    before(function (next) {
        this.timeout(10000);
        process.env.NODE_ENV = 'test';
        process.chdir(path.join(__dirname, 'fixtures'));

        var child = shell.exec('npm install');
        if (child.code !== 0) {
            console.log(child.output);
            shell.exit(child.code);
        }
        require.main.filename = __dirname;

        kraken.create(app).listen(function (err, server) {
            if (err) {
                console.error(err);
            }
            wcServer = server;
            next();
        });
    });


    after(function (next) {
        process.chdir(trackDir);
        wcServer.close(next);
    });

    it('simple test', function (next) {
        inject('/meta', function (err, res) {
            var model = JSON.parse(res);
            var routes_received = model.routes;
            assert.ok(JSON.stringify(routes_received) !== '{}');
            assert.ok(routes_received['/now'][0] === 'get');
            assert.ok(model.appInfo.appName);
            next();
        });

    });

    it('simple test with trailing slash', function (next) {
        inject('/meta//', function (err, res) {
            var model = JSON.parse(res);
            var routes_received = model.routes;
            assert.ok(JSON.stringify(routes_received) !== '{}');
            assert.ok(routes_received['/now'][0] === 'get');
            assert.ok(model.appInfo.appName);
            next();
        });

    });

    it('null test', function (next) {
        inject('/hello', function (err, res) {
            assert.ok(res === 'hello world');
            next();

        });
    });

});


describe('check meta - LIVE Simulation', function () {
    var wcServer;

    before(function (next) {
        this.timeout(10000);
        process.env.DEPLOY_ENV = 'LIVE';
        process.chdir(path.join(__dirname, 'fixtures'));
        require.main.filename = __dirname;

        kraken.create(appProdWithCheckNext).listen(function (err, server) {
            if (err) {
                console.error(err);
            }
            wcServer = server;
            next();
        });
    });

    after(function (next) {
        process.chdir(trackDir);
        wcServer.close(next);
    });

    it('check production access denied', function (next) {

        var params = {"headers" : { "pp_remote_addr": '200.1.1.3'}};
        inject('/meta', function (err, res, statusCode) {
            assert.ok(statusCode === 404);
            next();
        }, params);

    });

    it('check production only manifestId and appName access accepted', function (next) {

        var params = {"headers" : { "pp_remote_addr": '10.1.1.3'}};

        inject('/meta', function (err, res) {
            var model = JSON.parse(res);
            assert.ok(model.appInfo.appName === 'sample');
            next();
        }, params);
    });

    it('check production access accepted - request to exact host', function (next) {

        var params = {
            "headers": { "pp_remote_addr": '10.1.1.3'},
            "hostname": os.hostname()
        };

        inject('/meta', function (err, res) {
            var model = JSON.parse(res);
            assert.ok(model.appInfo.appName === 'sample');
            assert.ok(model.routes);
            next();
        }, params);
    });

    it('check production access denied invalid IP', function (next) {

        var params = {"headers" : { "pp_remote_addr": '10'}};
        inject('/meta', function (err, res, statusCode) {
            assert.ok(statusCode === 404);
            next();
        }, params);
    });

    it('check production access denied no IP', function (next) {

        var params = {"headers" : { "pp_remote_addr": ''}};
        inject('/meta', function (err, res, statusCode) {
            assert.ok(statusCode === 404);
            next();
        }, params);
    });

    it('check production access accepted localhost', function (next) {

        var params = {
                "headers": { "pp_remote_addr": '127.0.0.1'},
                "hostname": os.hostname()
            };

        inject('/meta', function (err, res) {
            var model = JSON.parse(res);
            assert.ok(model.appInfo.appName === 'sample');
            assert.ok(model.routes);
            next();
        }, params);
    });

});

describe('check meta - NON-LIVE Simulation', function () {

    var wcServer;

    before(function (next) {
        process.env.DEPLOY_ENV = '';
        process.chdir(path.join(__dirname, 'fixtures'));
        require.main.filename = __dirname;

        kraken.create(appWithCheckNext).listen(function (err, server) {
            if (err) {
                console.error(err);
            }
            wcServer = server;
            next();
        });
    });


    after(function (next) {
        process.chdir(trackDir);
        wcServer.close(next);
    });

    it('check production access allowed', function (next) {
        var params = {"headers" : { 'pp_remote_addr': '10.1.1.3'}};
        inject('/meta/', function (err, res, statusCode) {
            var model = JSON.parse(res);
            assert.ok(model.appInfo.appName === 'sample');
            assert.ok(model.routes);
            assert.ok(model.services);
            assert.ok(typeof parseInt(model.services[0].port, 10) === 'number');
            next();
        }, params);

    });

});


describe('check ecv access - LIVE Simulation', function () {

    var wcServer;

    before(function (next) {
        process.env.DEPLOY_ENV = 'LIVE';
        process.chdir(path.join(__dirname, 'fixtures'));
        require.main.filename = __dirname;
        process.env.ECV_TEST_FILE = path.resolve('./control.html');

        kraken.create(appProdWithCheckNext).listen(function (err, server) {
            wcServer = server;
            next();
        });
    });

    after(function (next) {
        process.chdir(trackDir);
        wcServer.close(next);
    });

    it('check production access allowed valid IP', function (next) {
        var params = {"headers" : { 'pp_remote_addr': '10.1.1.3'}};
        inject('/ecv', function (err, res, statusCode) {
            assert(res === '<html><head><title>ECV Control: In</title></head><body><p>Request: To be in rotation</p></body></html>');
            next();
        }, params);

    });

    it('check production access allowed non-valid IP', function (next) {
        var params = {"headers" : { 'pp_remote_addr': '10'}};
        inject('/ecv', function (err, res, statusCode) {
            assert(res === '<html><head><title>ECV Control: In</title></head><body><p>Request: To be in rotation</p></body></html>');
            //assert.ok(statusCode === 404);
            next();
        }, params);

    });
});


describe('proxy meta testing', function () {

    var wcServer,
        server,
        httpsApp = express(),
        opts,
        options = {};

    before(function (next) {
        process.env.DEPLOY_ENV = 'NONLIVE';
        process.chdir(path.join(__dirname, 'fixtures'));
        options.cwd = trackDir + '/fixtures';
        require.main.filename = __dirname;

        kraken.create(app).listen(8011, function (err, server) {
            wcServer = server;
        });

        shell.exec('sh keys.sh', function () {
            opts = {
                key: fs.readFileSync('./privatekey.pem'),
                cert: fs.readFileSync('./certificate.pem')
            };

            server = https.createServer(opts, httpsApp);
            server.listen(8843);
            httpsApp.get('/metaTest', function (req, res) {
                inject('/meta', function (err, jsonResponse, statusCode) {
                    var model = JSON.parse(jsonResponse);
                    res.json(model);
                });
            });
            next();
        });

    });

    after(function (next) {
        process.chdir(trackDir);
        server.close();
        wcServer.close(next);
    });
});

function inject(path, callback, params) {
    var reqParams = {
        scheme: "http",
        method: 'GET',
        port: 8011,
        path: path,
        rejectUnauthorized: false,
        requestCert: true,
        agent: false
    };
    params = params || {};

    for (var i in params) {
        if (params.hasOwnProperty(i)) {
            reqParams[i] = params[i];
        }
    }

    var req = httpunch.get(reqParams, function (error, res) {
        if (error) {
            return callback(error, null, null);
        }
        return callback(null, res.body.toString('utf8'), res.statusCode);
    });
}

var nextCheck = module.exports = function nextCheck(arg) {
    return function (req, res, next) {
        res.end('invoked next');
    };
};

