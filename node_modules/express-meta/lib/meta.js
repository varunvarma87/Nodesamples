/**
 *
 * Responsible for generating meta information for any app using nodejs
 */
'use strict';

var SECONDS_PER_DAY = 86400,
    SECONDS_PER_HOUR = 3600,
    SECONDS_PER_MINUTE = 60;

var os = require('os'),
    fs = require('fs'),
    path = require('path'),
    topos = require('topos'),
    util = require('util'),
    tryRequire = require('try-require'),
    debug = require('debuglog')('meta');

var routes = [],
    root = process.cwd(),
    pkgJson = require(path.join(root, 'package.json')),
    metaJson = tryRequire(path.join(root, 'manifest.json')),
    aggregatedModules,
    stack = [];

/**
 * function to aggregate the modules being used in the app
 * @param data - array of package names and their versions
 * @param dir - root of the app
 * @param pkgs - package.json file of the app
 * @param callback - callback to module.exports where moduleAggregator was invoked
 */

function aggregateModules(dir, pkgs, callback) {
    var dep = pkgs.dependencies,
        mod,
        data = [],
        size = 0,
        counter = 0,
        pkg = {};
    Object.keys(dep).forEach(function (key) {
        size++;
        var modPath = path.join(dir, 'node_modules', key, 'package.json');
        fs.exists(modPath, function (exists) {
            counter++;
            if (exists) {
                pkg = {};
                mod = require(modPath);
                pkg.name = mod.name;
                pkg.version = mod.version;
                data.push(pkg);
            }
            if (counter === size) {
                aggregatedModules = data;
                callback(null, data);
            }
        });

    });

}

/**
 * initial invocation to aggregate module information
 * @param callback - callback to the module.exports
 */

function moduleAggregator(callback) {
    if (aggregatedModules) {
        callback(null, aggregatedModules);
    } else {
        aggregateModules(root, pkgJson, callback);
    }
}

/**
 * function to obtain the list of routes and their corresponding methods like get, post etc. that has been configured for the app
 */

var getRoutes = function (routes) {
    var method,
        i,
        path,
        data = {};

    for (method in routes) {
        for (i in routes[method]) {
            path = routes[method][i].path;
            if (data[path]) {
                data[path].push(method);
            } else {
                data[path] = [];
                data[path].push(method);
            }

        }
    }
    return data;
};

/**
 * function that returns the memory usage details for the app
 */
var getUsage = function () {
    var data = {},
        mem;
    mem = util.inspect(process.memoryUsage());
    data.total = parseInt(mem.split(' ')[4].replace(/,+$/, ''), 10);
    data.used = parseInt(mem.split(' ')[6], 10);
    return data;
};

/**
 * function to return the different services the app has been configured
 * obtained using topos module
 */
var getServiceInfo = function (req) {
    var info = {},
        service_info = [],
        service,
        svc,
        topos_info,
        services = req.app && req.app.kraken && req.app.kraken.get('services');

    if (services) {
        for (var serviceName in services) {
            info = {};
            info.service = serviceName;
            info.transport = services[serviceName].transport;
            info.host = services[serviceName].hostname;
            info.port = services[serviceName].port;
            info.ipport = services[serviceName].ipport;
            info.basepath = services[serviceName].basepath;
            info.server = services[serviceName].package;

            if (info.service !== 'type') {
                service_info.push(info);
            }
        }
        return service_info;
    }

    topos_info = topos.getDump();

    for (service in topos_info) {
        info = {};

        if (service === 'services') {

            for (svc in topos_info[service]) {
                info = {};
                info.service = svc;
                info.transport = topos_info[service][svc].transport;
                info.host = topos_info[service][svc].hostname;
                info.port = topos_info[service][svc].port;
                info.ipport = topos_info[service][svc].ipport;
                info.basepath = topos_info[service][svc].basepath;
                info.server = topos_info[service][svc].package;

                if (info.service !== 'type') {
                    service_info.push(info);
                }
            }

        } else {

            info.service = service;
            info.host = topos_info[service].host;
            info.port = topos_info[service].port;
            info.ipport = topos_info[service].ipport;

            if (info.service !== 'type') {
                service_info.push(info);
            }

        }
    }
    return service_info;
};

/**
 * function to obtained the various process related information
 */
var getProcessInfo = function () {
    var totalSec = process.uptime(),
        days = Math.floor(totalSec / SECONDS_PER_DAY),
        hours = Math.floor((totalSec % SECONDS_PER_DAY) / SECONDS_PER_HOUR),
        minutes = Math.floor(((totalSec % SECONDS_PER_DAY) % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE),
        seconds = totalSec % 60,
        sec = seconds.toFixed(),
        result = days + ' days ' + hours + ' hrs ' + minutes + ' min ' + sec + ' secs',
        process_info = {};
    process_info.uptime = result;
    process_info.deployEnv = process.env.DEPLOY_ENV;
    process_info.nodeEnv = process.env.NODE_ENV;
    process_info.platform = process.platform;
    process_info.architecture = process.arch;
    process_info.clusterInstances = metaJson && metaJson.info && metaJson.info.clusterInstance || '1';
    process_info.cwd = process.cwd();
    return process_info;
};

function ecvCheck(req, res) {
    var ecv_status_file;

    if (process.env.ECV_TEST_FILE) {
        ecv_status_file = process.env.ECV_TEST_FILE;
    } else {
        ecv_status_file = '/x/web/ECV/control.html';
    }
    debug('%s: ecv-monitor status check...', Date(Date.now()));
    fs.readFile(ecv_status_file, function (err, data) {
        if (err) {
            res.writeHeader(500, {
                "Content-Type": "text/plain"
            });
            res.end(err + "\n");
        } else {
            res.writeHeader(200, {
                "Content-Type": "text/html"
            });
            res.end(data);
        }
    });
}

/**
 * returns the middleware that has been configured for the app
 * @param stack argument containing the app.stack information
 * @returns array containing the middleware names
 */
function getMiddlewareInfo(stack) {

    var mware = [],
        name,
        fn;
    for (var i in stack) {
        fn = String(stack[i].handle);
        name = ((fn.substr(0, fn.indexOf('('))).split(" ")[1]);
        if (name !== '') {
            mware.push(name);
        } else {
            mware.push('No Name');
        }
    }
    return (mware);
}

module.exports = function meta() {

    return function meta(req, res, next) {
        res.setHeader('Cache-Control', 'no-cache');
        var url,
            urlLength,
            model = {},
            checkUrl,
            metaStartTime = Date.now(),
            execTime,
            params = {};

        url = req.url.replace(/\/\//g, '/');
        urlLength = url.length;

        if (url.charAt(urlLength - 1) === '/') {
            url = url.substr(0, urlLength - 1);
        }

        url = url.split('/');
        checkUrl = url[url.length - 1];

        model = req.meta || {};
        if (checkUrl === 'ecv') {
            ecvCheck(req, res, next);

        } else if (checkUrl === 'meta') {
            if (!req.isInternalRequest) {
                res.statusCode = 404;
                res.end();
                return;
            }

            stack = req.app.stack;
            routes = req.app.routes;

            var pageInfo, links;

            if (res.locals && res.locals.context) {
                pageInfo =  res.locals.context.pageInfo;
                links = res.locals.context.links;
            } else {
                pageInfo = {};
                links = {};
            }

            if (req.showDebugInfo) {    //more restricted access
                model.scm = (pageInfo.debug && pageInfo.debug.scm) || {};
                model.appInfo = (pageInfo.debug && pageInfo.debug.version) || {};
                model.appInfo.appName = req.appName || '';

                model.resourceBaseUrl = links.resourceBaseUrl || '';
                model.hostname = os.hostname();
                model.memory = getUsage();
                model.processInfo = getProcessInfo();
                model.middleware = getMiddlewareInfo(stack);
                model.routes = getRoutes(routes);
                model.services = getServiceInfo(req);
                moduleAggregator(function (err, result) {
                    if (!err) {
                        model.pkg = result;
                        execTime = Date.now() - metaStartTime;
                        model.executionTime = execTime + 'ms';
                        res.json(model);
                    }
                });
            } else {
                //show only appName and manifestId
                model.appInfo = (pageInfo.debug && pageInfo.debug.version) || {};
                model.appInfo.appName = req.appName || '';
                execTime = Date.now() - metaStartTime;
                model.executionTime = execTime + 'ms';
                res.json(model);
            }

        } else {
            return next();
        }
    };
};
