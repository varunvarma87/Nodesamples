'use strict';


var path = require('path'),
    fs = require('fs'),
    confit = require('confit'),
    async = require('async'),
    objutil = require('objutil'),
    vaultHandler = require('./vault-handler'),
    caller = require('caller'),
    deployEnv = require('environment-paypal'),
    shush = require('shush'),
    tryRequire = require('try-require'),
    debuglog = require('debuglog')('brogan-paypal');

/**
 * Wraps kraken options to provide access to vault and configures topos and services.
 * @param options
 * @returns {Object}
 */
function brogan(options) {
    var newoptions;

    if (!options) {
        options = {};
    }
    // Adding the SLR Retry as a startUp Header if the app has not configured it.
    // This will be moved to the default meddleware configuration module later

    options.startupHeaders = options.startupHeaders || {};
    if (!options.startupHeaders['X-SLR-RETRY']) {
        debuglog('adding the X-SLR-RETRY as a startup header');
        options.startupHeaders['X-SLR-RETRY'] = 'Server is starting.';
    }

    if (!options.vault) {
        try {
            //get the vault config from the <approot>/config/config.json
            //This is to avoid application to configure the value for vault options.
            //Env based overrides (development, staging etc) are not applicable for the vault property.
            var config = shush(path.join(path.dirname(caller()), 'config/config.json'));
            options.vault = (config && config.vault) || {};

        } catch (err) {
            options.vault = {};
        }
    }

    if (process.env.DEPLOY_ENV) {
        options.vault.name = getAppName(path.dirname(caller()));
        options.vault.env = process.env.DEPLOY_ENV;
    }

    newoptions = {
        protocols: {
            vault: vaultHandler(options.vault || {})
        }
    };

    objutil.deepMixin(options, newoptions);

    newoptions.onconfig = wrapconfig(newoptions);

    //binding default uncaughtException Handler
    require('./ue-handler');

    return newoptions;
}

module.exports = brogan;

/**
 * Provides a default onconfig or wraps the provided one, ensuring that brogan can contribute.
 * @param original
 * @returns {Function}
 */
function wrapconfig(options) {
    var original = options.onconfig;

    return function onconfig(config, next) {
        async.waterfall([
            function init(done) {
                debuglog('onconfig: init.');

                done(null, config, options);
            },
            loadTopos,
            configServices
        ], function (error, config) {
            if (error) {
                debuglog('error: %s', error.message);
                next(error);
                return;
            }

            if (original) {
                original(config, function(err, config) {
                    //Connection tester can be done async, independent of the kraken onConfigure callback.
                    next(err, config);
                    testConnections(config);
                });

            } else {
                //If the onConfigure does not exist
                next(null, config);
                testConnections(config);
            }
        });
    };
}

/**
 * Tests the connections using topo connection tester function.
 * @param config
 *
 */
function testConnections(config) {
    var topos, data = {}, connections;
    topos = tryRequire('topos');
    if (!topos) {
        return;
    }
    // Invoke the Connection tester (This gets invoked by default on dev environment).
    // For all the environments, a configurable option exist part of topos to enable this.
    if (config && topos.connectionTest) {
        connections = config.get('topos:connections');
        if (connections) {
            connections.forEach(function (key) {
                if (config.get(key)) {
                    data[key] = config.get(key);
                }
            });
        }
        objutil.deepMixin(config.get('services'), data);

        topos.connectionTest(config.get('topos'), data);
    }
}

function sessionMiddlewareConfig() {
    var appconfig, broganconfig;
    var appconfigJson = path.join(process.cwd(), 'config/config.json'),
        broganconfigJson = path.join(__dirname, '../config/config.json');

    try {
        appconfig = shush(appconfigJson);
        broganconfig = shush(broganconfigJson);
    }
    catch (e) {
        //No op
    }

    var appSessionConfig = appconfig && appconfig.middleware && appconfig.middleware.session,
        broganSessionConfig = broganconfig && broganconfig.middleware && broganconfig.middleware.session;

    return appSessionConfig || broganSessionConfig;
}
/**
 * Loads topos into config.
 * @param config
 * @param done
 */
function loadTopos(config, options, done) {
    var factory, topos, layout,
        sessionMiddleware, sessionConfig;

    debuglog('loading topos.');


    topos = tryRequire('topos');
    if (!topos) {
        debuglog('missing topos module');
        done(null, config, options);
        return;
    }
    /*
     * Get the aggregated layouts form topos.
     */
    layout = topos.init(config.get('topos'));

    factory = confit({
        protocols: options.protocols,
        basedir: path.join(__dirname, '../config')
    });

    sessionMiddleware = sessionMiddlewareConfig();
    if (sessionMiddleware) {
        sessionConfig = {
            middleware: {
                session: sessionMiddleware
            }
        };
    }

    //Override the "layout" Values for Service End points, only for Prod and Sandbox.
    //For all the other ENV, use the layout as a default and support the confit based overrides.
    //This change will allow developers to override service end points for staging,
    //And we can make sure that, in production, the source of truth is always coming from the layout file.
    if (deployEnv.isNotSandbox() && deployEnv.isNotProd()) {
        factory.addDefault(layout);
    } else {
        factory.addOverride(layout);
    }

    factory.create(function (error, defaults) {
        if (error) {
            debuglog('skipping due to error: %s', error.message);
            done(null, config, options);
            return;
        }

        debuglog('merging configs.');
        defaults.merge(config);
        if (sessionMiddleware) {
            defaults.use(sessionConfig);
        }
        factory.addOverride(defaults._store);
        //recreating confit factory to run all the shortshop handlers
        factory.create(function (err, data) {
            done(err, data, options);
        });
    });
}
/**
 * Configures servicecore if present.
 * @param config
 * @param done
 */
function configServices(config, options, done) {
    var servicecore;

    debuglog('configuring servicecore.');

    servicecore = tryRequire('servicecore');
    if (!servicecore) {
        debuglog('missing servicecore module');
        done(null, config);
        return;
    }

    servicecore.configuration = config.get('services') || {};

    done(null, config);
}

function getAppName(root) {

    debuglog('determining appname.');

    function look(dir) {
        var file, pkg;

        file = path.join(dir, 'package.json');

        debuglog('searching for %s.', file);

        if (fs.existsSync(file)) {
            try {
                pkg = require(file);
                return pkg.name;
            }
            catch (e) {
                debuglog('unable to determine app name; error in package.json: %s', e.message);
                throw e;
            }
        }

        if (path.dirname(dir) !== dir) {
            return look(path.dirname(dir));
        }

        debuglog('unable to determine app name; could not find package.json.');

        return undefined;
    }

    return look(root);
}
